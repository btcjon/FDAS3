[{
  "markdown": "## How-to[#](#how-to \"Permalink to this heading\")\n\nThe Panel How-to guides provide step by step recipes for solving essential problems and tasks that arise during your work. They assume that you’ve completed the Getting Started material and therefore already have some knowledge of how Panel works. There is no order to the guides, other than any potential prerequisites listed at the top of a page. Jump to the topic that is relevant to you now.\n\n## Prepare to develop[#](#prepare-to-develop \"Permalink to this heading\")\n\nDevelop in a notebook\n\nHow to effectively develop apps in a notebook environment.\n\nDevelop in an editor\n\nHow to effectively develop apps in a Python or Markdown file.\n\n## Build apps[#](#build-apps \"Permalink to this heading\")\n\nConstruct components\n\nHow to construct and customize individual components like an image or slider widget.\n\nArrange Components\n\nHow to arrange and size components on the page.\n\nStyle components\n\nHow to apply designs, themes and custom styling to components to achieve a polished look and feel.\n\nAdd interactivity\n\nHow to link add interactivity to your applications using reactive APIs.\n\nApply templates\n\nHow to use a Template to customize the look and feel of a deployed Panel app.\n\n## Use specialized UIs and APIs[#](#use-specialized-uis-and-apis \"Permalink to this heading\")\n\nBuild a sequential UI\n\nHow to build a Panel Pipeline that connects multiple panels into a sequential user interface.\n\nBuild custom components\n\nHow to extend Panel by building custom components.\n\nGenerate UIs from declared parameters (`Declarative API`)\n\nHow to use Parameterized classes with Panel to generate UIs without writing GUI code.\n\nExplicitly link parameters (`Callbacks API`)\n\nHow to link the parameters of Panel components in Python and Javascript.\n\n## Manage session tasks[#](#manage-session-tasks \"Permalink to this heading\")\n\nRegister session callbacks\n\nHow to set up callbacks on session related events (e.g. on page load or when a session is destroyed) and define periodic tasks.\n\nAccess session state\n\nHow to access and manipulate state related to the user session, HTTP request and URL arguments.\n\n## Test and debug[#](#test-and-debug \"Permalink to this heading\")\n\nEnable profiling and debugging\n\nHow to profile and debug your application using the admin dashboard and other tools.\n\nSet up testing for an application\n\nHow to set up unit tests, UI tests and load testing to ensure your applications are (and stay) robust and scalable.\n\n## Share your work[#](#share-your-work \"Permalink to this heading\")\n\nConfigure the server\n\nHow to configure the Panel server.\n\nIntegrate with other servers\n\nHow to integrate Panel in other application based on Flask, FastAPI or Django.\n\nDeploy applications\n\nHow to deploy Panel applications to various cloud providers (e.g. Azure, GCP, AWS etc.)\n\nExport apps\n\nHow to export and save Panel applications as static files.\n\nRun panel in WebAssembly\n\nHow to run Panel applications entirely in the browser using WebAssembly (Wasm), Pyodide, and PyScript.\n\n## Migrate to Panel[#](#migrate-to-panel \"Permalink to this heading\")\n\nMigrate from Streamlit\n\n[![https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)\n\nHow to migrate existing Streamlit applications to Panel."
},
{
  "markdown": "This guide addresses how to arrange components in a template layout.\n\n* * *\n\nThe default templates that are provided with Panel define four content areas on the page, which can be populated as desired: `header`, `sidebar`, `main`, and `modal` (a dialog box/popup window).\n\nLet’s create a simple app and place components in the `header`, `sidebar`, and `main` areas (see the dedicated guide on the [`modal`](https://panel.holoviz.org/how_to/templates/template_modal.html)). We’ll first save this script below into a file called `app.py`:\n\napp.py\n\nimport hvplot.pandas\nimport numpy as np\nimport pandas as pd\nimport panel as pn\n\n\\# Data and Widgets\nxs \\= np.linspace(0, np.pi)\nfreq \\= pn.widgets.FloatSlider(name\\=\"Frequency\", start\\=0, end\\=10, value\\=2)\nphase \\= pn.widgets.FloatSlider(name\\=\"Phase\", start\\=0, end\\=np.pi)\n\n\\# Interactive data pipeline\ndef sine(freq, phase):\n    return pd.DataFrame(dict(y\\=np.sin(xs\\*freq+phase)), index\\=xs)\n\ndfi\\_sine \\= hvplot.bind(sine, freq, phase).interactive()\n\n\\# Explicitly set template and add some text to the header area\ntemplate \\= pn.template.BootstrapTemplate(title\\='BootstrapTemplate')\n\\# Add components to the sidebar, main, and header\ntemplate.sidebar.extend(\\[freq, phase\\])\ntemplate.main.append(\n    pn.Card(dfi\\_sine.hvplot(min\\_height\\=400).output(), title\\='Sine')\n)\ntemplate.header.append('## Header')\n\ntemplate.servable();\n\nNow, we can activate this app on the command line:\n\npanel serve app.py \\--show \\--autoreload\n\n![example panel app](https://panel.holoviz.org/_static/images/template_arrange.png)"
},
{
  "markdown": "## Apply Templates[#](#apply-templates \"Permalink to this heading\")\n\nThe Panel `Template` component is a special layout object that helps make deployable apps look nicer. These How-to pages provide solutions for common tasks related to using templates.\n\nSet a Template\n\nHow to set a template for a deployable app.\n\nArrange Components in a Template\n\nHow to arrange components in a template layout.\n\nToggle Modal\n\nHow to toggle the modal area of a template.\n\nCustomize Template Theme\n\nHow to customize the theme of a template.\n\nBuild a Custom Template\n\nHow to build a custom template."
},
{
  "markdown": "## Set a Template[#](#set-a-template \"Permalink to this heading\")\n\nThis guide addresses how to set a template for a deployable app.\n\n* * *\n\nThere are two ways of building an application using templates; either we explicitly construct the template or we change the global template.\n\n## Explicit Constructor[#](#explicit-constructor \"Permalink to this heading\")\n\nThe explicit approach instantiates a template directly and then add components to the template’s areas.\n\nLet us construct a very simple app containing two plots in the `main` area and two widgets in the `sidebar` based on the `BootstrapTemplate` class. Let’s save this script below into a file called `app.py`.\n\napp.py\n\nimport hvplot.pandas\nimport numpy as np\nimport pandas as pd\nimport panel as pn\ntemplate \\= pn.template.BootstrapTemplate(title\\='Bootstrap Template')\n\nxs \\= np.linspace(0, np.pi)\nfreq \\= pn.widgets.FloatSlider(name\\=\"Frequency\", start\\=0, end\\=10, value\\=2)\nphase \\= pn.widgets.FloatSlider(name\\=\"Phase\", start\\=0, end\\=np.pi)\n\ndef sine(freq, phase):\n    return pd.DataFrame(dict(y\\=np.sin(xs\\*freq+phase)), index\\=xs)\n\ndef cosine(freq, phase):\n    return pd.DataFrame(dict(y\\=np.cos(xs\\*freq+phase)), index\\=xs)\n\ndfi\\_sine \\= hvplot.bind(sine, freq, phase).interactive()\ndfi\\_cosine \\= hvplot.bind(cosine, freq, phase).interactive()\n\nplot\\_opts \\= dict(responsive\\=True, min\\_height\\=400)\ntemplate.sidebar.append(freq)\ntemplate.sidebar.append(phase)\ntemplate.main.append(\n    pn.Row(        pn.Card(dfi\\_sine.hvplot(\\*\\*plot\\_opts).output(), title\\='Sine'),        pn.Card(dfi\\_cosine.hvplot(\\*\\*plot\\_opts).output(), title\\='Cosine'),    )\n)\ntemplate.servable();\n\nNote\n\nTemplates can be served or displayed just like any other Panel component, i.e. using `.servable()` or `.show()`.\n\nNow we can activate this app on the command line:\n\npanel serve app.py \\--show\n\n![example panel app with bootstrap template](https://panel.holoviz.org/_static/images/template_bootstrap.png)\n\n## Global Template[#](#global-template \"Permalink to this heading\")\n\nAnother, often simpler approach is to set the global template with the `pn.extension()` call. Once the global template is set, we can easily add components to the template using `.servable(area=...)` calls. Let’s create the same app as above but using this global template approach. We’ll save the script below into a file called `app_global.py`.\n\napp.py\n\nimport hvplot.pandas\nimport numpy as np\nimport pandas as pd\nimport panel as pn\npn.extension(template\\='bootstrap')\nxs \\= np.linspace(0, np.pi)\nfreq \\= pn.widgets.FloatSlider(name\\=\"Frequency\", start\\=0, end\\=10, value\\=2).servable(target\\='sidebar')\nphase \\= pn.widgets.FloatSlider(name\\=\"Phase\", start\\=0, end\\=np.pi).servable(target\\='sidebar')\n\ndef sine(freq, phase):\n    return pd.DataFrame(dict(y\\=np.sin(xs\\*freq+phase)), index\\=xs)\n\ndef cosine(freq, phase):\n    return pd.DataFrame(dict(y\\=np.cos(xs\\*freq+phase)), index\\=xs)\n\ndfi\\_sine \\= hvplot.bind(sine, freq, phase).interactive()\ndfi\\_cosine \\= hvplot.bind(cosine, freq, phase).interactive()\nplot\\_opts \\= dict(responsive\\=True, min\\_height\\=400)\npn.Row(\n    pn.Card(dfi\\_sine.hvplot(\\*\\*plot\\_opts).output(), title\\='Sine'),\n    pn.Card(dfi\\_cosine.hvplot(\\*\\*plot\\_opts).output(), title\\='Cosine'),\n).servable(target\\='main');\n\nNow, we can activate this app on the command line:\n\npanel serve app\\_global.py \\--show\n\n![example panel app with bootstrap template](https://panel.holoviz.org/_static/images/template_bootstrap.png)"
},
{
  "markdown": "## Toggle Modal[#](#toggle-modal \"Permalink to this heading\")\n\nThis guide addresses how to toggle the modal area of a template.\n\n* * *\n\nA modal can be opened and closed with `.open_modal()` and `.close_modal()` methods, respectively. Let’s create a modal that is activated by a button on the sidebar. We’ll first save this script below into a file called `app.py`:\n\napp.py\n\nimport hvplot.pandas\nimport numpy as np\nimport pandas as pd\nimport panel as pn\n\n\\# Explicitly set template and add some text to the header area\ntemplate \\= pn.template.BootstrapTemplate(title\\='Bootstrap Template')\n\n\\# Data and Widgets\nxs \\= np.linspace(0, np.pi)\nfreq \\= pn.widgets.FloatSlider(name\\=\"Frequency\", start\\=0, end\\=10, value\\=2)\nphase \\= pn.widgets.FloatSlider(name\\=\"Phase\", start\\=0, end\\=np.pi)\n\n\\# Interactive data pipeline\ndef sine(freq, phase):\n    return pd.DataFrame(dict(y\\=np.sin(xs\\*freq+phase)), index\\=xs)\n\ndfi\\_sine \\= hvplot.bind(sine, freq, phase).interactive()\n\n\\# Add components to the sidebar, main, and header\ntemplate.sidebar.extend(\\[freq, phase\\])\ntemplate.main.append(\n    pn.Card(dfi\\_sine.hvplot(heiht\\=200, min\\_height\\=400).output(), title\\='Sine')\n)\ntemplate.header.append('## Header')\n\\# Add some content to the modal area\ntemplate.modal.append(\"## This is a modal\")\n\\# Create a button\nmodal\\_btn \\= pn.widgets.Button(name\\=\"Click for modal\")\n\\# Callback that will open the modal when the button is clicked\ndef about\\_callback(event):\n    template.open\\_modal()\n\\# Link the button to the callback and append it to the sidebar\nmodal\\_btn.on\\_click(about\\_callback)\ntemplate.sidebar.append(modal\\_btn)\n\ntemplate.servable();\n\nNow we can activate this app on the command line. When we click the button in the sidebar, we see the modal pop up:\n\npanel serve app.py \\--show \\--autoreload\n\n![example panel app with an active modal](https://panel.holoviz.org/_static/images/template_arrange_modal.png)"
},
{
  "markdown": "## Customize Template Theme[#](#customize-template-theme \"Permalink to this heading\")\n\nThis guide addresses how to customize the theme of a template.\n\n* * *\n\nTo implement a custom template theme you should declare a generic class and a specific class implementation for all the templates that should be supported, e.g. here is an example of what the definition of a `DarkTheme` might look like for the `MaterialTemplate`.\n\nimport param\nimport panel as pn\nfrom panel.template.theme import Theme\nfrom bokeh.themes import DARK\\_MINIMAL\n\nclass DarkTheme(Theme): \\# generic class\n    \"\"\"\n    The DarkTheme provides a dark color palette\n    \"\"\"\n\n    bokeh\\_theme \\= param.ClassSelector(class\\_\\=(Theme, str), default\\=DARK\\_MINIMAL)\n\nclass MaterialDarkTheme(DarkTheme): \\# specific class\n\n    \\# css = param.Filename() Here we could declare some custom CSS to apply\n\n    \\# This tells Panel to use this implementation\n    \\_template \\= pn.template.MaterialTemplate\n\nOnce these classes are created, the themes can be imported and applied to a template. We will use the generic `DarkTheme` that is shipped with Panel to simplify the example below:\n\napp.py\n\nimport hvplot.pandas\nimport numpy as np\nimport pandas as pd\nimport panel as pn\nfrom panel.template import DarkTheme\n\n\\# Data and Widgets\nxs \\= np.linspace(0, np.pi)\nfreq \\= pn.widgets.FloatSlider(name\\=\"Frequency\", start\\=0, end\\=10, value\\=2)\nphase \\= pn.widgets.FloatSlider(name\\=\"Phase\", start\\=0, end\\=np.pi)\n\n\\# Interactive data pipeline\ndef sine(freq, phase):\n    return pd.DataFrame(dict(y\\=np.sin(xs\\*freq+phase)), index\\=xs)\n\ndfi\\_sine \\= hvplot.bind(sine, freq, phase).interactive()\n\ntemplate \\= pn.template.MaterialTemplate(title\\='Material Dark', theme\\=DarkTheme)\n\ntemplate.sidebar.append(freq)\ntemplate.sidebar.append(phase)\ntemplate.main.append(\n    pn.Card(dfi\\_sine.hvplot(min\\_height\\=400).output(), title\\='Sine')\n)\ntemplate.servable();\n\nNow, we can activate this app on the command line:\n\npanel serve app.py \\--show \\--autoreload\n\n![dark themed panel app](https://panel.holoviz.org/_static/images/template_mat_dark.png)"
},
{
  "markdown": "## Reuse sessions[#](#reuse-sessions \"Permalink to this heading\")\n\nThis guide addresses how to reuse sessions to speed up the initial rendering.\n\n* * *\n\nIn order to render a page for a visiting user the Panel server creates a so called session. This session has to execute the code associated with your application and then render the page template to HTML. This template could a custom `Template` that you instantiate explicitly (such as the `BootstrapTemplate` or `FastListTemplate`) or the basic default template. Once the frontend has rendered the initial template it will establish a Websocket connection and render the actual Panel components into the template.\n\nSince the template being rendered initially is identical each time we can make use of that to speed up the time to initial render. You can enable this behavior very simply by passing the `--reuse-sessions` argument to `panel serve`. This can also be combined with `--global-loading-spinner` to display a loading spinner on top of your entire application, e.g.:\n\npanel serve app.py \\--reuse-sessions \\--global-loading-spinner\n\n![Application with --reuse-sessions and --global-loading-spinner enabled](https://panel.holoviz.org/_images/reuse_sessions.png)\n\nTip\n\nIf you want to warm up the server with the cached sessions you can also provide the `--warm` option.\n\n## More complex cases[#](#more-complex-cases \"Permalink to this heading\")\n\nThe above approach works well for simple cases but sometimes the layout or configuration of your template is dependent on other variables, e.g. let’s say you have an app where a query parameter is used to set the title of our page:\n\nimport random\nimport panel as pn\n\npn.extension(template\\='material')\n\ncity \\= pn.state.session\\_args.get('city', \\[b'Berlin'\\])\\[0\\].decode('utf-8')\n\npn.state.template.title \\= f'{city} Weather'\n\npn.FlexBox(\n    pn.Card(pn.indicators.Number(\n        name\\='Temperature', value\\=random.randint(\\-20, 45), format\\='{value} °C'\n    ), hide\\_header\\=True),\n    pn.Card(pn.indicators.Number(\n        name\\='Humidity', value\\=random.randint(0, 100), format\\='{value}%'\n    ), hide\\_header\\=True)\n).servable()\n\n![Example of reuse sessions functionality](https://panel.holoviz.org/_images/reuse_sessions_example.png)\n\nHere the Template title is set via a query paramerer which we obtained from the `pn.state.session_args`. If we reuse this session then all sessions will use the initial value of the title. Therefore we have to define a so called `session_key_func`.\n\nThe `session_key_func` can be defined on `pn.config` (or via the `pn.extension`). For our example above we have to write a key function that ensures we cache a different version of our template depending on the value of the `city` query parameter. The `session_key_func` receives one argument (the `request` object).\n\nIn our example we will write a function that returns the ‘city’ request argument:\n\ndef session\\_key\\_func(request):\n    return request.arguments.get('city', \\[b'Berlin'\\])\\[0\\]\n\npn.extension(template\\='material', session\\_key\\_func\\=session\\_key\\_func)\n\nNow when a request arrives to serve our application it will check whether the city has been seen previously and if not it will create a new session for that unique key."
},
{
  "markdown": "## Build a Custom Template[#](#build-a-custom-template \"Permalink to this heading\")\n\nThis guide addresses how to build a custom template.\n\nPrerequisites\n\n1.  The [How to > Set a Template](https://panel.holoviz.org/how_to/templates/template_set.html) guide demonstrates how to set a template for a deployable app.\n    \n2.  The [How to > Customize Template Theme](https://panel.holoviz.org/how_to/templates/template_theme.html) guide addresses how to customize the theme of a template, which may be sufficient in many cases.\n    \n\n* * *\n\n## Build a Template in a Single File[#](#build-a-template-in-a-single-file \"Permalink to this heading\")\n\nCompletely custom templates extend the default [Jinja2](https://palletsprojects.com/p/jinja/) template in various ways. Before we dive into modifying such a template, let us take a look at the default template used by Panel:\n\n{% from macros import embed %}\n\n<!DOCTYPE html>\n<html lang\\=\"en\"\\>\n{% block head %}\n<head\\>\n    {% block inner\\_head %}\n    <meta charset\\=\"utf-8\"\\>\n    <title\\>{% block title %}{{ title | e if title else \"Panel App\" }}{% endblock %}</title\\>\n    {% block preamble %}{% endblock %}\n    {% block resources %}\n        {% block css\\_resources %}\n        {{ bokeh\\_css | indent(8) if bokeh\\_css }}\n        {% endblock %}\n        {% block js\\_resources %}\n        {{ bokeh\\_js | indent(8) if bokeh\\_js }}\n        {% endblock %}\n    {% endblock %}\n    {% block postamble %}{% endblock %}\n    {% endblock %}\n</head\\>\n{% endblock %}\n{% block body %}\n<body\\>\n    {% block inner\\_body %}\n    {% block contents %}\n        {% for doc in docs %}\n        {{ embed(doc) if doc.elementid }}\n        {% for root in doc.roots %}\n            {{ embed(root) | indent(10) }}\n        {% endfor %}\n        {% endfor %}\n    {% endblock %}\n    {{ plot\\_script | indent(8) }}\n    {% endblock %}\n</body\\>\n{% endblock %}\n</html\\>\n\nAs you may be able to note if you are familiar with jinja2 templating or similar languages, this template can easily be extended by overriding the existing `{% block ... %}` definitions. However it is also possible to completely override this default template instead.\n\nThat said it is usually easiest to simply extend an existing template by overriding certain blocks. To begin with we start by using `{% extends base %}` to declare that we are merely extending an existing template rather than defining a whole new one; otherwise we would have to repeat the entire header sections of the full template to ensure all the appropriate resources are loaded.\n\nIn this case we will extend the postamble block of the header to load some additional resources, and the contents block to redefine how the components will be laid out. Specifically, we will load bootstrap.css in the preamble allowing us to use the bootstrap grid system to lay out the output.\n\ntemplate \\= \"\"\"\n{% extends base %}\n\n<!-- goes in head -->\n{% block postamble %}\n<link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\">\n{% endblock %}\n\n<!-- goes in body -->\n{% block contents %}\n{{ app\\_title }}\n<p>This is a Panel app with a custom template allowing us to compose multiple Panel objects into a single HTML document.</p>\n<br>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm\">\n      {{ embed(roots.A) }}\n    </div>\n    <div class=\"col-sm\">\n      {{ embed(roots.B) }}\n    </div>\n  </div>\n</div>\n{% endblock %}\n\"\"\"\n\nIf you look closely we defined two different roots in the template using the `embed` macro. In order to be able to render the template we now have to first construct the `pn.Template` object with the template HTML and then populate the template with the two required roots, in this case `'A'` and `'B'` by using the `add_panel` method. If either of the roots is not defined the app is invalid and will fail to launch. The app will also fail to launch if any panels are added that are not referenced in the template.\n\nAdditionally we have also declared a new `app_title` variable in the template, which we can populate by using the `add_variable` method:\n\nimport panel as pn\nimport holoviews as hv\n\ntmpl \\= pn.Template(template)\n\ntmpl.add\\_variable('app\\_title', '<h1>Custom Template App</h1>')\n\ntmpl.add\\_panel('A', hv.Curve(\\[1, 2, 3\\]))\ntmpl.add\\_panel('B', hv.Curve(\\[1, 2, 3\\]))\n\nEmbedding a different CSS framework (like Bootstrap) in the notebook can have undesirable side-effects so a `Template` may also be given a separate `nb_template` that will be used when rendering inside the notebook:\n\nimport panel as pn\nimport holoviews as hv\npn.extension() \\# for notebook\n\nnb\\_template \\= \"\"\"\n{% extends base %}\n\n{% block contents %}\n{{ app\\_title }}\n<p>This is a Panel app with a custom template allowing us to compose multiple Panel objects into a single HTML document.</p>\n<br>\n<div style=\"display:table; width: 100%\">\n  <div style=\"display:table-cell; margin: auto\">\n    {{ embed(roots.A) }}\n  </div>\n  <div style=\"display:table-cell; margin: auto\">\n    {{ embed(roots.B) }}\n  </div>\n</div>\n{% endblock %}\n\"\"\"\n\ntmpl \\= pn.Template(template, nb\\_template\\=nb\\_template)\n\ntmpl.add\\_variable('app\\_title', '<h1>Custom Template App</h1>')\n\ntmpl.add\\_panel('A', hv.Curve(\\[1, 2, 3\\]))\ntmpl.add\\_panel('B', hv.Curve(\\[1, 2, 3\\]))\n\n## Load Template from a Separate File[#](#load-template-from-a-separate-file \"Permalink to this heading\")\n\nIf the template is larger it is often cleaner to define it in a separate file. You can either read it in as a string, or use the official loading mechanism available for Jinja2 templates by defining a `Environment` along with a `loader`.\n\nfrom jinja2 import Environment, FileSystemLoader\n\nenv \\= Environment(loader\\=FileSystemLoader('.'))\njinja\\_template \\= env.get\\_template('sample\\_template.html')\n\ntmpl \\= pn.Template(jinja\\_template)\n\ntmpl.add\\_panel('A', hv.Curve(\\[1, 2, 3\\]))\ntmpl.add\\_panel('B', hv.Curve(\\[1, 2, 3\\]))\ntmpl.servable()"
},
{
  "markdown": "## Improve the Performance[#](#improve-the-performance \"Permalink to this heading\")\n\nThere are a number of common bottlenecks and pitfalls that can significantly reduce the performance of your applications and some approaches to improve the performance of your application. This section provides various approaches to try to improve the performance of your applications.\n\nReuse sessions\n\nDiscover how to reuse sessions to improve the start render time.\n\nEnable throttling\n\nDiscover how to enable throttling to reduce the number of events being processed."
},
{
  "markdown": "This guide addresses how to make your functions interactive by binding widgets to them. This is done with the use of `pn.bind`, which allows binding the value of a widget to a function or method.\n\n* * *\n\nThe recommended approach to adding interactivity to your applications is by writing reactive functions or methods. To discover how to write one of these first, we need a function.\n\nLet’s start by creating a function. The function takes an argument `number` and will return a string of stars equal to the number:\n\ndef star\\_creator(number):\n    return \"⭐\" \\* number\n\nstar\\_creator(5)\n\nCalling a function repeatedly with different arguments is not very interactive, so as a second step we will create a widget. Here we have chosen the `pn.widgets.IntSlider` with a value of 5 and a range between 1 and 10:\n\nimport panel as pn\n\npn.extension()\n\nslider \\= pn.widgets.IntSlider(value\\=5, start\\=1, end\\=10)\nslider\n\nTo make our `star_creator` function interactive we can now bind the widget to the function and add it to a layout together with the `slider`:\n\ninteractive\\_star\\_creator \\= pn.bind(star\\_creator, slider)\n\npn.Column(slider, interactive\\_star\\_creator)\n\nNote\n\n`pn.bind` works very similarly to Python’s [`functools.partial`](https://docs.python.org/3/library/functools.html#functools.partial), except that it automatically resolves the current value of any widgets, _Parameters_ and other bound functions that are passed as arguments.\n\nInternally the layout will create a so called `ParamFunction` component to wrap the interactive function. This wrapper component will re-evaluate and update the output whenever the inputs to the function change."
},
{
  "markdown": "## Enable Throttling[#](#enable-throttling \"Permalink to this heading\")\n\nOne of the simplest ways to avoid slowing down your application is simply to control how often events from the frontend trigger code execution in Python. Particularly when using sliders this can be a problem. To solve this issue sliders offer `value_throttled` parameters which are updated only when the user releases the slider unlike the `value` parameter which is updated continuously as the slider is dragged. If you are building apps using the reactive `pn.bind` function you can depend on the `value_throttled` parameter directly:\n\nimport panel as pn\npn.extension()\n\ndef output(value):\n    return value\n\nslider \\= pn.widgets.IntSlider(end\\=10)\nbound\\_output \\= pn.bind(output, slider.param.value\\_throttled)\npn.Row(slider, bound\\_output)\n\nAlternatively, you can also ensure that all sliders only update on mouse release if you set `pn.config.throttled = True`."
},
{
  "markdown": "## Add interactivity with generators[#](#add-interactivity-with-generators \"Permalink to this heading\")\n\nThis guide addresses how to use generators to build interactive components. This is done with the use of `pn.bind`, which binds a function or method to the value of a widget. Compared to simple reactive functions this allows for more complex interactivity.\n\n* * *\n\nimport asyncio\nimport time\n\nimport panel as pn\n\npn.extension()\n\nLet us say we have some action that is triggered by a widget, such as a button, and while we are computing the results we want to provide feedback to the user. Using imperative programming this involves writing callbacks that update the current state of our components. This is complex and really we prefer to write reactive components. This is where _generator functions_ come in.\n\nImportant\n\nA _generator_ function is a function that use `yield` to _return_ results as they are produced during the execution. It is not allowed to `return` anything, but can use `return` to _break_ the execution. For an introduction to _generator functions_ check out [Real Python | Introduction to generator functions](https://realpython.com/introduction-to-python-generators/).\n\nIn the example below we add a `Button` to trigger some calculation. Initially the calculation hasn’t yet run, so we check the value provided by the `Button` indicating whether a calculation has been triggered and while it is `False` we `yield` some text and `return`. However, when the `Button` is clicked the function is called again with `run=True` and we kick off some calculation. As this calculation progresses we can `yield` updates and then once the calculation is successful we `yield` again with the final result:\n\nrun \\= pn.widgets.Button(name\\=\"Press to run calculation\", align\\='center')\n\ndef runner(run):\n    if not run:\n        yield \"Calculation did not run yet\"\n        return\n    for i in range(101):\n        time.sleep(0.01) \\# Some calculation\n        yield pn.Column(\n            f'Running ({i}/100%)', pn.indicators.Progress(value\\=i)\n        )\n    yield \"Success ✅︎\"\npn.Row(run, pn.bind(runner, run))\n\nThis provides a powerful mechanism for providing incrememental updates as we load some data, perform some data processing, etc.\n\nThis can also be combined with asynchronous processing, e.g. to dynamically stream in new data as it arrives:\n\nimport random\n\nasync def slideshow():\n    index \\= 0\n    while True:\n        url \\= f\"https://picsum.photos/800/300?image={index}\"\n\n        if pn.state.\\_is\\_pyodide:\n            from pyodide.http import pyfetch\n            img, \\_ \\= await asyncio.gather(pyfetch(url), asyncio.sleep(1))\n            yield pn.pane.JPG(await img.bytes())\n\n        import aiohttp\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as resp:\n                img, \\_ \\= await asyncio.gather(resp.read(), asyncio.sleep(1))\n                yield pn.pane.JPG(img)\n        index \\= (index + 1) % 10\n\npn.Row(slideshow)"
},
{
  "markdown": "## Add reactivity to components[#](#add-reactivity-to-components \"Permalink to this heading\")\n\nThis guide addresses how to bind _Parameters_ and bound functions on components.\n\nNew in version 1.0.0: Bind _Parameters_, widgets and bound functions to component _Parameters_.\n\n* * *\n\nThe power to binding _Parameters_, widgets and interactive functions to component _Parameters_ can be used with all of Panel’s widgets and panes. This provides a powerful way to add interactivity to an application and update specific _Parameters_ without writing callbacks.\n\nLet’s start with an using existing components to give you an idea of the power behind this. In this example we bind the value of a slider widget to the `page_size` _Parameter_ of the [Tabulator](https://panel.holoviz.org/reference/widgets/Tabulator.html) widget. This will allow you to change the page size of the table with the slider:\n\nimport pandas as pd\nimport panel as pn\n\npn.extension(\"tabulator\")\n\ndf \\= pd.read\\_csv(\"https://datasets.holoviz.org/penguins/v1/penguins.csv\")\n\nslider \\= pn.widgets.IntSlider(value\\=5, start\\=1, end\\=10, name\\='page\\_size')\ntabulator \\= pn.widgets.Tabulator(df, page\\_size\\=slider, pagination\\=\"remote\")\n\npn.Column(slider, tabulator)\n\n## Binding bound function on components[#](#binding-bound-function-on-components \"Permalink to this heading\")\n\nOften times the value of a widget or _Parameter_ will not map directly onto the _Parameter_ you want to set. In these cases, you can write a reactive function (using `pn.bind`), which transforms the values of the inputs.\n\nLet’s say we have a function that takes a string and a number as input:\n\ndef object\\_creator(string, number):\n    return string \\* number\n\nobject\\_creator('🐘', 5)\n\nNow we can bind `IntSlider` and the `Select` widgets to the `object_creator` to create an interactive string. Once we have a reactive function we can pass it to a component, e.g. `Markdown` to render this:\n\nslider \\= pn.widgets.IntSlider(value\\=5, start\\=1, end\\=10)\nselect \\= pn.widgets.Select(value\\=\"⭐\", options\\=\\[\"⭐\", \"🐘\"\\])\n\niobject \\= pn.bind(object\\_creator, select, slider)\n\npn.Row(slider, select, pn.pane.Markdown(iobject))\n\nThis approach is preferred over rendering reactive functions directly because it is more efficient and updates only the specific _Parameters_ that are being changed.\n\nIf you want to update multiple _Parameters_ at the same time you can pass a reactive function (or **Parameter**) as the `refs` keyword argument. The function (or **Parameter**) must return a dictionary of parameters to update, e.g. let’s say you wanted to write a function that returns both\n\nslider \\= pn.widgets.IntSlider(value\\=5, start\\=1, end\\=10, name\\='Number')\nselect \\= pn.widgets.RadioButtonGroup(value\\=\"⭐\", options\\=\\[\"⭐\", \"🐘\"\\], name\\='String', align\\='center')\nsize \\= pn.widgets.IntSlider(value\\=12, start\\=6, end\\=24, name\\='Size')\n\ndef refs(string, number, size):\n    return {\n        'object': string \\* number,\n        'styles': {'font-size': f'{size}pt'}\n    }\n\nirefs \\= pn.bind(refs, select, slider, size)\n\npn.Row(slider, size, select, pn.pane.Markdown(refs\\=irefs))\n\nIn this way we can update both the current `object` and the `styles` **Parameter** of the `Markdown` pane simultaneously."
},
{
  "markdown": "## Cache Data[#](#cache-data \"Permalink to this heading\")\n\nCaching data and computation is one of the most effective ways to speed up your applications, especially when working with large datasets or performing expensive computations that don’t depend on any extraneous state. Panel’s architecture is well suited towards caching since multiple user sessions can run in the same process and therefore have access to Panel’s global `state` object. These How-to guides address common tasks related to caching.\n\nManually Cache\n\nHow to manually cache data and objects on `pn.state.cache`.\n\nAutomatically Cache\n\nHow to use the `panel.cache` decorator to memoize (i.e. cache the output of) functions automatically."
},
{
  "markdown": "## Make interactive data workflows[#](#make-interactive-data-workflows \"Permalink to this heading\")\n\nThis guide addresses how to bind interactive data pipelines to a component using `hvplot.interactive`. This is done by combining Panels widgets with [hvplot](https://hvplot.holoviz.org/).\n\n* * *\n\n`hvplot.interactive` is a tool to get better control over your data pipelines. This is done by replacing the constant parameters in your pipeline with widgets (e.g., a number slider) that will automatically get displayed next to your pipeline output and trigger an output update on changes. With this approach, all your pipeline parameters are available in one place, and you get complete interactive control over the pipeline. For more information, check out the [hvPlot documentation](https://panel.holoviz.org/how_to/interactivity/hvplot_interactive.html).\n\nLet’s start by fetching some data:\n\nimport pandas as pd\n\ndf \\= pd.read\\_csv('https://datasets.holoviz.org/penguins/v1/penguins.csv')\ndf.head()\n\n|     | species | island | bill\\_length\\_mm | bill\\_depth\\_mm | flipper\\_length\\_mm | body\\_mass\\_g | sex | year |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 0   | Adelie | Torgersen | 39.1 | 18.7 | 181.0 | 3750.0 | male | 2007 |\n| 1   | Adelie | Torgersen | 39.5 | 17.4 | 186.0 | 3800.0 | female | 2007 |\n| 2   | Adelie | Torgersen | 40.3 | 18.0 | 195.0 | 3250.0 | female | 2007 |\n| 3   | Adelie | Torgersen | NaN | NaN | NaN | NaN | NaN | 2007 |\n| 4   | Adelie | Torgersen | 36.7 | 19.3 | 193.0 | 3450.0 | female | 2007 |\n\nWe now want to create select widgets for the column `species` and a slider for `year`. We can do this with Panel’s widgets:\n\nimport panel as pn\n\npn.extension('tabulator')\n\nspecies\\_widget \\= pn.widgets.Select(name\\=\"species\", options\\=\\[\"Adelie\", \"Gentoo\", \"Chinstrap\"\\])\nyear\\_widget \\= pn.widgets.IntSlider(name\\=\"year\", start\\=2007, end\\=2009)\n\nLet’s then use these to filter the data. We can do this by using `hvplot.interactive` and passing the `species_widget` as the `species` parameter and the `year_widget` as the `year` parameter. In our case, we want the year always to be greater than or equal to the widget’s value.\n\nimport hvplot.pandas  \\# Enable interactive\n\nidf \\= df.interactive()\nidf \\= idf\\[(idf\\[\"species\"\\] \\== species\\_widget) & (idf\\[\"year\"\\] \\>= year\\_widget)\\]\n\nidf.head()\n\nSimilarly we can use other pandas features in the same way.\n\nhead\\_widget \\= pn.widgets.IntSlider(name\\=\"Head\", start\\=1, end\\=10)\\\\\n\nidf.head(head\\_widget)\n\nBecause we are already using `hvplot`, we can use the other powerful API of plotting the data with `hvplot`:\n\nidf.hvplot(kind\\=\"scatter\", x\\=\"bill\\_length\\_mm\", y\\=\"bill\\_depth\\_mm\", by\\=\"sex\")\n\nThe default is to include both the widgets and the interactive panel (graph or table) when we display the interactive dataframe. If we wish to display them separately we can access the widgets and the panel as .widgets and .panel() respectively.\n\npn.Column(\n    idf.widgets(),\n    pn.Spacer(height\\=30),\n    \"Selected penguins\",\n    idf.head().panel(),\n)\n\nHowever we can also use bind the interactive pipeline we have built to a Panel component, e.g. a `Tabulator` widget:\n\npn.Row(\n    idf.widgets(),\n    pn.widgets.Tabulator(idf, page\\_size\\=10, pagination\\='remote'),\n)"
},
{
  "markdown": "## Manually Cache[#](#manually-cache \"Permalink to this heading\")\n\nThis guide addresses how to cache data and objects globally across user sessions - `pn.state.cache`.\n\n* * *\n\nThe `panel.state.cache` object is a simple dictionary that is shared between all sessions on a particular Panel server process. This makes it possible to load large datasets (or other objects you want to share) once and subsequently access the cached object.\n\nTo assign to the cache manually, simply put the data load or expensive calculation in an `if`/`else` block which checks whether the custom key is already present:\n\nif 'data' in pn.state.cache:\n    data \\= pn.state.cache\\['data'\\]\nelse:\n    pn.state.cache\\['data'\\] \\= data \\= ... \\# Load some data or perform an expensive computation\n\nAlternatively, the `as_cached` helper function provides a slightly cleaner way to write the caching logic. Instead of writing a conditional statement you write a function that is executed only when the inputs to the function change. If provided, the `args` and `kwargs` will also be hashed making it easy to cache (or memoize) on the arguments to the function:\n\ndef load\\_data(\\*args, \\*\\*kwargs):\n    return ... \\# Load some data\n\ndata \\= pn.state.as\\_cached('data', load\\_data, \\*args, \\*\\*kwargs)\n\nNow, the first time the app is loaded the data will be cached and subsequent sessions will simply look up the data in the cache, speeding up the process of rendering. If you want to warm up the cache before the first user visits the application you can also provide the `--warm` argument to the `panel serve` command, which will ensure the application is initialized as soon as it is launched. If you want to populate the cache in a separate script from your main application you may also provide the path to a setup script using the `--setup` argument to `panel serve`."
},
{
  "markdown": "## Arrange Components[#](#arrange-components \"Permalink to this heading\")\n\nArranging components on the page and controlling their size is a major part of building an application. In this section we will go over different ways of achieving fixed and responsive layouts and otherwise arrange components on the page.\n\nCustomize Spacing\n\nHow to customize the spacing between elements.\n\nAlign Components\n\nHow to customize the alignment between components.\n\nControl Size\n\nHow to control the size of components.\n\n## Examples[#](#examples \"Permalink to this heading\")\n\n![](https://assets.holoviz.org/panel/how_to/layout/dynamic_tabs.png)\n\nUse the `dynamic` parameter of `Tabs` to defer rendering until a tab is selected."
},
{
  "markdown": "## Automatically Cache[#](#automatically-cache \"Permalink to this heading\")\n\nThis guide addresses how to use the `panel.cache` decorator to memoize (i.e. cache the output of) functions automatically.\n\n* * *\n\nThe `pn.cache` decorator provides an easy way to cache the outputs of a function depending on its inputs (i.e. `memoization`). If you’ve ever used the Python `@lru_cache` decorator you will be familiar with this concept. However the `pn.cache` functions support additional cache `policy`s apart from LRU (least-recently used), including `LFU` (least-frequently-used) and ‘FIFO’ (first-in-first-out). This means that if the specified number of `max_items` is reached Panel will automatically evict items from the cache based on this `policy`. Additionally items can be deleted from the cache based on a `ttl` (time-to-live) value given in seconds.\n\n## Caching in memory[#](#caching-in-memory \"Permalink to this heading\")\n\nThe `pn.cache` decorator can easily be combined with the different Panel APIs including `pn.bind` and `pn.depends` providing a powerful way to speed up your applications.\n\n@pn.cache(max\\_items\\=10, policy\\='LRU')\ndef load\\_data(path):\n    return ... \\# Load some data\n\nOnce you have decorated your function with `pn.cache` any call to `load_data` will be cached in memory until `max_items` value is reached (i.e. you have loaded 10 different `path` values). At that point the `policy` will determine which item is evicted.\n\nThe `pn.cache` decorator can easily be combined with `pn.bind` to speed up rendering of your reactive components:\n\nimport pandas as pd\nimport panel as pn\n\npn.extension('tabulator')\n\nselect \\= pn.widgets.Select(options\\={\n    'Penguins': 'https://raw.githubusercontent.com/mwaskom/seaborn-data/master/penguins.csv',\n    'Diamonds': 'https://raw.githucbusercontent.com/mwaskom/seaborn-data/master/diamonds.csv',\n    'Titanic': 'https://raw.githubusercontent.com/mwaskom/seaborn-data/master/titanic.csv',\n    'MPG': 'https://raw.githubusercontent.com/mwaskom/seaborn-data/mastser/mpg.csv'\n})\n\n@pn.cache\ndef fetch\\_data(url):\n    return pd.read\\_csv(url)\n\npn.Column(select, pn.bind(pn.widgets.Tabulator, pn.bind(fetch\\_data, select), page\\_size\\=10))\n\n## Disk caching[#](#disk-caching \"Permalink to this heading\")\n\nIf you have `diskcache` installed you can also cache the results to disk by setting `to_disk=True`. The `diskcache` library will then cache the value to the supplied `cache_path` (defaulting to `./cache`). Making use of disk caching allows you to cache items even if the server is restarted.\n\n## Clearing the cache[#](#clearing-the-cache \"Permalink to this heading\")\n\nOnce a function has been decorated with `pn.cache` you can easily clear the cache by calling `.clear()` on that function, e.g. in the example above you could call `load_data.clear()`. If you want to clear all caches you may also call `pn.state.clear_caches()`.\n\n## Per-session caching[#](#per-session-caching \"Permalink to this heading\")\n\nBy default any functions decorated or wrapped with `pn.cache` will use a global cache that will be reused across multiple sessions, i.e. multiple users visiting your app will all share the same cache. If instead you want a session-local cache, that only reuses cached outputs for the duration of each visit to your application, you can set `pn.cache(..., per_session=True)`."
},
{
  "markdown": "## Add concurrent processing[#](#add-concurrent-processing \"Permalink to this heading\")\n\nWhen deploying a Panel application to be accessed by multiple users they will often access the same server simultaneously. To maintain responsiveness of the application when multiple users are interacting with it at the same time there are multiple approaches to concurrency, each with their own drawbacks and advantages:\n\n1.  `Load balancing`: A load balancer distributes network traffic between multiple instances of the Panel application. This ensures that the load is distributed across multiple servers but also requires a lot configuration and resources.\n    \n2.  `Multi-process server instance`: Launches your app with multiple processes on a single machine. Much simpler to set up than a load balancer but the load is not distributed equally across processes and you are limited by the compute and memory resources on one machine.\n    \n3.  `Threading`: Attempts to distribute processing across multiple threads. Effectiveness depends on the operations being performed, I/O bound and CPU bound operations that release the GIL can easily be made concurrent in this way.\n    \n4.  `AsyncIO`: Allows asynchronously processing I/O bound operations. Effective for many concurrent I/O operations but requires rewriting your application and callbacks to make use of `async`/`await` paradigm.\n    \n\n## Scaling across processes[#](#scaling-across-processes \"Permalink to this heading\")\n\nBoth load balancing and starting multiple processes effectively spin up multiple copies of the same application and distribute the load across the processes. This results in duplication and therefore significantly higher overhead (basically scaling linearly with the number of processes). In applications where you are relying on global state (e.g. the `pn.state.cache`) this can introduce significant challenges to ensure that application state stays synchronized.\n\nSet up Load Balancing\n\nDiscover how-to configure load balancing (e.g. using NGINX) to scale Panel apps across processes.\n\nLaunch multiple processes\n\nDiscover how to launch multiple processes on a Panel server to add scaling.\n\n## Scaling within a single process[#](#scaling-within-a-single-process \"Permalink to this heading\")\n\nThreading and async are both approaches to speed up processing in Python using concurrency in a single Python process. Since we can’t provide a complete primer on either threading or asynchronous processing here, if you are not familiar with these concepts we recommend reading up on them before continuing. Read about [threading in Python here](https://realpython.com/intro-to-python-threading/) and [AsyncIO here](https://realpython.com/async-io-python/).\n\nWhen to use which approach cannot be answered easily and is never completely clear cut. As a general guide however use `asyncio` can scale almost arbitrarily allowing you to perform thousands or even millions of IO bound operations concurrently, while threading limits you to the number of available threads. In practice this may never actually become relevant so the other main differences are that `async` coroutines are significantly more lightweight but that you have to carefully consider accessing shared objects across threads. Using `async` coroutines makes it very clear where concurrency occurs and therefore can make it easier to avoid race conditions and avoid having to think about locking a thread to access shared objects. However, in some situations threading can also be useful for CPU intensive operations where the operation being executed [releases the GIL](https://realpython.com/python-gil/), this includes many NumPy, Pandas and Numba functions.\n\nEnable Automatic Threading\n\nDiscover how to enable threading to distribute processing across threads.\n\nSet up Manual Threading\n\nDiscover how to manually set up a Thread to process an event queue.\n\nUse Asynchronous Processing\n\nDiscover how to make use of asynchronous callbacks to handle I/O bound operations concurrently."
},
{
  "markdown": "## Customize Spacing[#](#customize-spacing \"Permalink to this heading\")\n\nThis guide addresses how to customize the spacing between elements.\n\n* * *\n\nThe spacing between components is controlled by setting the margin parameter on individual components and by adding Spacers between components.\n\n## Margin Parameter[#](#margin-parameter \"Permalink to this heading\")\n\nThe `margin` parameter can be used to create space around an element defined as the number of pixels at the (top, right, bottom, and left). The `margin` can be defined in one of three ways:\n\n1.  By setting `margin=25`, which will set the margin on all sides to 25 px.\n    \n2.  By setting `margin=(25, 50)`, which will set the top and bottom margins to 25 px and the left and right margins to 50 px.\n    \n3.  By setting `margin=(25, 50, 75, 100)`, which will set the top, right, bottom, and left margins to 25, 50, 75, and 100 px, respectively.\n    \n\nFor example, let’s create three buttons and customize their margin. To make it easier to see the margin area, we’ll embed each into a `Column` and then shade the `Column` background.\n\nimport panel as pn\n\npn.extension() \\# for notebook\n\npn.Row(\n    pn.Column(pn.widgets.Button(name\\='B1', width\\=100, margin\\=25), styles\\={'background': '#f0f0f0'}),\n    pn.Column(pn.widgets.Button(name\\='B2', width\\=100, margin\\=(40, 50)), styles\\={'background': '#f0f0f0'}),\n    pn.Column(pn.widgets.Button(name\\='B3', width\\=100, margin\\=(25, 50, 75, 100)), styles\\={'background': '#f0f0f0'}))\n\n## Spacer Components[#](#spacer-components \"Permalink to this heading\")\n\nSpacer components make it easy to put fixed or responsive spacing between objects.\n\nFirst, let’s add fixed-width Spacers in between some numbers:\n\npn.Row(\n    1,\n    pn.Spacer(width\\=200),\n    2,\n    pn.Spacer(width\\=100),\n    3,\n    pn.Spacer(width\\=50),\n    4,\n    pn.Spacer(width\\=25),\n    5\n)\n\nInstead of absolute spacing, we could use `VSpacer` or `HSpacer` components to provide responsive vertical and horizontal spacing, respectively. Using these components we can space objects equidistantly in a layout and allow the empty space to shrink when the browser is resized.\n\npn.Row(\n    pn.layout.HSpacer(),\n    '\\* Item 1\\\\n\\* Item2',\n    pn.layout.HSpacer(),\n    '1. First\\\\n2\\. Second',\n    pn.layout.HSpacer()\n)\n\n* * *"
},
{
  "markdown": "## Align Components[#](#align-components \"Permalink to this heading\")\n\nThis guide addresses how to customize the alignment between components.\n\n* * *\n\nThe `align` parameter controls how components align vertically and horizontally. It supports ‘start’, ‘center’, and ‘end’ values and can be set for both horizontal and vertical directions at once or for each separately by passing in a tuple of the form `(horizontal, vertical)`.\n\nOne common use-case where alignment is important is when placing multiple items with different heights in a `Row`. Let’s create a big button and align a slider to the center of the button using `align=center`:\n\nimport panel as pn\npn.extension() \\# for notebook\n\nbutton \\= pn.widgets.Button(name\\='Test', height\\=100)\nslider \\= pn.widgets.IntSlider(align\\='center')\n\npn.Row(button, slider, styles\\={'background': 'lightgrey'})\n\nNow, let’s look at aligning components in a grid with an instance of passing in `(horizontal, vertical)`:\n\npn.GridBox(\n    pn.widgets.Button(name\\='Test', height\\=100),\n    pn.widgets.IntSlider(align\\='center'),\n    pn.widgets.TextInput(name\\='Test', height\\=100, width\\=100, align\\=('center')),\n    pn.widgets.TextInput(width\\=150, align\\=('start', 'end')),\n    ncols\\=2,\n    styles\\={'background': 'lightgrey'}\n)\n\n* * *"
},
{
  "markdown": "## Load balancing[#](#load-balancing \"Permalink to this heading\")\n\nSetting up load balancing is a huge topic dependent on the precise system you are using so we won’t go into any specific implementation here. In most cases you set up a reverse proxy (like NGINX) to distribute the load across multiple application servers. If you are using a system like Kubernetes it will also handle spinning up the servers for you and can even do so dynamically depending on the amount of concurrent users to ensure that you are not wasting resources when there are fewer users.\n\n![](https://www.nginx.com/wp-content/uploads/2014/07/what-is-load-balancing-diagram-NGINX-1024x518.png)\n\nDiagram showing concept of load balancing (NGINX)\n\nLoad balancing is the most complex approach to set up but is guaranteed to improve concurrent usage of your application since different users are not contending for access to the same process or even necessarily the same physical compute and memory resources. At the same time it is more wasteful of resources since it potentially occupies multiple machines and since each process is isolated there is no sharing of cached data or global state.\n\nTo get started configuring a load balancer take a look at the [Bokeh documentation](https://docs.bokeh.org/en/latest/docs/user_guide/server/deploy.html#load-balancing) which provides example configurations for Apache and NGINX."
},
{
  "markdown": "## Launch multiple processes[#](#launch-multiple-processes \"Permalink to this heading\")\n\nLaunching a Panel application on multiple processes is effectively a simpler way to scale your application. One major advantage is that it is easy to set up, when deploying your application with `panel serve` simply configure `--num-procs N`, where N is the number of processes. Generally choose an `N` that is no larger than the number of processors on your machine.\n\nThe main limitation is that the underlying Tornado multi-process mode does not balance connections across processes. Rather, any incoming connection will be assigned to the first server process that accepts it. Typically any idle process can get a new client regardless of how many clients it already has. In general the resulting distribution of clients across processes will be unequal. Moreover, this still uses significantly more resources since each process has the same overhead and all processes will be contending for the same memory and compute resources. However if your application is single-threaded and you have sufficient memory this is a simple way to make your application scale."
},
{
  "markdown": "## Control Size[#](#control-size \"Permalink to this heading\")\n\nThis guide addresses how to control the size of components.\n\n* * *\n\nComponents can use either one of the responsive sizing modes or absolute sizing.\n\nImportant\n\nUnlike other components, the size of a plot component is usually determined by the underlying plotting library, so it may be necessary to ensure that you set the size and aspect when declaring the plot.\n\n## Absolute Sizing[#](#absolute-sizing \"Permalink to this heading\")\n\nTo set a fixed size on a component, it is usually sufficient to set a `width` or `height`, but in certain cases setting `sizing_mode='fixed'` explicitly may also be required.\n\nLet’s create a simple example that fixes the height or width of several components:\n\nimport panel as pn\npn.extension() \\# for notebook\n\npn.Row(\n    pn.pane.Markdown('ABCDE', styles\\={'background': '#f0f0f0'}, width\\=75, height\\=100),\n    pn.widgets.FloatSlider(width\\=200, styles\\={'background': '#f0f0f0'}),\n    pn.pane.PNG('https://upload.wikimedia.org/wikipedia/commons/4/47/PNG\\_transparency\\_demonstration\\_1.png', width\\=300, styles\\={'background': '#f0f0f0'}),\n)\n\nNow let’s use `sizing_mode='fixed'` to create a fixed-size component. This will retain the object’s original width and height regardless of any subsequent browser window resize events. This is usually the default behavior and simply respects the provided width and height.\n\npn.pane.PNG('https://upload.wikimedia.org/wikipedia/commons/8/89/PNG-Gradient.png', sizing\\_mode\\='fixed')\n\n## Responsive Sizing[#](#responsive-sizing \"Permalink to this heading\")\n\nMost panel objects support reactive sizing which adjusts depending on the size of the visible area of a web page. Responsive sizing modes can be controlled using the `sizing_mode` parameter with the following options:\n\n*   **“stretch\\_width”**: Component will responsively resize to stretch to the available width, without maintaining any aspect ratio. The height of the component depends on the type of the component and may be fixed or fit to component’s contents. To demonstrate this behavior we create a Row with a fixed height and responsive width to fill:\n    \n\npn.Row(\n    pn.pane.Str(styles\\={'background': '#f0f0f0'}, height\\=100, sizing\\_mode\\='stretch\\_width'),\n    width\\_policy\\='max', height\\=200\n)\n\n*   **“stretch\\_height”**: Component will responsively resize to stretch to the available height, without maintaining any aspect ratio. The width of the component depends on the type of the component and may be fixed or fit to component’s contents. To demonstrate the filling behavior in a document we declare a Column with a fixed height for the component to fill:\n    \n\npn.Column(\n    pn.pane.Str(styles\\={'background': '#f0f0f0'}, sizing\\_mode\\='stretch\\_height', width\\=200),\n    height\\=200\n)\n\n*   **“stretch\\_both”**: Component is completely responsive, independently in width and height, and will occupy all the available horizontal and vertical space, even if this changes the aspect ratio of the component. To demonstrate this behavior we will declare a Column with a fixed height and responsive width for the component to fill:\n    \n\npn.Column(\n    pn.pane.Str(styles\\={'background': '#f0f0f0'}, sizing\\_mode\\='stretch\\_both'),\n    height\\=200, width\\_policy\\='max'\n)\n\n*   **“scale\\_height”**: Component will responsively resize to stretch to the available height, while maintaining the original or provided aspect ratio.\n    \n*   **“scale\\_width”**: Component will responsively resize to stretch to the available width, while maintaining the original or provided aspect ratio.\n    \n*   **“scale\\_both”**: Component will responsively resize to both the available width and height, while maintaining the original or provided aspect ratio. For example:\n    \n\npn.Column(\n    pn.pane.PNG(\n        'https://upload.wikimedia.org/wikipedia/commons/4/47/PNG\\_transparency\\_demonstration\\_1.png',\n        sizing\\_mode\\='scale\\_both'\n    ), height\\=400, width\\=500, styles\\={'background': '#f0f0f0'})\n\n* * *"
},
{
  "markdown": "## Enable Automatic Threading[#](#enable-automatic-threading \"Permalink to this heading\")\n\nUsing threading in Panel can either be enabled manually, e.g. by managing your own thread pool and dispatching concurrent tasks to it, or it can be managed by Panel itself by setting the `config.nthreads` parameter (or equivalently by setting it with `pn.extension(nthreads=...)`. This will start a `ThreadPoolExecutor` with the specified number of threads (or if set to `0` it will set the number of threads based on your system, i.e. `min(32, os.cpu_count() + 4)`).\n\nWhenever an event is generated or a periodic callback fires Panel will then automatically dispatch the event to the executor. An event in this case refers to any action generated on the frontend such as the manipulation of a widget by a user or the interaction with a plot. If you are launching an application with `panel serve` you should enable this option configure this option on the CLI by setting `--num-threads`.\n\nTo demonstrate the effect of enabling threading take this example below:\n\nimport panel as pn\n\npn.extension(nthreads\\=2)\n\ndef button\\_click(event):\n    print(f'Button clicked for the {event.new}th time.')\n    time.sleep(2) \\# Simulate long running operation\n    print(f'Finished processing {event.new}th click.')\n\nbutton \\= pn.widgets.Button(name\\='Click me!')\n\nbutton.on\\_click(button\\_click)\n\nWhen we click the button twice successively in a single-threaded context we will see the following output:\n\n\\> Button clicked for the 1th time.\n... 2 second wait\n\\> Finished processing 1th click.\n\\> Button clicked for the 2th time.\n... 2 second wait\n\\> Finished processing 2th click.\n\nIn a threaded context on the other hand the two clicks will be processed concurrently:\n\n\\> Button clicked for the 1th time.\n\\> Button clicked for the 2th time.\n... 2 second wait\n\\> Finished processing 1th click.\n\\> Finished processing 2th click.\n\nNote\n\nNote that the global ThreadPool is used to dispatch events triggered by changes in parameters, events (such as click events), [`defer_load`](https://panel.holoviz.org/how_to/callbacks/defer_load.html) callbacks and optionally [`onload` callbacks](https://panel.holoviz.org/how_to/callbacks/load.html)."
},
{
  "markdown": "## How-to[#](#how-to \"Permalink to this heading\")\n\nThe Panel How-to guides provide step by step recipes for solving essential problems and tasks that arise during your work. They assume that you’ve completed the Getting Started material and therefore already have some knowledge of how Panel works. There is no order to the guides, other than any potential prerequisites listed at the top of a page. Jump to the topic that is relevant to you now.\n\n## Prepare to develop[#](#prepare-to-develop \"Permalink to this heading\")\n\nDevelop in a notebook\n\nHow to effectively develop apps in a notebook environment.\n\nDevelop in an editor\n\nHow to effectively develop apps in a Python or Markdown file.\n\n## Build apps[#](#build-apps \"Permalink to this heading\")\n\nConstruct components\n\nHow to construct and customize individual components like an image or slider widget.\n\nArrange Components\n\nHow to arrange and size components on the page.\n\nStyle components\n\nHow to apply designs, themes and custom styling to components to achieve a polished look and feel.\n\nAdd interactivity\n\nHow to link add interactivity to your applications using reactive APIs.\n\nApply templates\n\nHow to use a Template to customize the look and feel of a deployed Panel app.\n\n## Use specialized UIs and APIs[#](#use-specialized-uis-and-apis \"Permalink to this heading\")\n\nBuild a sequential UI\n\nHow to build a Panel Pipeline that connects multiple panels into a sequential user interface.\n\nBuild custom components\n\nHow to extend Panel by building custom components.\n\nGenerate UIs from declared parameters (`Declarative API`)\n\nHow to use Parameterized classes with Panel to generate UIs without writing GUI code.\n\nExplicitly link parameters (`Callbacks API`)\n\nHow to link the parameters of Panel components in Python and Javascript.\n\n## Manage session tasks[#](#manage-session-tasks \"Permalink to this heading\")\n\nRegister session callbacks\n\nHow to set up callbacks on session related events (e.g. on page load or when a session is destroyed) and define periodic tasks.\n\nAccess session state\n\nHow to access and manipulate state related to the user session, HTTP request and URL arguments.\n\n## Test and debug[#](#test-and-debug \"Permalink to this heading\")\n\nEnable profiling and debugging\n\nHow to profile and debug your application using the admin dashboard and other tools.\n\nSet up testing for an application\n\nHow to set up unit tests, UI tests and load testing to ensure your applications are (and stay) robust and scalable.\n\n## Share your work[#](#share-your-work \"Permalink to this heading\")\n\nConfigure the server\n\nHow to configure the Panel server.\n\nIntegrate with other servers\n\nHow to integrate Panel in other application based on Flask, FastAPI or Django.\n\nDeploy applications\n\nHow to deploy Panel applications to various cloud providers (e.g. Azure, GCP, AWS etc.)\n\nExport apps\n\nHow to export and save Panel applications as static files.\n\nRun panel in WebAssembly\n\nHow to run Panel applications entirely in the browser using WebAssembly (Wasm), Pyodide, and PyScript.\n\n## Migrate to Panel[#](#migrate-to-panel \"Permalink to this heading\")\n\nMigrate from Streamlit\n\n[![https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)\n\nHow to migrate existing Streamlit applications to Panel."
},
{
  "markdown": "## Build a `Pipeline`[#](#build-a-pipeline \"Permalink to this heading\")\n\nA Panel Pipeline allows you to connect multiple panels into a sequential user interface where the output of one stage feeds into the next. These How-to pages provide solutions for common tasks related to creating and customizing pipelines.\n\nCreate a `Pipeline`\n\nHow to create a simple linear Panel Pipeline.\n\nCreate a Non-Linear `Pipeline`\n\nThis guide addresses how to build a non-linear Panel Pipeline with branching and converging steps.\n\nCustomize `Pipeline` Layout\n\nHow to customize the visual layout of the Panel Pipeline UI.\n\nControl `Pipeline` Flow\n\nHow to programmatically control the Pipeline UI flow."
},
{
  "markdown": "## Use Asynchronous Processing[#](#use-asynchronous-processing \"Permalink to this heading\")\n\nWhen using Python you can use async callbacks wherever you would ordinarily use a regular synchronous function. For instance you can use `pn.bind` on an async function:\n\nimport panel as pn\n\nwidget \\= pn.widgets.IntSlider(start\\=0, end\\=10)\n\nasync def get\\_img(index):\n    url \\= f\"https://picsum.photos/800/300?image={index}\"\n    if pn.state.\\_is\\_pyodide:\n        from pyodide.http import pyfetch\n        return pn.pane.JPG(await (await pyfetch(url)).bytes())\n\n    import aiohttp\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as resp:\n            return pn.pane.JPG(await resp.read())\n\npn.Column(widget, pn.bind(get\\_img, widget))\n\nIn this example Panel will invoke the function and update the output when the function returns while leaving the process unblocked for the duration of the `aiohttp` request.\n\nSimilarly you can attach asynchronous callbacks using `.param.watch`:\n\nwidget \\= pn.widgets.IntSlider(start\\=0, end\\=10)\n\nimage \\= pn.pane.JPG()\n\nasync def update\\_img(event):\n    url \\= f\"https://picsum.photos/800/300?image={event.new}\"\n    if pn.state.\\_is\\_pyodide:\n        from pyodide.http import pyfetch\n        image.object \\= await (await pyfetch(url)).bytes()\n        return\n\n    import aiohttp\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as resp:\n            image.object \\= await resp.read()\n\nwidget.param.watch(update\\_img, 'value')\nwidget.param.trigger('value')\n\npn.Column(widget, image)\n\nIn this example Param will await the asynchronous function and the image will be updated when the request completes."
},
{
  "markdown": "## Create a `Pipeline`[#](#create-a-pipeline \"Permalink to this heading\")\n\nThis guide addresses how to connect multiple panels into a `Pipeline` to express complex multi-page workflows where the output of one stage feeds into the next stage.\n\nPrerequisites\n\n1.  The [Param with Panel How-to Guides](https://panel.holoviz.org/how_to/param/index.html) describe how to set up classes that declare parameters and link them to some computation or visualization.\n    \n\n* * *\n\nTo start, lets instantiate an empty `Pipeline`. We will use the ‘katex’ extension to render mathematical notation in this example.\n\nimport param\nimport panel as pn\npn.extension('katex')\n\npipeline \\= pn.pipeline.Pipeline()\n\nNow let’s populate the pipeline with our first stage which takes two inputs (`a` and `b`) and produces two outputs (`c`, computed by multiplying the inputs, and `d`, computed by raising `a` to the power `b`).\n\nTo create this stage, let’s:\n\n1.  Declare a Parameterized class with some input parameters (e.g. `a = param.Integer`)\n    \n2.  Decorate a method with `@param.output` to declare outputs (we’ll discuss this more later)\n    \n3.  Declare a `panel` method that returns a view of this stage’s object\n    \n\nclass Stage1(param.Parameterized):\n\n    a \\= param.Integer(default\\=2, bounds\\=(0, 10))\n    b \\= param.Integer(default\\=3, bounds\\=(0, 10))\n\n    @param.output(('c', param.Integer), ('d', param.Integer))\n    def output(self):\n        return self.a \\* self.b, self.a \\*\\* self.b\n\n    @param.depends('a', 'b')\n    def view(self):\n        c, d \\= self.output()\n        c\\_out \\= pn.pane.LaTeX('${a} \\* {b} = {c}$'.format(\n            a\\=self.a, b\\=self.b, c\\=c), styles\\={'font-size': '2em'})\n        d\\_out \\= pn.pane.LaTeX('${a}^{{{b}}} = {d}$'.format(\n            a\\=self.a, b\\=self.b, d\\=d), styles\\={'font-size': '2em'})\n        return pn.Column(\n\t\t    c\\_out, d\\_out,  margin\\=(40, 10), styles\\={'background': '#f0f0f0'}\n\t\t)\n\n    def panel(self):\n        return pn.Row(self.param, self.view,)\n\nWe can now render this stage on its own:\n\nstage1 \\= Stage1()\nstage1.panel()\n\nBefore we create a second stage let’s briefly discuss the some details about the system of outputs that links the stages. To declare the output for our first stage, we decorated one of its methods with `@param.output(('c', param.Integer), ('d', param.Integer))`. However, there are multiple ways to declare outputs with this decorator:\n\n*   `param.output()`: Declaring an output without arguments will declare that the method returns an output that will inherit the **name of the method** and does not make any specific type declarations.\n    \n*   `param.output(param.Integer)`: Declaring an output with a specific `Parameter` or Python type also declares an output with the name of the method but declares that the output will be of a specific type.\n    \n*   `param.output(c=param.Integer)`: Declaring an output using a keyword argument allows overriding the method name as the name of the output and declares the type.\n    \n\nIt is also possible to declare multiple outputs, either as keywords or tuples:\n\n*   `param.output(c=param.Integer, d=param.String)` or\n    \n*   `param.output(('c', param.Integer), ('d', param.String))`\n    \n\nImportantly, in addition to passing along the outputs designated with `param.output()`, the Pipeline will also pass along the values of any input parameters whose names match input parameters on the next stage (unless `inherit_params` is set to `False`).\n\nOk, enough explanation, let’s take a look at the outputs of our first stage:\n\n{'c': (<param.parameters.Integer object at 0x116af6100>, <bound method Stage1.output of Stage1(a=2, b=3, name='Stage101022')>, 0), 'd': (<param.parameters.Integer object at 0x116af61c0>, <bound method Stage1.output of Stage1(a=2, b=3, name='Stage101022')>, 1)}\n\nOur `Pipeline` will use this information to determine what outputs are available to be fed into the next stage of the workflow.\n\nNow let’s set up a second stage that will also declare a `c` input Parameter to consume the `c` output of the first stage. Note, the second stage does not have to consume all parameters, and here we will ignore the first stage’s output `d`. Otherwise, the second stage below is very similar to the first one; it declares both a `view` method that depends on the parameters of the class, and a `panel` method that returns a view of the object. As this is our last stage, we don’t need to define any further outputs.\n\nclass Stage2(param.Parameterized):\n\n    c \\= param.Integer(default\\=6, bounds\\=(0, None))\n    exp \\= param.Number(default\\=0.1, bounds\\=(0, 3))\n\n    @param.depends('c', 'exp')\n    def view(self):\n        out \\= pn.pane.LaTeX('${%s}^{%s}={%.3f}$' % (self.c, self.exp, self.c\\*\\*self.exp),\n                      styles\\={'font-size': '2em'})\n        return pn.Column(out, margin\\=(40, 10), styles\\={'background': '#f0f0f0'})\n\n    def panel(self):\n        return pn.Row(self.param, self.view)\n\nNow let’s add our stages to our `Pipeline` using the `add_stage` method\n\npipeline.add\\_stage('Stage 1', Stage1)\npipeline.add\\_stage('Stage 2', Stage2)\n\nFinally, to display the `pipeline` UI we simply let it render itself:\n\nAs you can see the `Pipeline` renders a diagram displaying the available stages in the workflow along with previous and next buttons to move between each stage. Note also when progressing to Stage 2, the `c` parameter widget is not rendered because its value has been provided by the previous stage.\n\nHere is the complete code for this section in case you want to easily copy it:\n\nimport param\nimport panel as pn\npn.extension('katex')\n\npipeline \\= pn.pipeline.Pipeline()\n\nclass Stage1(param.Parameterized):\n\n    a \\= param.Integer(default\\=2, bounds\\=(0, 10))\n    b \\= param.Integer(default\\=3, bounds\\=(0, 10))\n\n    @param.output(('c', param.Integer), ('d', param.Integer))\n    def output(self):\n        return self.a \\* self.b, self.a \\*\\* self.b\n\n    @param.depends('a', 'b')\n    def view(self):\n        c, d \\= self.output()\n        c\\_out \\= pn.pane.LaTeX('${a} \\* {b} = {c}$'.format(\n            a\\=self.a, b\\=self.b, c\\=c), styles\\={'font-size': '2em'})\n        d\\_out \\= pn.pane.LaTeX('${a}^{{{b}}} = {d}$'.format(\n            a\\=self.a, b\\=self.b, d\\=d), styles\\={'font-size': '2em'})\n        return pn.Column(c\\_out, d\\_out,  margin\\=(40, 10), styles\\={'background': '#f0f0f0'})\n\n    def panel(self):\n        return pn.Row(self.param, self.view,)\n\nclass Stage2(param.Parameterized):\n\n    c \\= param.Integer(default\\=6, bounds\\=(0, None))\n    exp \\= param.Number(default\\=0.1, bounds\\=(0, 3))\n\n    @param.depends('c', 'exp')\n    def view(self):\n        out \\= pn.pane.LaTeX('${%s}^{%s}={%.3f}$' % (self.c, self.exp, self.c\\*\\*self.exp),\n                      styles\\={'font-size': '2em'})\n        return pn.Column(out, margin\\=(40, 10), styles\\={'background': '#f0f0f0'})\n\n    def panel(self):\n        return pn.Row(self.param, self.view)\n\npipeline.add\\_stage('Stage 1', Stage1)\npipeline.add\\_stage('Stage 2', Stage2)\n\npipeline"
},
{
  "markdown": "## Configuring Authentication[#](#configuring-authentication \"Permalink to this heading\")\n\nAuthentication is a difficult topic fraught with potential pitfalls and complicated configuration options. Panel aims to be a “batteries-included” package for building applications and dashboards and therefore ships with a number of inbuilt providers for authentication in an application.\n\nThe primary mechanism by which Panel performs authentication is [OAuth 2.0](https://oauth.net/2/). The official specification for OAuth 2.0 describes the protocol as follows:\n\nThe OAuth 2.0 authorization framework enables a third-party\napplication to obtain limited access to an HTTP service, either on\nbehalf of a resource owner by orchestrating an approval interaction\nbetween the resource owner and the HTTP service, or by allowing the\nthird-party application to obtain access on its own behalf.\n\nIn other words OAuth outsources authentication to a third party provider, e.g. GitHub, Google or Azure AD, to authenticate the user credentials and give limited access to the APIs of that service.\n\nConfiguring Basic Authentication\n\nDiscover how to add basic password based authentication to your application.\n\nConfiguring OAuth\n\nDiscover how to configure OAuth from the commandline.\n\nOAuth Providers\n\nA list of OAuth providers and how to configure them.\n\nTemplates\n\nDiscover how to configure error and logout templates to match the design of your application.\n\nUser Information\n\nDiscover how to make use of the user information and access tokens returned by the OAuth provider.\n\nAccess Tokens\n\nDiscover how to use OAuth access tokens and ensure they are automatically refreshed when they expire.\n\nAuthorization callbacks\n\nDiscover how to configure a callback to implement custom authorization logic.\n\nOptional Authentication\n\nDiscover how to configure Auth to allow guest users to access specific endpoints or the entire application.\n\nNote that since Panel is built on Bokeh server and Tornado it is also possible to implement your own authentication independent of the OAuth components shipped with Panel, [see the Bokeh documentation](https://docs.bokeh.org/en/latest/docs/user_guide/server.html#authentication) for further information."
},
{
  "markdown": "## Configuring Basic Authentication[#](#configuring-basic-authentication \"Permalink to this heading\")\n\nFor simple uses cases it may be totally sufficient to enable a basic Auth provider, which simply compares the provided login credentials against a master password or credentials stored in a file.\n\n## Setting up basic authentication[#](#setting-up-basic-authentication \"Permalink to this heading\")\n\nBasic authentication can be set up simply by providing the `--basic-auth` commandline argument (or the `PANEL_BASIC_AUTH` environment variable). Here is how to do it:\n\nCreate a basic `app.py` file.\n\nimport panel as pn\n\npn.extension(template\\=\"fast\")\n\nlogout \\= pn.widgets.Button(name\\=\"Log out\")\nlogout.js\\_on\\_click(code\\=\"\"\"window.location.href = './logout'\"\"\")\npn.Column(f\"Congrats \\`{pn.state.user}\\`. You got access!\", logout).servable()\n\nNow serve the application\n\npanel serve app.py \\--basic-auth my\\_password \\--cookie-secret my\\_super\\_safe\\_cookie\\_secret\n\nWhen loading the application you should now see a very simple login form:\n\n![Basic Auth Login Form](https://panel.holoviz.org/_images/basic_auth.png)\n\nIf you enter an invalid password it will look like\n\n![Invalid Basic Auth Login Form](https://panel.holoviz.org/_images/basic_auth_invalid.png)\n\nIf you enter the valid password (i.e. `my_password`) it will look like\n\n![Valid Basic Auth Login Form](https://panel.holoviz.org/_images/basic_auth_valid.png)\n\nIf you click the _Log out_ button you will be sent back to the log in form.\n\nIn this mode the `username` is not authenticated. The `username` is provided as part of the [user info](https://panel.holoviz.org/how_to/authentication/user_info.html).\n\n## User credentials[#](#user-credentials \"Permalink to this heading\")\n\nIf you want a slightly more complex setup with a number of different users with potentially different access controls you can also provide a path to a file containing user credentials, e.g. let’s say we have a file called `credentials.json` containing:\n\n{\n    \"user1\": \"my\\_password\",\n    \"admin\": \"my\\_super\\_safe\\_password\"\n}\n\nWe can now configure the basic authentication with:\n\npanel serve app.py \\--basic-auth credentials.json \\--cookie-secret my\\_super\\_safe\\_cookie\\_secret\n\nThe basic auth provider will now check the provided credentials against the credentials declared in this file.\n\nWhen serving an application dynamically using \\`pn.serve\\` you can also provide a dictionary of usernames and passwords via the \\`basic\\_auth\\` keyword argument.\n\n## Custom templates[#](#custom-templates \"Permalink to this heading\")\n\nIf you want to customize the authentication template you can provide a custom template with the `--basic-login-template` CLI argument. The template needs to submit `username` and `password` to the `/login` endpoint of the Panel server, e.g. the form of the default template looks like this. Check out the default template [here](https://github.com/holoviz/panel/blob/main/panel/_templates/basic_login.html) for inspiration."
},
{
  "markdown": "## Customize `Pipeline` Layout[#](#customize-pipeline-layout \"Permalink to this heading\")\n\nThis guide addresses how to customize the visual layout of the Panel `Pipeline` UI.\n\n* * *\n\nA `Pipeline` object has the following components that you can customize to display in any configuration.\n\n*   `layout`: The overall layout of the header and stage.\n    \n*   `header`: The navigation components and network diagram.\n    \n*   `title`: The name of the current stage.\n    \n*   `network`: A network diagram representing the pipeline.\n    \n*   `stage`: The contents of the current pipeline stage.\n    \n*   `buttons`: All navigation buttons and selectors.\n    \n*   `prev_button`: The button to go to the previous stage.\n    \n*   `prev_selector`: The selector widget to select between previous branching stages.\n    \n*   `next_button`: The button to go to the previous stage\n    \n*   `next_selector`: The selector widget to select the next branching stages.\n    \n\nFor instance, let’s rearrange the layout of a simple non-linear pipeline. For a walk-through of this type of pipeline, refer to the [Create a Non-Linear Pipeline](https://panel.holoviz.org/how_to/pipeline/complex_pipeline.html) How-to Guide.\n\nFirst, let’s create the stages and add them to a pipeline:\n\nimport param\nimport panel as pn\npn.extension() \\# for notebook\n\nclass Input(param.Parameterized):\n\n    value1 \\= param.Integer(default\\=2, bounds\\=(0,10))\n    value2 \\= param.Integer(default\\=3, bounds\\=(0,10))\n\n    def panel(self):\n        return pn.Column(self.param.value1, self.param.value2)\n\nclass Multiply(Input):\n\n    value1 \\= param.Integer()\n    value2 \\= param.Integer()\n    operator \\= param.String(default\\='\\*')\n\n    def panel(self):\n        return pn.pane.Markdown(f'# {self.value1} \\* {self.value2}')\n\n    @param.output('result')\n    def output(self):\n        return self.value1 \\* self.value2\n\nclass Add(Input):\n\n    value1 \\= param.Integer()\n    value2 \\= param.Integer()\n    operator \\= param.String(default\\='+')\n\n    def panel(self):\n        return pn.pane.Markdown(f'# {self.value1} + {self.value2}')\n\n    @param.output('result')\n    def output(self):\n        return self.value1 + self.value2\n\nclass Result(Input):\n\n    value1 \\= param.Integer()\n    value2 \\= param.Integer()\n    operator \\= param.String(default\\='')\n    result \\= param.Integer(default\\=0)\n\n    def panel(self):\n        return pn.pane.Markdown(f'# {self.value1} {self.operator} {self.value2} = {self.result}')\n\ndag \\= pn.pipeline.Pipeline()\n\ndag.add\\_stage('Input', Input)\ndag.add\\_stage('Multiply', Multiply)\ndag.add\\_stage('Add', Add)\ndag.add\\_stage('Result', Result)\n\ndag.define\\_graph({'Input': ('Multiply', 'Add'), 'Multiply': 'Result', 'Add': 'Result'})\n\nNow we can use any of the layout components to arrange the UI:\n\npn.Column(\n    dag.title,\n    pn.Row(dag.buttons, pn.layout.HSpacer(), dag.stage),\n    dag.network\n)"
},
{
  "markdown": "## Configuring OAuth[#](#configuring-oauth \"Permalink to this heading\")\n\nThe OAuth component will stop any user from accessing the application before first logging into the selected provider. The configuration to set up OAuth is all handled via the global `pn.config` object, which has a number of OAuth related parameters. When launching the application via the `panel serve` CLI command these config options can be set as CLI arguments or environment variables, when using the `pn.serve` function on the other hand these variables can be passed in as arguments.\n\n## `oauth_provider`[#](#oauth-provider \"Permalink to this heading\")\n\nThe first step in configuring a OAuth is to specify a specific OAuth provider. Panel ships with a number of providers by default:\n\n*   `azure`: Azure Active Directory\n    \n*   `bitbucket`: Bitbucket\n    \n*   `github`: GitHub\n    \n*   `gitlab`: GitLab\n    \n*   `google`: Google\n    \n*   `okta`: Okta\n    \n*   `generic`: Generic OAuth Provider with configurable endpoints\n    \n*   `password`: Generic password grant based OAuth Provider with configurable endpoints\n    \n*   `auth_code`: Generic code challenge grant based OAuth Provider with configurable endpoints\n    \n\nWe will go through the process of configuring each of these individually in [Providers](https://panel.holoviz.org/how_to/authentication/providers.html) but for now all we need to know that the `oauth_provider` can be set on the commandline using the `--oauth-provider` CLI argument to `panel serve` or the `PANEL_OAUTH_PROVIDER` environment variable.\n\nExamples:\n\npanel serve oauth\\_example.py \\--oauth\\-provider\\=...\n\nPANEL\\_OAUTH\\_PROVIDER\\=... panel serve oauth\\_example.py\n\nor in Python:\n\npn.serve(app, oauth\\_provider\\=...)\n\n## Endpoints[#](#endpoints \"Permalink to this heading\")\n\nThe login and logout endpoints are configurable:\n\npanel serve oauth\\_example.py \\--login\\-endpoint\\=\"/signin\" \\--logout\\-endpoint\\=\"/signoff\"\n\nor in Python:\n\npn.serve(app, login\\_endpoint\\=\"/signin\", logout\\_endpoint\\=\"/signoff\", ...)\n\nor in Python:\n\n## `oauth_key` and `oauth_secret`[#](#oauth-key-and-oauth-secret \"Permalink to this heading\")\n\nTo authenticate with a OAuth provider we generally require two pieces of information (although some providers will require more customization):\n\n1.  The Client ID is a public identifier for apps.\n    \n2.  The Client Secret is a secret known only to the application and the authorization server.\n    \n\nThese can be configured in a number of ways the client ID and client secret can be supplied to the `panel serve` command as `--oauth-key` and `--oauth-secret` CLI arguments or `PANEL_OAUTH_KEY` and `PANEL_OAUTH_SECRET` environment variables respectively.\n\nExamples:\n\npanel serve oauth\\_example.py \\--oauth\\-key\\=... \\--oauth\\-secret\\=...\n\nPANEL\\_OAUTH\\_KEY\\=... PANEL\\_OAUTH\\_KEY\\=... panel serve oauth\\_example.py ...\n\nor in Python:\n\npn.serve(app, oauth\\_key\\=..., oauth\\_secret\\=..., ...)\n\nThe only exception to authenticating with a `oauth_secret` are the generic password and code challenge based OAuth providers. If you picked one of these then you must only provide the client ID using the `--oauth-key` CLI argument or `PANEL_OAUTH_KEY` environment variable.\n\n## `cookie_secret`[#](#cookie-secret \"Permalink to this heading\")\n\nOnce authenticated the user information and authorization token will be set as secure cookies. Cookies are not secure and can easily be modified by clients. A secure cookie ensures that the user information cannot be interfered with or forged by the client by signing it with a secret key. Note that secure cookies guarantee integrity but not confidentiality. That is, the cookie cannot be modified but its contents can be seen by the user. To generate a `cookie_secret` use the `panel secret` CLI argument or generate some other random non-guessable string, ideally with at least 256-bits of entropy.\n\nTo set the `cookie_secret` supply `--cookie-secret` as a CLI argument or set the `PANEL_COOKIE_SECRET` environment variable.\n\nExamples:\n\npanel serve oauth\\_example.py \\--cookie\\-secret\\=...\n\nPANEL\\_COOKIE\\_SECRET\\=... panel serve oauth\\_example.py ...\n\nor in Python:\n\npn.serve(app, cookie\\_secret\\=\"my-super-secret-secret\", ...)\n\n## `oauth_expiry`[#](#oauth-expiry \"Permalink to this heading\")\n\nThe OAuth expiry configuration value determines for how long an OAuth token will be valid once it has been issued. By default it is valid for 1 day, but may be overwritten by providing the duration in the number of days (decimal values are allowed).\n\nTo set the `oauth_expiry` supply `--oauth-expiry-days` as a CLI argument or set the `PANEL_OAUTH_EXPIRY` environment variable.\n\nExamples:\n\npanel serve oauth\\_example.py \\--oauth\\-expiry\\-days\\=...\n\nPANEL\\_OAUTH\\_EXPIRY\\=... panel serve oauth\\_example.py ...\n\n## Encryption[#](#encryption \"Permalink to this heading\")\n\nThe architecture of the Bokeh/Panel server means that credentials stored as cookies can be leak in a number of ways. On the initial HTTP(S) request the server will respond with the HTML document that renders the application and this will include an unencrypted token containing the OAuth information. To ensure that the user information and access token are properly encrypted we rely on the Fernet encryption in the `cryptography` library. You can install it with `pip install cryptography` or `conda install cryptography`.\n\nOnce installed you will be able to generate a encryption key with `panel oauth-secret`. This will generate a secret you can pass to the `panel serve` CLI command using the `--oauth-encryption-key` argument or `PANEL_OAUTH_ENCRYPTION` environment variable.\n\nExamples:\n\npanel serve oauth\\_example.py \\--oauth\\-encryption\\-key\\=...\n\nPANEL\\_OAUTH\\_ENCRYPTION\\=... panel serve oauth\\_example.py ...\n\nor in Python:\n\npn.serve(app, oauth\\_encryption\\_key\\=...)\n\n## Redirect URI[#](#redirect-uri \"Permalink to this heading\")\n\nOnce the OAuth provider has authenticated a user it has to redirect them back to the application, this is what is known as the redirect URI. For security reasons this has to match the URL registered with the OAuth provider exactly. By default Panel will redirect the user straight back to the original URL of your app, e.g. when you’re hosting your app at `https://myapp.myprovider.com` Panel will use that as the redirect URI. However in certain scenarios you may override this to provide a specific redirect URI. This can be achieved with the `--oauth-redirect-uri` CLI argument or the `PANEL_OAUTH_REDIRECT_URI` environment variable.\n\nExamples:\n\npanel serve oauth\\_example.py \\--oauth\\-redirect\\-uri\\=...\n\nPANEL\\_OAUTH\\_REDIRECT\\_URI\\=... panel serve oauth\\_example.py\n\n## Scopes[#](#scopes \"Permalink to this heading\")\n\nOAuth allows the application to request specific scopes to perform certain actions when authenticating with the provider. To set the scopes you may set the `PANEL_OAUTH_SCOPE` environment variable or provide it as an argument using the `--oauth-extra-params {'scope': ...}` CLI argument.\n\nExamples:\n\npanel serve oauth\\_example.py \\--oauth\\-extra\\-params {'scope': 'openid'}\n\nPANEL\\_OAUTH\\_SCOPE\\=openid panel serve oauth\\_example.py\n\nor in Python:\n\npn.serve(app, ..., oauth\\_extra\\_params\\={'scope': 'openid'})\n\n## Summary[#](#summary \"Permalink to this heading\")\n\nA fully configured OAuth configuration may look like this:\n\npanel serve oauth\\_example.py --oauth-provider=github --oauth-key=... --oauth-secret=... --cookie-secret=... --oauth-encryption-key=...\n\nPANEL\\_OAUTH\\_PROVIDER=... PANEL\\_OAUTH\\_KEY=... PANEL\\_OAUTH\\_SECRET=... PANEL\\_COOKIE\\_SECRET=... PANEL\\_OAUTH\\_ENCRYPTION=... panel serve oauth\\_example.py ...\\`\n\nor in Python:\n\npn.serve(app, oauth\\_provider\\='github', oauth\\_key\\=..., oauth\\_secret\\=..., cookie\\_secret\\=..., oauth\\_encryption\\_key\\=...)\n\nFor a generic, password, or code provider you may also have to provide the `TOKEN_URL`, `AUTHORIZE_URL` and `USER_URL` via the `--oauth-extra-params` CLI argument, `OAUTH_EXTRA_PARAMS` environment variable or in Python using the `oauth_extra_params` keyword argument."
},
{
  "markdown": "## OAuth Providers[#](#oauth-providers \"Permalink to this heading\")\n\nPanel supports a number of OAuth providers out-of-the-box. Follow the guide for setting up an OAuth application specific to your provider and then refer to the [Configuring OAuth guide](https://panel.holoviz.org/how_to/authentication/configuration.html) to add OAuth to your application.\n\n## **Azure Active Directory**[#](#azure-active-directory \"Permalink to this heading\")\n\nTo set up OAuth2.0 authentication for Azure Active directory follow [these instructions](https://docs.microsoft.com/en-us/azure/api-management/api-management-howto-protect-backend-with-aad). In addition to the `oauth_key` and `oauth_secret` ensure that you also supply the tenant ID using `oauth_extra_params`, e.g.:\n\npanel serve oauth\\_test.py \\--oauth\\-extra\\-params\\=\"{'tenant': '...'}\"\n\nPANEL\\_OAUTH\\_EXTRA\\_PARAMS\\=\"{'tenant': '...'}\" panel serve oauth\\_example.py ...\n\n## **Bitbucket**[#](#bitbucket \"Permalink to this heading\")\n\nBitbucket provides instructions about setting [setting up an OAuth consumer](https://support.atlassian.com/bitbucket-cloud/docs/use-oauth-on-bitbucket-cloud/). Follow these and then supply the `oauth_key` and `oauth_secret` to Panel as described above.\n\n## **GitHub**[#](#github \"Permalink to this heading\")\n\nGitHub provides detailed instructions on [creating an OAuth app](https://developer.github.com/apps/building-oauth-apps/creating-an-oauth-app/). Follow these and then supply the `oauth_key` and `oauth_secret` to Panel as described above.\n\n## **GitLab**[#](#gitlab \"Permalink to this heading\")\n\nGitLab provides a detailed guide on [configuring an OAuth](https://docs.gitlab.com/ee/api/oauth2.html) application. In addition to the `oauth_key` and `oauth_secret` you will also have to supply a custom url using the `oauth_extra_params` if you have a custom GitLab instance (the default `oauth_extra_params={'url': 'gitlab.com'}`).\n\n## **Google**[#](#google \"Permalink to this heading\")\n\nGoogle provides a guide about [configuring a OAuth application](https://developers.google.com/identity/protocols/oauth2/native-app). By default nothing except the `oauth_key` and `oauth_secret` are required but to access Google services you may also want to override the default `scope` via the `oauth_extra_params`.\n\n## **Okta**[#](#okta \"Permalink to this heading\")\n\nOkta provides a guide about [configuring OAuth2](https://developer.okta.com/docs/concepts/oauth-openid/). You must provide an `oauth_key` and `oauth_secret` but in most other ordinary setups you will also have to provide a `url` via the `oauth_extra_params` and if you have set up a custom authentication server (i.e. not ‘default’) with Okta you must also provide ‘server’, the `oauth_extra_params` should then look something like this: `{'server': 'custom', 'url': 'dev-***.okta.com'}`\n\n## **Auth0**[#](#auth0 \"Permalink to this heading\")\n\nAuth0 provides detailed documentation about [configuring a OAuth application](https://auth0.com/docs/get-started/applications/application-settings). In addition to the `oauth_key` and `oauth_secret` you must also provide a `subdomain` via the `oauth_extra_params`, i.e. you must provide something like: `{'subdomain': 'dev-....us'}` and we also recommend you obtain the `audience` for your Auth0 API and provide that along with the subdomain.\n\n## **Generic**/**Password**/**Code**[#](#generic-password-code \"Permalink to this heading\")\n\nThe `'generic'`, `'password'` and `'code'` OAuth providers allows you to provide custom authentication endpoints using the `--oauth-extra-param` or using environment variables. Specifically you must provide:\n\n*   `AUTHORIZE_URL`: The authorization endpoint of the authentication server, may also be provided using the `PANEL_OAUTH_AUTHORIZE_URL` environment variable.\n    \n*   `TOKEN_URL`: The token endpoint of the authentication server, may also be provided using the `PANEL_OAUTH_TOKEN_URL` environment variable.\n    \n*   `USER_URL`: The user information endpoint of the authentication server, may also be provided using the `PANEL_OAUTH_USER_URL` environment variable.\n    \n\nThe difference between these three providers is the authentication flow they perform. The `generic` provider uses the standard authentication flow, which requests authorization using the client secret, while the `password` based workflow lets the user log in via a form served on the server (only recommended for testing and development), and the `code` uses a code challenge based auth flow.\n\n## Plugins[#](#plugins \"Permalink to this heading\")\n\nThe Panel OAuth providers are pluggable, in other words downstream libraries may define their own Tornado `RequestHandler` to be used with Panel. To register such a component the `setup.py` of the downstream package should register an entry\\_point that Panel can discover. To read more about entry points see the [Python documentation](https://packaging.python.org/specifications/entry-points/). A custom OAuth request handler in your library may be registered as follows:\n\nentry\\_points\\={\n    'panel.auth': \\[\n        \"custom = my\\_library.auth:MyCustomOAuthRequestHandler\"\n    \\]\n}"
},
{
  "markdown": "## Control `Pipeline` Flow[#](#control-pipeline-flow \"Permalink to this heading\")\n\nThis guide addresses how to programmatically control the `Pipeline` UI flow.\n\nPrerequisites\n\n1.  The [Create a Non-Linear Pipeline](https://panel.holoviz.org/how_to/pipeline/complex_pipeline.html) How-to Guide walks through the creation of branching pipeline that commonly used in the context of controlling pipeline flow.\n    \n\n* * *\n\nBy default, controlling the flow between different stages is done using the “Previous” and “Next” buttons. However, we often want to control the UI flow programmatically from within a stage. We can do this with the following parameters:\n\n*   The `ready_parameter` can block (`False`) or unblock (`True`) potential advancement to the next stage.\n    \n*   The `auto_advance` parameter will automatically advance to the next stage if unblocked by the `ready_parameter`.\n    \n*   The `next_parameter` argument can be used to dynamically set which stage will be next.\n    \n\nIn this way we can control the workflow programmatically from inside the stages.\n\nIn the example below we create a branching and converging workflow that can be used without the buttons by declaring `ready_parameter` and `auto_advance` for each of the stages, which we can toggle with a custom button or simply set to `True` by default to automatically proceed to the next stage.\n\nWe will also control which branching stage to switch to from within a stage by declaring a parameter which will hold the name of the next stage to switch to. In this case, we create a parameter to select between `Add` and `Multiply` stages. Later, we will point the pipeline to this parameter using the `next_parameter` argument.\n\nFirst, let’s create our stages:\n\nimport param\nimport panel as pn\npn.extension() \\# for notebook\n\nclass Input(param.Parameterized):\n\n    value1 \\= param.Integer(default\\=2, bounds\\=(0,10))\n    value2 \\= param.Integer(default\\=3, bounds\\=(0,10))\n    operator \\= param.Selector(default\\='Multiply', objects\\=\\['Multiply', 'Add'\\])\n    ready \\= param.Boolean(default\\=False)\n\n    def panel(self):\n        button \\= pn.widgets.Button(name\\='Go', button\\_type\\='success')\n        button.on\\_click(lambda event: setattr(self, 'ready', True)) \\# allows auto-advance to proceed\n        widgets \\= pn.Row(self.param.value1, self.param.operator, self.param.value2)\n        for w in widgets:\n            w.width \\= 85\n        return pn.Column(widgets, button)\n\nclass Multiply(param.Parameterized):\n\n    value1 \\= param.Integer()\n    value2 \\= param.Integer()\n    ready \\= param.Boolean(default\\=True)\n\n    def panel(self):\n        return pn.pane.Markdown(f'# {self.value1} \\* {self.value2}')\n\n    @param.output('equation')\n    def output(self):\n        return f'# {self.value1} \\* {self.value2} = {self.value1 \\* self.value2}'\n\nclass Add(param.Parameterized):\n\n    value1 \\= param.Integer()\n    value2 \\= param.Integer()\n    ready \\= param.Boolean(default\\=True)\n\n    def panel(self):\n        return pn.pane.Markdown(f'# {self.value1} + {self.value2} =')\n\n    @param.output('equation')\n    def output(self):\n        return f'# {self.value1} + {self.value2} = {self.value1 + self.value2}'\n\nclass Result(param.Parameterized):\n\n    equation \\= param.String()\n\n    def panel(self):\n        return pn.pane.Markdown(self.equation)\n\nNow let’s add the stages to a pipeline and define the graph:\n\ndag \\= pn.pipeline.Pipeline()\n\ndag.add\\_stage('Input', Input, ready\\_parameter\\='ready', auto\\_advance\\=True, next\\_parameter\\='operator')\ndag.add\\_stage('Multiply', Multiply, ready\\_parameter\\='ready', auto\\_advance\\=True)\ndag.add\\_stage('Add', Add, ready\\_parameter\\='ready', auto\\_advance\\=True)\ndag.add\\_stage('Result', Result)\n\ndag.define\\_graph({'Input': ('Multiply', 'Add'), 'Multiply': 'Result', 'Add': 'Result'})\n\nFinally we display the pipeline without the `Next` button, which is appropriate because all the flow control is now handled from within the stages:\n\npn.Column(\n    dag.title,\n    dag.network,\n    dag.stage,\n    dag.prev\\_button\n)\n\nAs you can see, a panel Pipeline can be used to set up complex workflows when needed, with each stage controlled either manually or from within the stage, without having to define complex callbacks or other GUI logic.\n\nHere is the complete code for this section in case you want to easily copy it:\n\nimport param\nimport panel as pn\npn.extension() \\# for notebook\n\nclass Input(param.Parameterized):\n\n    value1 \\= param.Integer(default\\=2, bounds\\=(0,10))\n    value2 \\= param.Integer(default\\=3, bounds\\=(0,10))\n    operator \\= param.Selector(default\\='Multiply', objects\\=\\['Multiply', 'Add'\\])\n    ready \\= param.Boolean(default\\=False)\n\n    def panel(self):\n        button \\= pn.widgets.Button(name\\='Go', button\\_type\\='success')\n        button.on\\_click(lambda event: setattr(self, 'ready', True)) \\# allows auto-advance to proceed\n        widgets \\= pn.Row(self.param.value1, self.param.operator, self.param.value2)\n        for w in widgets:\n            w.width \\= 85\n        return pn.Column(widgets, button)\n\nclass Multiply(param.Parameterized):\n\n    value1 \\= param.Integer()\n    value2 \\= param.Integer()\n    ready \\= param.Boolean(default\\=True)\n\n    def panel(self):\n        return pn.pane.Markdown(f'# {self.value1} \\* {self.value2}')\n\n    @param.output('equation')\n    def output(self):\n        return f'# {self.value1} \\* {self.value2} = {self.value1 \\* self.value2}'\n\nclass Add(param.Parameterized):\n\n    value1 \\= param.Integer()\n    value2 \\= param.Integer()\n    ready \\= param.Boolean(default\\=True)\n\n    def panel(self):\n        return pn.pane.Markdown(f'# {self.value1} + {self.value2} =')\n\n    @param.output('equation')\n    def output(self):\n        return f'# {self.value1} + {self.value2} = {self.value1 + self.value2}'\n\nclass Result(param.Parameterized):\n\n    equation \\= param.String()\n\n    def panel(self):\n        return pn.pane.Markdown(self.equation)\n\ndag \\= pn.pipeline.Pipeline()\n\ndag.add\\_stage('Input', Input, ready\\_parameter\\='ready', auto\\_advance\\=True, next\\_parameter\\='operator')\ndag.add\\_stage('Multiply', Multiply, ready\\_parameter\\='ready', auto\\_advance\\=True)\ndag.add\\_stage('Add', Add, ready\\_parameter\\='ready', auto\\_advance\\=True)\ndag.add\\_stage('Result', Result)\n\ndag.define\\_graph({'Input': ('Multiply', 'Add'), 'Multiply': 'Result', 'Add': 'Result'})\n\npn.Column(\n    dag.title,\n    dag.network,\n    dag.stage,\n    dag.prev\\_button\n)"
},
{
  "markdown": "## Accessing User information[#](#accessing-user-information \"Permalink to this heading\")\n\n## User State[#](#user-state \"Permalink to this heading\")\n\nOnce a user is authorized with the chosen OAuth provider certain user information and an `access_token` will be available to be used in the application to customize the user experience. Like all other global state this may be accessed on the `pn.state` object, specifically it makes three attributes available:\n\n*   **`pn.state.user`**: A unique name, email or ID that identifies the user.\n    \n*   **`pn.state.access_token`**: The access token issued by the OAuth provider to authorize requests to its APIs.\n    \n*   **`pn.state.refresh_token`**: The refresh token issued by the OAuth provider to authorize requests to its APIs (if available these are usually longer lived than the `access_token`).\n    \n*   **`pn.state.user_info`**: Additional user information provided by the OAuth provider. This may include names, email, APIs to request further user information, IDs and more."
},
{
  "markdown": "## Build Custom Components[#](#build-custom-components \"Permalink to this heading\")\n\nThese How-to pages provide solutions for common tasks related to extending Panel with custom components.\n\nCombine Existing Components\n\nHow to build custom components that are combinations of existing components.\n\nBuild Components from Scratch\n\nHow to build custom components from scratch.\n\n## Examples[#](#examples \"Permalink to this heading\")\n\n![](https://assets.holoviz.org/panel/how_to/custom_components/canvas_draw.png)\n\nBuild a Canvas component\n\nBuild a custom component to draw on an HTML canvas based on `ReactiveHTML`.\n\n![](https://assets.holoviz.org/panel/how_to/custom_components/leaflet.png)\n\nWrap Leaflet.js\n\nBuild a custom component wrapping leaflet.js using `ReactiveHTML`.\n\n![](https://assets.holoviz.org/panel/how_to/custom_components/material_ui.png)\n\nWrap Material UI\n\nBuild custom components wrapping material UI using `ReactiveHTML`.\n\n![](https://assets.holoviz.org/panel/how_to/custom_components/vue.png)\n\nWrap a Vue.js component\n\nBuild custom component wrapping a Vue.js app using `ReactiveHTML`.\n\n![](https://assets.holoviz.org/panel/how_to/custom_components/plot_viewer.png)\n\nBuild a Plot Viewer\n\nBuild custom component wrapping a bokeh plot and some widgets using the `Viewer` pattern.\n\n![](https://assets.holoviz.org/panel/how_to/custom_components/table_viewer.png)\n\nBuild a Table Viewer\n\nBuild custom component wrapping a table and some widgets using the `Viewer` pattern."
},
{
  "markdown": "## Combine Existing Components[#](#combine-existing-components \"Permalink to this heading\")\n\nThis guide addresses how to build custom components that are combinations of existing components.\n\n* * *\n\nThe simplest way to extend Panel is to implement a so called `Viewer` component that can wrap multiple existing Panel components into an easily reusable unit that behaves like a native Panel component.\n\nLet’s create a composite `EditableRange` component made up of two `FloatInput` widgets. First, we will create the widgets:\n\nimport param\nimport panel as pn\nfrom panel.viewable import Viewer\npn.extension() \\# for notebook\n\nclass EditableRange(Viewer):\n\n    value \\= param.Range(doc\\=\"A numeric range.\")\n\n    width \\= param.Integer(default\\=300)\n\n    def \\_\\_init\\_\\_(self, \\*\\*params):\n        self.\\_start\\_input \\= pn.widgets.FloatInput()        self.\\_end\\_input \\= pn.widgets.FloatInput(align\\='end')        super().\\_\\_init\\_\\_(\\*\\*params)\n        self.\\_layout \\= pn.Row(self.\\_start\\_input, self.\\_end\\_input)\n\nThen, we set up callbacks to sync the parameters on the underlying widgets with the parameters on the `Viewer` component.\n\nimport param\nimport panel as pn\nfrom panel.viewable import Viewer\npn.extension() \\# for notebook\n\nclass EditableRange(Viewer):\n\n    value \\= param.Range(doc\\=\"A numeric range.\")\n\n    width \\= param.Integer(default\\=300)\n\n    def \\_\\_init\\_\\_(self, \\*\\*params):\n        self.\\_start\\_input \\= pn.widgets.FloatInput()\n        self.\\_end\\_input \\= pn.widgets.FloatInput(align\\='end')\n        super().\\_\\_init\\_\\_(\\*\\*params)\n        self.\\_layout \\= pn.Row(self.\\_start\\_input, self.\\_end\\_input)\n        self.\\_sync\\_widgets()\n    @param.depends('value', 'width', watch\\=True)    def \\_sync\\_widgets(self):        self.\\_start\\_input.name \\= self.name        self.\\_start\\_input.value \\= self.value\\[0\\]        self.\\_end\\_input.value \\= self.value\\[1\\]        self.\\_start\\_input.width \\= self.width//2        self.\\_end\\_input.width \\= self.width//2\n    @param.depends('\\_start\\_input.value', '\\_end\\_input.value', watch\\=True)    def \\_sync\\_params(self):        self.value \\= (self.\\_start\\_input.value, self.\\_end\\_input.value)\n\nFinally, we’ll implement the required `__panel__` method, which returns the Panel layout to be rendered. Panel will call this method when displaying the component.\n\nimport param\nimport panel as pn\n\nfrom panel.viewable import Viewer\n\npn.extension() \\# for notebook\n\nclass EditableRange(Viewer):\n\n    value \\= param.Range(doc\\=\"A numeric range.\")\n\n    width \\= param.Integer(default\\=300)\n\n    def \\_\\_init\\_\\_(self, \\*\\*params):\n        self.\\_start\\_input \\= pn.widgets.FloatInput()\n        self.\\_end\\_input \\= pn.widgets.FloatInput(align\\='end')\n        super().\\_\\_init\\_\\_(\\*\\*params)\n        self.\\_layout \\= pn.Row(self.\\_start\\_input, self.\\_end\\_input)\n        self.\\_sync\\_widgets()\n\n    def \\_\\_panel\\_\\_(self):\n        return self.\\_layout\n\n    @param.depends('value', 'width', watch\\=True)\n    def \\_sync\\_widgets(self):\n        self.\\_start\\_input.name \\= self.name\n        self.\\_start\\_input.value \\= self.value\\[0\\]\n        self.\\_end\\_input.value \\= self.value\\[1\\]\n        self.\\_start\\_input.width \\= self.width//2\n        self.\\_end\\_input.width \\= self.width//2\n\n    @param.depends('\\_start\\_input.value', '\\_end\\_input.value', watch\\=True)\n    def \\_sync\\_params(self):\n        self.value \\= (self.\\_start\\_input.value, self.\\_end\\_input.value)\n\nrange\\_widget \\= EditableRange(name\\='Range', value\\=(0, 10))\n\npn.Column(\n    '#### This is a custom widget',\n    range\\_widget\n)"
},
{
  "markdown": "## Authorization callbacks[#](#authorization-callbacks \"Permalink to this heading\")\n\nThe OAuth providers integrated with Panel provide an easy way to enable authentication on your applications. This verifies the identity of a user and also provides some level of access control (i.e. authorization). However often times the OAuth configuration is controlled by a corporate IT department or is otherwise difficult to manage so its often easier to grant permissions to use the OAuth provider freely but then restrict access controls in the application itself. To manage access you can provide an `authorize_callback` as part of your applications.\n\nThe `authorize_callback` can be configured on `pn.config` or via the `pn.extension`:\n\nimport panel as pn\n\ndef authorize(user\\_info):\n    with open('users.txt') as f:\n        valid\\_users \\= f.readlines()\n    return user\\_info\\['username'\\] in valid\\_users\n\npn.config.authorize\\_callback \\= authorize \\# or pn.extension(..., authorize\\_callback=authorize)\n\nThe `authorize_callback` is given a dictionary containing the data in the OAuth provider’s `id_token` and optionally the current endpoint that the user is trying to access. The example above checks whether the current user is in the list of users specified in a `user.txt` file. However you can implement whatever logic you want to either grant a user access or reject it.\n\nYou may return either a boolean `True`/`False` value OR a string, which will be used to redirect the user to a different URL or endpoint. As an example, you may redirect users to specific endpoints:\n\ndef authorize(user\\_info, page):\n    user \\= user\\_info\\['user'\\]\n\tif page \\== '/':\n        if user in ADMINS:\n\t        return '/admin'\n\t    else:\n\t\t    return '/user'\n    elif user in ADMINS:\n\t    return True\n\telse:\n\t    return page.startswith('/user')\n\nThe callback above would direct users visiting the root (`/`) to the appropriate endpoint depending on whether they are in the list of `ADMINS`. If the user is an admin they are granted access to both the `/user` and `/admin` endpoints while non-admin users will only be granted access to the `/user` endpoint.\n\nIf a user is not authorized, i.e. the callback returns `False`, they will be presented with an authorization error template which can be configured using the `--auth-template` commandline option or by setting `config.auth_template`.\n\n![](https://panel.holoviz.org/_static/images/authorization.png)\n\nThe auth template must be a valid Jinja2 template and accepts a number of arguments:\n\n*   `{{ title }}`: The page title.\n    \n*   `{{ error_type }}`: The type of error.\n    \n*   `{{ error }}`: A short description of the error.\n    \n*   `{{ error_msg }}`: A full description of the error.\n    \n\nThe `authorize_callback` may also contain a second parameter, which is set by the requested application path. You can use this extra parameter to check if a user is authenticated _and_ has access to the application at the given path.\n\nfrom urllib import parse\nimport panel as pn\n\nauthorized\\_user\\_paths \\= {\n    \"user1\": \\[\"/app1\", \"/app2\"\\],\n    \"user2\": \\[\"/app1\"\\],\n}\n\ndef authorize(user\\_info, request\\_path):\n    current\\_user \\= user\\_info\\['username'\\]\n    current\\_path \\= parse.urlparse(request\\_path).path\n    if current\\_user not in authorized\\_user\\_paths:\n        return False\n    current\\_user\\_paths \\= authorized\\_user\\_paths\\[current\\_user\\]\n    if current\\_path in current\\_user\\_paths:\n        return True\n    return False\n\npn.config.authorize\\_callback \\= authorize"
},
{
  "markdown": "## Build Components from Scratch[#](#build-components-from-scratch \"Permalink to this heading\")\n\nThis guide addresses how to build custom Panel components from scratch.\n\nPrerequisites\n\n1.  As a how-to guide, the intent is to provide recipes for specific problems without a lot of discussion. However, this is an advanced topic so if you get stuck, please read the associated [Explanation > Building Custom Components](https://panel.holoviz.org/explanation/components/components_custom.html) for further explanation.\n    \n\n* * *\n\nThe `ReactiveHTML` class provides bi-directional syncing of arbitrary HTML attributes and DOM properties with parameters on the subclass. The key part of the subclass is the `_template` variable. This is the HTML template that gets rendered and declares how to link parameters on the class to HTML attributes.\n\n## Callback Example[#](#callback-example \"Permalink to this heading\")\n\nLet’s declare a `Slideshow` component which subscribes to `click` events on an `<img>` element and advances the image `index` on each click:\n\nimport panel as pn\nimport param\n\nfrom panel.reactive import ReactiveHTML\n\npn.extension()\n\nclass Slideshow(ReactiveHTML):\n\n    index \\= param.Integer(default\\=0)\n\n    \\_template \\= '<img id=\"slideshow\" src=\"https://picsum.photos/800/300?image=${index}\" onclick=\"${\\_img\\_click}\"></img>'\n\n    def \\_img\\_click(self, event):\n        self.index += 1\n\nprint('run the code block above, then click on the image below')\n\nSlideshow(width\\=500, height\\=200)\n\nrun the code block above, then click on the image below\n\nAs we can see this approach lets us quickly build custom HTML components with complex interactivity. However if we do not need any complex computations in Python we can also construct a pure JS equivalent:\n\nclass JSSlideshow(ReactiveHTML):\n\n    index \\= param.Integer(default\\=0)\n\n    \\_template \\= \"\"\"<img id=\"slideshow\" src=\"https://picsum.photos/800/300?image=${index}\" onclick=\"${script('click')}\"></img>\"\"\"\n\n    \\_scripts \\= {'click': 'data.index += 1'}\n\nJSSlideshow(width\\=800, height\\=300)\n\n## Child Template Example[#](#child-template-example \"Permalink to this heading\")\n\nIf we want to provide a template for the children of an HTML node we have to use Jinja2 syntax to loop over the parameter. The component will insert the loop variable `option` into each of the tags:\n\nclass Select(ReactiveHTML):\n\n    options \\= param.List(doc\\=\"Options to choose from.\")\n\n    value \\= param.String(doc\\=\"Current selected option\")\n\n    \\_template \\= \"\"\"\n    <select id=\"select\" value=\"${value}\" style=\"width: ${model.width}px\">\n      {% for option in options %}\n      <option id=\"option\">${option}</option>\n      {% endfor %}\n    </select>\n    \"\"\"\n\n    \\_dom\\_events \\= {'select': \\['change'\\]}\n\nselect \\= Select(options\\=\\['A', 'B', 'C'\\])\nselect\n\nThe loop body can declare any number of HTML tags to add for each child object, e.g. to add labels or icons, however the child object (like the `{{option}}` or `${option}`) must always be wrapped by an HTML element (e.g. `<option>`) which must declare an `id`. Depending on your use case you can wrap each child in any HTML element you require, allowing complex nested components to be declared. Note that the example above inserted the `options` as child objects but since they are strings we could use literals instead:\n\n<select id\\=\"select\" value\\=\"${value}\" style\\=\"width: ${model.width}px\"\\>\n  {% for option in options %}\n  <option id\\=\"option-{{ loop.index0 }}\"\\>{{ option }}</option\\>\n  {% endfor %}\n</select\\>\n\nWhen using child literals we have to ensure that each `<option>` DOM node has a unique ID manually by inserting the `loop.index0` value (which would otherwise be added automatically).\n\n## Javascript Events Example[#](#javascript-events-example \"Permalink to this heading\")\n\nNext we will build a more complex example using pure Javascript events to draw on a canvas with configurable line width, color and the ability to clear and save the resulting drawing.\n\nimport panel as pn\n\nclass Canvas(ReactiveHTML):\n\n    color \\= param.Color(default\\='#000000')\n\n    line\\_width \\= param.Number(default\\=1, bounds\\=(0.1, 10))\n\n    uri \\= param.String()\n\n    \\_template \\= \"\"\"\n    <canvas\n      id=\"canvas\"\n      style=\"border: 1px solid;\"\n      width=\"${model.width}\"\n      height=\"${model.height}\"\n      onmousedown=\"${script('start')}\"\n      onmousemove=\"${script('draw')}\"\n      onmouseup=\"${script('end')}\"\n    >\n    </canvas>\n    <button id=\"clear\" onclick='${script(\"clear\")}'>Clear</button>\n    <button id=\"save\" onclick='${script(\"save\")}'>Save</button>\n    \"\"\"\n\n    \\_scripts \\= {\n        'render': \"\"\"\n          state.ctx = canvas.getContext(\"2d\")\n        \"\"\",\n        'start': \"\"\"\n          state.start = event\n          state.ctx.beginPath()\n          state.ctx.moveTo(state.start.offsetX, state.start.offsetY)\n        \"\"\",\n        'draw': \"\"\"\n          if (state.start == null)\n            return\n          state.ctx.lineTo(event.offsetX, event.offsetY)\n          state.ctx.stroke()\n        \"\"\",\n        'end': \"\"\"\n          delete state.start\n        \"\"\",\n        'clear': \"\"\"\n          state.ctx.clearRect(0, 0, canvas.width, canvas.height);\n        \"\"\",\n        'save': \"\"\"\n          data.uri = canvas.toDataURL();\n        \"\"\",\n        'line\\_width': \"\"\"\n          state.ctx.lineWidth = data.line\\_width;\n        \"\"\",\n        'color': \"\"\"\n          state.ctx.strokeStyle = data.color;\n        \"\"\"\n    }\n\ncanvas \\= Canvas(width\\=300, height\\=300)\n\n\\# We create a separate HTML element which syncs with the uri parameter of the Canvas\npng\\_view \\= pn.pane.HTML()\ncanvas.jslink(png\\_view, code\\={'uri': \"target.text = \\`<img src='${source.uri}'></img>\\`\"})\n\npn.Column(\n    '# Drag on canvas to draw\\\\n To export the drawing to a png click save.',\n    pn.Row(\n        canvas.controls(\\['color', 'line\\_width'\\]),\n        canvas,\n        png\\_view\n    )\n)\n\nThis example leverages all three ways a script is invoked:\n\n1.  `'render'` is called on initialization\n    \n2.  `'start'`, `'draw'` and `'end'` are explicitly invoked using the `${script(...)}` syntax in inline callbacks\n    \n3.  `'line_width'` and `'color'` are invoked when the parameters change (i.e. when a widget is updated)\n    \n\nIt also makes extensive use of the available objects in the namespace:\n\n*   `'render'`: Uses the `state` object to easily access the canvas rendering context in subsequent callbacks and accesses the `canvas` DOM node by name.\n    \n*   `'start'`, `'draw'`: Use the `event` object provided by the `onmousedown` and `onmousemove` inline callbacks\n    \n*   `'save'`, `'line_width'`, `'color'`: Use the `data` object to get and set the current state of the parameter values"
},
{
  "markdown": "If you need full control over how your GUI is set up then you can manually define widgets that link directly to other objects using either Python or JavaScript (JS) callbacks. Python callbacks are simple for Python users to write and can directly access Python data structures, while JS callbacks can directly manipulate the displayed HTML document and allow setting up dynamic behavior even for exported HTML files (with no Python process running). This section contains how-to guides that address common tasks related the use of callbacks.\n\nCreate High-Level Python Links with `.link`\n\nHow to use the convenient, high-level `.link` API to link parameters in Python.\n\nCreate Low-Level Python Links with `.watch`\n\nHow to use the flexible, low-level `.watch` API to trigger callbacks in Python.\n\nLink Two Objects in Javascript\n\nHow to link parameters of two objects in Javascript.\n\nLink Plot Parameters in Javascript\n\nHow to link Bokeh and HoloViews plot parameters in Javascript.\n\nLink Many Objects in Javascript\n\nHow to write arbitrary Javascript callbacks linking one or more objects.\n\n## Examples[#](#examples \"Permalink to this heading\")\n\n![](https://assets.holoviz.org/panel/how_to/links/bokeh_property_editor.png)\n\nBokeh Property Editor\n\nBuild a UI that allows editing a Bokeh figure in JS.\n\n![](https://assets.holoviz.org/panel/how_to/links/deckgl.png)\n\nDeck.gl\n\nJS Link JSON editors to allow live editing a Deck.gl plot.\n\n![](https://assets.holoviz.org/panel/how_to/links/holoviews_glyph_link.png)\n\nHoloViews\n\nJS Link widgets to a glyph in a HoloViews plot.\n\n![](https://assets.holoviz.org/panel/how_to/links/plotly.png)\n\nPlotly\n\nJS Link a widget to a Plotly plot.\n\n![](https://assets.holoviz.org/panel/how_to/links/vega.png)\n\nVega\n\nJS Link a widget to a Vega plot."
},
{
  "markdown": "## Allowing Guest Users[#](#allowing-guest-users \"Permalink to this heading\")\n\nSometimes you will want to allow guest users to have access to certain endpoints of your application or grant them access to all applications without having to log in. For these cases you can make the authentication flow optional and guide them towards the `login_endpoint` only when they are accessing functionality that requires authentication.\n\n## Optional Authentication[#](#optional-authentication \"Permalink to this heading\")\n\nThe simplest way to make authentication optional is to set the `--oauth-optional` on the commandline or when using `pn.serve` passing the `oauth_optional` keyword argument:\n\npanel serve app.py ... \\--oauth-optional\n\nPanel will now let the user access all endpoints without being redirected to the authentication provider or local login page. If specific functionality in your application requires authentication you may then redirect the user to the login endpoint, e.g. by default you would redirect them to `/login`. As an example let’s take this app:\n\nimport panel as pn\n\npn.extension(template\\='material')\n\npn.state.template.title \\= 'Optional Auth'\n\nif pn.state.user \\== 'guest':\n    button \\= pn.widgets.Button(name\\='Login').servable(target\\='header')\n    button.js\\_on\\_click(code\\='window.location.href=\"/login\"')\n\npn.Column(f'# Hello {pn.state.user}!', pn.state.user\\_info).servable()\n\nServing this app with `panel serve app.py ... --oauth-optional` and then visiting the `/app` endpoint will show the following:\n\n![Optional Auth Application](https://panel.holoviz.org/_images/optional_auth.png)\n\nAfter clicking the login link the user will be directed through the login flow.\n\nAlternatively you can declare an [`authorize_callback`](https://panel.holoviz.org/how_to/authentication/authorization.html) as part of your application which will redirect a guest user should they attempt to access a restricted endpoint:\n\nimport panel as pn\n\ndef authorize(user\\_info, path):\n    if user\\_info\\['user'\\] \\== 'guest' and path \\== '/admin':\n        return '/login'\n    return True\n\npn.extension(authorize\\_callback\\=authorize, template\\='material')\n\npn.state.template.title \\= 'Admin'\n\npn.Column(f'# Hello {pn.state.user}!', pn.state.user\\_info).servable()\n\n## Guest Endpoints[#](#guest-endpoints \"Permalink to this heading\")\n\nIf you only want to open up specific endpoints to guest users you may also provide `--oauth-guest-endpoints`, e.g. let’s say you have `app.py` and `admin.py`. On the commandline you can provide:\n\npanel serve app.py admin.py ... \\--oauth-guest-endpoints /app\n\nThis will allow users to access the `/app` endpoint as a guest but force them through the login flow if they attempt to access the `/admin` endpoint."
},
{
  "markdown": "## How-to[#](#how-to \"Permalink to this heading\")\n\nThe Panel How-to guides provide step by step recipes for solving essential problems and tasks that arise during your work. They assume that you’ve completed the Getting Started material and therefore already have some knowledge of how Panel works. There is no order to the guides, other than any potential prerequisites listed at the top of a page. Jump to the topic that is relevant to you now.\n\n## Prepare to develop[#](#prepare-to-develop \"Permalink to this heading\")\n\nDevelop in a notebook\n\nHow to effectively develop apps in a notebook environment.\n\nDevelop in an editor\n\nHow to effectively develop apps in a Python or Markdown file.\n\n## Build apps[#](#build-apps \"Permalink to this heading\")\n\nConstruct components\n\nHow to construct and customize individual components like an image or slider widget.\n\nArrange Components\n\nHow to arrange and size components on the page.\n\nStyle components\n\nHow to apply designs, themes and custom styling to components to achieve a polished look and feel.\n\nAdd interactivity\n\nHow to link add interactivity to your applications using reactive APIs.\n\nApply templates\n\nHow to use a Template to customize the look and feel of a deployed Panel app.\n\n## Use specialized UIs and APIs[#](#use-specialized-uis-and-apis \"Permalink to this heading\")\n\nBuild a sequential UI\n\nHow to build a Panel Pipeline that connects multiple panels into a sequential user interface.\n\nBuild custom components\n\nHow to extend Panel by building custom components.\n\nGenerate UIs from declared parameters (`Declarative API`)\n\nHow to use Parameterized classes with Panel to generate UIs without writing GUI code.\n\nExplicitly link parameters (`Callbacks API`)\n\nHow to link the parameters of Panel components in Python and Javascript.\n\n## Manage session tasks[#](#manage-session-tasks \"Permalink to this heading\")\n\nRegister session callbacks\n\nHow to set up callbacks on session related events (e.g. on page load or when a session is destroyed) and define periodic tasks.\n\nAccess session state\n\nHow to access and manipulate state related to the user session, HTTP request and URL arguments.\n\n## Test and debug[#](#test-and-debug \"Permalink to this heading\")\n\nEnable profiling and debugging\n\nHow to profile and debug your application using the admin dashboard and other tools.\n\nSet up testing for an application\n\nHow to set up unit tests, UI tests and load testing to ensure your applications are (and stay) robust and scalable.\n\n## Share your work[#](#share-your-work \"Permalink to this heading\")\n\nConfigure the server\n\nHow to configure the Panel server.\n\nIntegrate with other servers\n\nHow to integrate Panel in other application based on Flask, FastAPI or Django.\n\nDeploy applications\n\nHow to deploy Panel applications to various cloud providers (e.g. Azure, GCP, AWS etc.)\n\nExport apps\n\nHow to export and save Panel applications as static files.\n\nRun panel in WebAssembly\n\nHow to run Panel applications entirely in the browser using WebAssembly (Wasm), Pyodide, and PyScript.\n\n## Migrate to Panel[#](#migrate-to-panel \"Permalink to this heading\")\n\nMigrate from Streamlit\n\n[![https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)\n\nHow to migrate existing Streamlit applications to Panel."
},
{
  "markdown": "This guide addresses how to use the convenient, high-level `.link` API to link parameters in Python.\n\n* * *\n\nTo start, let’s see how a `TextInput` widget and a `Markdown` pane normally behave:\n\nimport panel as pn\n\npn.extension()\n\npn.Row(\n    pn.widgets.TextInput(value\\=\"Editable text\"),\n    pn.pane.Markdown('Some markdown')\n)\n\nThese two Panel objects are entirely independent; text can be entered into the input area and separately the Markdown pane will display its argument.\n\nWhat if we wanted connected input and output displays? One option when you expect to have a live Python process available is to use the `link` method on Widgets to link its parameters to some other Panel object. In the simplest case we simply provide the `target` object and define the mapping between the source and target parameters as the keywords. In this case, we map the `value` parameter on the `TextInput` widget to the `object` parameter on the `Markdown` pane:\n\nmarkdown \\= pn.pane.Markdown(\"Some text\")\ntext\\_input \\= pn.widgets.TextInput(value\\=markdown.object)\n\ntext\\_input.link(markdown, value\\='object')\n\npn.Row(text\\_input, markdown)\n\nNow, if Python is running and you type something in the box above and press Return, the corresponding Markdown pane should update to match. And if you use Python to directly manipulate the value of the text input (e.g. by editing the following cell to have new text in it and then executing it), then the Markdown should also update to match:\n\ntext\\_input.value \\= 'Some text'\n\nFor more complex mappings between the widget value and the target parameter, we can define an arbitrary transformation as a Python callback:\n\nm \\= pn.pane.Markdown(\"\")\nt \\= pn.widgets.TextInput()\n\ndef callback(target, event):\n    target.object \\= event.new.upper() + '!!!'\n\nt.link(m, callbacks\\={'value': callback})\nt.value\\=\"Some text\"\n\npn.Row(t, m)\n\nNote that here we explicitly set `t.value` before displaying the panel to trigger the linked Markdown pane to update to match the text widget; callbacks are not otherwise triggered when the links are first set up.\n\n* * *"
},
{
  "markdown": "This guide addresses how to use the low-level `.watch` API to trigger callbacks on parameters.\n\nPrerequisites\n\n1.  The [How to > Create High-Level Python Links with ‘.link’](https://panel.holoviz.org/how_to/links/links.html) guide demonstrates a high-level API to link to parameters, which is adequate in most cases.\n    \n\n* * *\n\nIf we need more control than what `.link` provides, we can fall back to the underlying `.watch` method. The main differences are that `.watch`:\n\n1.  does not assume you are linking two objects (providing more control over what you are watching)\n    \n2.  allows batched callbacks when multiple parameters change at once\n    \n3.  allows you to specify that an event should be triggered every time the parameter is set (instead of the default of only when the parameter value actually changes)\n    \n\nTo demonstrate `.watch`, let us set up three different models:\n\n1.  `Markdown` pane to display the possible options\n    \n2.  `Markdown` pane to display the _selected_ options\n    \n3.  `ToggleGroup` widget that allows us to toggle between a number of options\n    \n\nimport panel as pn\n\npn.extension()\n\nselections \\= pn.pane.Markdown(object\\='')\nselected \\= pn.pane.Markdown(object\\='')\ntoggle \\= pn.widgets.ToggleGroup(options\\=\\['A', 'B'\\])\n\n## Defining a callback[#](#defining-a-callback \"Permalink to this heading\")\n\nNext we define a callback that can handle multiple parameter changes at once and uses the `Event`’s `name` to figure out how to process the event. In this case it updates either the `selections` or the `selected` pane depending on whether ToggleGroup `options` or `value` changed:\n\ndef callback(\\*events):\n    print(events)\n    for event in events:\n        if event.name \\== 'options':\n            selections.object \\= 'Possible options: %s' % ', '.join(event.new)\n        elif event.name \\== 'value':\n            selected.object \\= 'Selected: %s' % ','.join(event.new)\n\n## Event objects[#](#event-objects \"Permalink to this heading\")\n\nBefore going any further let us discover what these `Event` objects are. An `Event` is used to signal the change in a parameter value. Event objects provide a number of useful attributes that provides additional information about the event:\n\n*   **`name`**: The name of the parameter that has changed\n    \n*   **`new`**: The new value of the parameter\n    \n*   **`old`**: The old value of the parameter before the event was triggered\n    \n*   **`type`**: The type of event (‘triggered’, ‘changed’, or ‘set’)\n    \n*   **`what`**: Describes what about the parameter changed (usually the value but other parameter attributes can also change)\n    \n*   **`obj`**: The Parameterized instance that holds the parameter\n    \n*   **`cls`**: The Parameterized class that holds the parameter\n    \n\n## Registering a watcher[#](#registering-a-watcher \"Permalink to this heading\")\n\nNow that we know how to define a callback and make use of `Event` attributes, it is time to register the callback. The `obj.param.watch` method lets us supply the callback along with the parameters we want to watch. Additionally we can declare whether the events should only be triggered when the parameter value changes, or every time the parameter is set:\n\nwatcher \\= toggle.param.watch(callback, \\['options', 'value'\\], onlychanged\\=False)\n\nNow let us display the widget alongside the `Markdown` panes that reflect the current state of the widget:\n\npn.Row(pn.Column(toggle, width\\=200, height\\=50), selections, pn.Spacer(width\\=50, height\\=50), selected)\n\nTo initialize the `selections` and `selected` we can explicitly `trigger` options and value events:\n\ntoggle.param.trigger('options', 'value')\n\n(Event(what='value', name='options', obj=CheckButtonGroup(options=\\['A', 'B'\\]), cls=CheckButtonGroup(options=\\['A', 'B'\\]), old=\\['A', 'B'\\], new=\\['A', 'B'\\], type='triggered'), Event(what='value', name='value', obj=CheckButtonGroup(options=\\['A', 'B'\\]), cls=CheckButtonGroup(options=\\['A', 'B'\\]), old=\\[\\], new=\\[\\], type='triggered'))\n\nWe can also override the initial parameters using the `update` method:\n\noptions \\= \\['A','B','C','D'\\]\ntoggle.param.update(options\\=dict(zip(options,options)), value\\=\\['D'\\])\n\n(Event(what='value', name='options', obj=CheckButtonGroup(options={'A': 'A', 'B': 'B', ...}, value=\\['D'\\]), cls=CheckButtonGroup(options={'A': 'A', 'B': 'B', ...}, value=\\['D'\\]), old=\\['A', 'B'\\], new={'A': 'A', 'B': 'B', 'C': 'C', 'D': 'D'}, type='set'), Event(what='value', name='value', obj=CheckButtonGroup(options={'A': 'A', 'B': 'B', ...}, value=\\['D'\\]), cls=CheckButtonGroup(options={'A': 'A', 'B': 'B', ...}, value=\\['D'\\]), old=\\[\\], new=\\['D'\\], type='set'))\n\n<param.parameterized.\\_ParametersRestorer object at 0x10dae13a0>\n\nUsing `update` allows us to batch two separate changes (the options and the value) together, which you can see from the `print` output resulted into a single invocation of the callback. You could instead have set them separately using the usual parameter-setting syntax `toggle.value=['D']; toggle.options=dict(zip(options,options))`, but batching them can be much more efficient for a non-trivial callback like a database query or a complex plot that needs updating.\n\nNow that the widgets are visible, you can toggle the option values and see the selected pane update in response via the callback (if Python is running).\n\n## Unlinking[#](#unlinking \"Permalink to this heading\")\n\nIf for whatever reason we want to stop watching parameter changes we can unsubscribe by passing our `watcher` (returned in the `watch` call above) to the `unwatch` method:\n\ntoggle.param.unwatch(watcher)\n\n* * *"
},
{
  "markdown": "This guide addresses how to link parameters of two objects in Javascript.\n\n* * *\n\nLinking objects in Python is often very convenient because it allows writing code entirely in Python. However, it also requires a live Python kernel. If instead we want a static example (e.g. on a simple website or in an email) to have custom interactivity, or we simply want to avoid the overhead of having to call back into Python, we can define links in JavaScript.\n\n## Link model properties[#](#link-model-properties \"Permalink to this heading\")\n\nLet us start by linking the `value` of the `TextInput` widget to the `object` property of a `Markdown` pane:\n\nimport panel as pn\n\npn.extension()\n\nmarkdown \\= pn.pane.Markdown('Markdown display')\ntext\\_input \\= pn.widgets.TextInput(value\\=markdown.object)\n\nlink \\= text\\_input.jslink(markdown, value\\='object')\n\npn.Row(text\\_input, markdown)\n\nAs you can see, Panel translates the specification into a JS code snippet which syncs the properties on the underlying Bokeh properties. But now if you edit the widget and press Return, the Markdown display will automatically update even in a static HTML web page.\n\n## Link bi-directionally[#](#link-bi-directionally \"Permalink to this heading\")\n\nWhen you want the source and target to be linked bi-directionally, i.e. a change in one will automatically trigger a change in the other you can simply set the `bidirectional` argument:\n\nt1 \\= pn.widgets.TextInput()\nt2 \\= pn.widgets.TextInput()\n\nt1.jslink(t2, value\\='value', bidirectional\\=True)\n\npn.Row(t1, t2)\n\n## Link using custom JS code[#](#link-using-custom-js-code \"Permalink to this heading\")\n\nSince everything happens in JS for a `jslink`, we can’t provide a Python callback. Instead, we can define a JS code snippet, which is executed when a property changes. E.g. we can define a little code snippet which adds HTML bold tags (`<b>`) around the text before setting it on the target. The code argument should map from the parameter/property on the source object to the JS code snippet to execute:\n\nmarkdown \\= pn.pane.Markdown(\"<b>Markdown display</b>\", width\\=400)\ntext\\_input \\= pn.widgets.TextInput(value\\=\"Markdown display\")\n\ncode \\= '''\n    target.text = '<b>' + source.value + '</b>'\n'''\nlink \\= text\\_input.jslink(markdown, code\\={'value': code})\n\npn.Row(text\\_input, markdown)\n\nHere `source` and `target` are made available in the JavaScript namespace, allowing us to arbitrarily modify the models in response to property change events. Note however that the underlying Bokeh model property names may differ slightly from the naming of the parameters on Panel objects, e.g. the ‘object’ parameter on the Markdown pane translates to the ‘text’ property on the Bokeh model used to render the `Markdown`.\n\nOf course, you can still update the value from Python, and it will automatically update the linked markdown:\n\ntext\\_input.value \\= \"Markdown display\"\n\n## Responding to click events[#](#responding-to-click-events \"Permalink to this heading\")\n\nTo respond to click events, we’ll demonstrate an example of using `js_on_click`. This example will open a URL from the `TextInput` widget value in a new browser tab:\n\nbutton \\= pn.widgets.Button(name\\='Open URL', button\\_type \\= 'primary')\nurl \\= pn.widgets.TextInput(name\\='URL', value \\= 'https://holoviz.org/')\nbutton.js\\_on\\_click(args\\={'target': url}, code\\='window.open(target.value)')\npn.Row(url, button)\n\n* * *"
},
{
  "markdown": "This guide addresses how to link Bokeh and HoloViews plot parameters in Javascript.\n\n* * *\n\nThe [How to > Link Two Objects in Javascript](https://panel.holoviz.org/how_to/links/jslinks.html) guide demonstrated how to link simple static panes, but links are probably most useful when combined with dynamic objects like plots.\n\n## Link Bokeh plots[#](#link-bokeh-plots \"Permalink to this heading\")\n\nThe `jslink` API trivially allows us to link a parameter on a Panel widget to a Bokeh plot property. Here we create a Bokeh Figure with a simple sine curve. The `jslink` method allows us to pass any Bokeh model held by the Figure as the `target`, then link the widget value to some property on it. E.g. here we link a `FloatSlider` value to the `line_width` of the `Line` glyph:\n\nimport numpy as np\nimport panel as pn\n\nfrom bokeh.plotting import figure\n\npn.extension()\n\np \\= figure(width\\=300, height\\=300)\nxs \\= np.linspace(0, 10)\nr \\= p.line(xs, np.sin(xs))\n\nwidth\\_slider \\= pn.widgets.FloatSlider(name\\='Line Width', start\\=0.1, end\\=10)\nwidth\\_slider.jslink(r.glyph, value\\='line\\_width')\n\npn.Column(width\\_slider, p)\n\n### Link HoloViews plots[#](#link-holoviews-plots \"Permalink to this heading\")\n\nBokeh models allow us to directly access the underlying models and properties, but this access is more indirect when working with HoloViews objects. HoloViews makes various models available directly in the namespace so that they can be accessed for linking:\n\n*   **`cds`**: The bokeh `ColumnDataSource` model which holds the data used to render the plot\n    \n*   **`glyph`**: The bokeh `Glyph` defining the style of the element\n    \n*   **`glyph_renderer`**: The Bokeh `GlyphRenderer` responsible for rendering the element\n    \n*   **`plot`**: The bokeh `Figure`\n    \n*   **`xaxis`/`yaxis`**: The Axis models of the plot\n    \n*   **`x_range`/`y_range`**: The x/y-axis `Range1d` models defining the axis ranges\n    \n\nAll these are made available in the JS code’s namespace if we decide to provide a JS code snippet, but can also be referenced in the property mapping. We can map the widget value to a property on the `glyph` by providing a specification separated by periods. E.g. in this case we can map the value to the `glyph.size`:\n\nimport holoviews as hv\nimport holoviews.plotting.bokeh\n\ncolors \\= \\[\"black\", \"red\", \"blue\", \"green\", \"gray\"\\]\n\nsize\\_widget \\= pn.widgets.FloatSlider(value\\=8, start\\=3, end\\=20, name\\='Size')\ncolor\\_widget \\= pn.widgets.Select(name\\='Color', options\\=colors, value\\='black')\n\npoints \\= hv.Points(np.random.rand(10, 2)).options(padding\\=0.1, line\\_color\\='black')\n\nsize\\_widget.jslink(points, value\\='glyph.size')\ncolor\\_widget.jslink(points, value\\='glyph.fill\\_color')\n\npn.Row(points, pn.Column(size\\_widget, color\\_widget))\n\nOf course, if you need to transform between the displayed widget value and the value to be used on the underlying Bokeh property, you can add custom JS code as shown in [the guide on JS-callbacks](https://panel.holoviz.org/how_to/links/jscallbacks.html). Together these linking options should allow you to express whatever interactions you wish between your Panel objects."
},
{
  "markdown": "This guide addresses how to write arbitrary JS callbacks linking one or more components.\n\nPrerequisites\n\n1.  The [How to > Link Two Objects in Javascript](https://panel.holoviz.org/how_to/links/links.html) guide demonstrates how to use the `.jslink` API to link parameters from two objects in Javascript, which is adequate in most cases.\n    \n\n* * *\n\nSometimes defining a simple link between two objects is not sufficient, e.g. when there are a number of objects involved. In these cases it is helpful to be able to define arbitrary Javascript callbacks. A very simple example is a very basic calculator which allows multiplying or adding two values, in this case we have two widgets to input numbers, a selector to pick the operation, a display for the result and a button.\n\nTo implement this we define a `jscallback`, which is triggered when the `Button.clicks` property changes and provide a number of `args` allowing us to access the values of the various widgets:\n\nimport panel as pn\n\npn.extension()\n\nvalue1 \\=   pn.widgets.Spinner(value\\=0, width\\=75)\noperator \\= pn.widgets.Select(value\\='\\*', options\\=\\['\\*', '+'\\], width\\=50, align\\='center')\nvalue2 \\=   pn.widgets.Spinner(value\\=0, width\\=75)\nbutton \\=   pn.widgets.Button(name\\='=', width\\=50)\nresult \\=   pn.widgets.StaticText(value\\='0', width\\=50, align\\='center')\n\nbutton.jscallback(clicks\\=\"\"\"\nif (op.value == '\\*')\n  result.text = (v1.value \\* v2.value).toString()\nelse\n  result.text = (v1.value + v2.value).toString()\n\"\"\", args\\={'op': operator, 'result': result, 'v1': value1, 'v2': value2})\n\npn.Row(value1, operator, value2, button, result)"
},
{
  "markdown": "Panel is built on [Param](https://param.holoviz.org/) - a library for handling all the user-modifiable parameters, arguments, and attributes that control your code. This section contains how-to guides for using `Param` objects and declared dependencies to generate user interfaces with Panel.\n\nGenerate Widgets from `Parameters`\n\nHow to generate UIs from Parameterized classes without writing any GUI related code.\n\nDeclare Custom Widgets\n\nHow to extend Param based UIs with custom widgets.\n\nDeclare Parameter dependencies\n\nHow to leverage `@param.depends` to express dependencies and trigger events based on UI interactions.\n\nCreate nested UIs\n\nHow to structure Parameterized classes with subobjects to create nested UIs automatically.\n\n## Examples[#](#examples \"Permalink to this heading\")\n\n![](https://assets.holoviz.org/panel/how_to/param/action_button.png)\n\nAction Button\n\nUsing `param.Action` to define a UI with a button.\n\n![](https://assets.holoviz.org/panel/how_to/param/loading.png)\n\nAutomatic Loading Indicator\n\nAutomatically enable a loading indicator for components rendered dynamically.\n\n![](https://assets.holoviz.org/panel/how_to/param/subobjects.png)\n\nParam Subobjects\n\nUsing Param to express a nested UI using a hierarchy of classes.\n\n![](https://assets.holoviz.org/panel/how_to/param/precedence.png)\n\nPrecedence\n\nUsing Parameter precedence to control the visibility of components."
},
{
  "markdown": "## Generate Widgets from `Parameters`[#](#generate-widgets-from-parameters \"Permalink to this heading\")\n\nThis guide addresses how to generate UIs from Parameterized classes without writing any GUI related code.\n\nPrerequisites\n\n1.  The [Param User Guide](https://param.holoviz.org/index.html) provides the conceptual foundation for use of `Parameterized` objects.\n    \n\n* * *\n\nParameters are Python attributes extended using the [Param library](https://param.holoviz.org/) to support types, ranges, and documentation, which turns out to be just the information you need to automatically create widgets for each parameter.\n\n## Declaring and displaying parameters[#](#declaring-and-displaying-parameters \"Permalink to this heading\")\n\nInternally parameters have a mapping that generates widgets appropriate for each type. This means that by declaring a `Parameterized` class we can automatically generate a full UI. Let us declare a `BaseClass`:\n\nimport param\nimport panel as pn\nimport pandas as pd\nimport datetime as dt\n\npn.extension()\n\nclass BaseClass(param.Parameterized):\n    x                       \\= param.Parameter(default\\=3.14, doc\\=\"X position\")\n    y                       \\= param.Parameter(default\\=\"Not editable\", constant\\=True)\n    string\\_value            \\= param.String(default\\=\"str\", doc\\=\"A string\")\n    num\\_int                 \\= param.Integer(default\\=50000, bounds\\=(\\-200, 100000))\n    unbounded\\_int           \\= param.Integer(default\\=23)\n    float\\_with\\_hard\\_bounds  \\= param.Number(default\\=8.2, bounds\\=(7.5, 10))\n    float\\_with\\_soft\\_bounds  \\= param.Number(default\\=0.5, bounds\\=(0, None), softbounds\\=(0,2))\n    unbounded\\_float         \\= param.Number(default\\=30.01, precedence\\=0)\n    hidden\\_parameter        \\= param.Number(default\\=2.718, precedence\\=-1)\n    integer\\_range           \\= param.Range(default\\=(3, 7), bounds\\=(0, 10))\n    float\\_range             \\= param.Range(default\\=(0, 1.57), bounds\\=(0, 3.145))\n    dictionary              \\= param.Dict(default\\={\"a\": 2, \"b\": 9})\n\nand then render the resulting UI using Panel:\n\npn.Param(BaseClass.param)\n\nBy changing a widget and re-running the following outputs, we can see that changes in the widgets are automatically reflected in Python:\n\nThe reverse is also true; editing a parameter from Python will automatically update any widgets that were generated from the parameter:\n\nBaseClass.num\\_int \\= 1\npn.Param(BaseClass.param.num\\_int)\n\nPassing the `.param` object renders the full set of widgets, while passing a single parameter will display just one widget. In this way we can easily declare exactly which parameters to display:\n\npn.Row(BaseClass.param.float\\_range, BaseClass.param.num\\_int)\n\n## Advanced parameters[#](#advanced-parameters \"Permalink to this heading\")\n\nThe `BaseClass` primarily declared simple parameters, however there are a wide range of parameter types covering many use cases. Below we define a subclass with some of these additional parameter types.\n\nclass Example(BaseClass):\n    \"\"\"An example Parameterized class\"\"\"\n\n    timestamps \\= \\[\\]\n\n    boolean                 \\= param.Boolean(default\\=True, doc\\=\"A sample Boolean parameter\")\n    color                   \\= param.Color(default\\='#FFFFFF')\n    date                    \\= param.Date(default\\=dt.datetime(2017, 1, 1),\n                                         bounds\\=(dt.datetime(2017, 1, 1), dt.datetime(2017, 2, 1)))\n    dataframe               \\= param.DataFrame(default\\=pd.\\_testing.makeDataFrame().iloc\\[:3\\])\n    select\\_string           \\= param.ObjectSelector(default\\=\"yellow\", objects\\=\\[\"red\", \"yellow\", \"green\"\\])\n    select\\_fn               \\= param.ObjectSelector(default\\=list,objects\\=\\[list, set, dict\\])\n    int\\_list                \\= param.ListSelector(default\\=\\[3, 5\\], objects\\=\\[1, 3, 5, 7, 9\\], precedence\\=0.5)\n    single\\_file             \\= param.FileSelector(path\\='../../\\*/\\*.py\\*', precedence\\=0.5)\n    multiple\\_files          \\= param.MultiFileSelector(path\\='../../\\*/\\*.py?', precedence\\=0.5)\n    record\\_timestamp        \\= param.Action(default\\=lambda x: x.timestamps.append(dt.datetime.utcnow()),\n                                           doc\\=\"\"\"Record timestamp.\"\"\", precedence\\=0.7)\n\nexample \\= Example()\n\npn.Param(example.param)\n\nFor example, the `Example.timestamps` Parameter records the timestamps from every “record timestamp” button press above. Rerun the code block below after clicking the button in order to see the output in the docs.\n\n* * *"
},
{
  "markdown": "## Declare Custom Widgets[#](#declare-custom-widgets \"Permalink to this heading\")\n\nThis guide addresses how to extend Param based UIs with custom widgets.\n\n* * *\n\n## Custom type[#](#custom-type \"Permalink to this heading\")\n\n`Param Parameters` can automatically be turned into widgets because Panel maintains a mapping between `Parameter` types and widget types. However, sometimes the default widget does not provide the most convenient UI and we want to provide an explicit hint to Panel to tell it how to render a `Parameter`. Using the `widgets` keyword we can declare a mapping between the parameter name and the type of widget that is desired (as long as the widget type supports the types of values held by the parameter type).\n\nAs an example, we can map a string and a number Selector to a `RadioButtonGroup` and `DiscretePlayer` respectively.\n\nimport panel as pn\nimport param\n\npn.extension()\n\nclass CustomExample(param.Parameterized):\n    \"\"\"An example Parameterized class\"\"\"\n\n    select\\_string \\= param.Selector(objects\\=\\[\"red\", \"yellow\", \"green\"\\])\n    autocomplete\\_string \\= param.Selector(default\\='', objects\\=\\[\"red\", \"yellow\", \"green\"\\], check\\_on\\_set\\=False)\n    select\\_number \\= param.Selector(objects\\=\\[0, 1, 10, 100\\])\n\npn.Param(CustomExample.param, widgets\\={\n    'select\\_string': pn.widgets.RadioButtonGroup,\n    'autocomplete\\_string': pn.widgets.AutocompleteInput,\n    'select\\_number': pn.widgets.DiscretePlayer}\n)\n\nAlso, it’s possible to pass arguments to the widget in order to customize it. Instead of passing the widget, pass a dictionary with the desired options. Use the `widget_type` keyword to map the widget.\n\nTaking up the previous example.\n\npn.Param(CustomExample.param, widgets\\={\n    'select\\_string': {'widget\\_type': pn.widgets.RadioButtonGroup, 'button\\_type': 'success'},\n    'autocomplete\\_string': {'widget\\_type': pn.widgets.AutocompleteInput, 'placeholder': 'Find a color...'},\n    'select\\_number': pn.widgets.DiscretePlayer}\n)\n\nHowever it is also possible to explicitly construct a widget from a parameter using the `.from_param` method, which makes it easy to override widget settings using keyword arguments:\n\npn.widgets.RadioBoxGroup.from\\_param(CustomExample.param.select\\_string, inline\\=True)\n\n## Custom name[#](#custom-name \"Permalink to this heading\")\n\nBy default, a param Pane has a title that is derived from the class name of its `Parameterized` object. Using the `name` keyword we can set any title to the pane, e.g. to improve the user interface.\n\npn.Param(CustomExample.param, name\\=\"Custom Name\")\n\n## Custom Sort[#](#custom-sort \"Permalink to this heading\")\n\nYou can sort the widgets alphabetically by setting `sort=True`\n\npn.Param(CustomExample.param, sort\\=True, name\\=\"Sort by Label Example\")\n\nYou can also specify a custom sort function that takes the (parameter name, Parameter instance) as input.\n\ndef sort\\_func(x):\n    return len(x\\[1\\].label)\n\npn.Param(CustomExample.param, sort\\=sort\\_func, name\\=\"Sort by Label Length Example\")\n\n* * *"
},
{
  "markdown": "## How-to[#](#how-to \"Permalink to this heading\")\n\nThe Panel How-to guides provide step by step recipes for solving essential problems and tasks that arise during your work. They assume that you’ve completed the Getting Started material and therefore already have some knowledge of how Panel works. There is no order to the guides, other than any potential prerequisites listed at the top of a page. Jump to the topic that is relevant to you now.\n\n## Prepare to develop[#](#prepare-to-develop \"Permalink to this heading\")\n\nDevelop in a notebook\n\nHow to effectively develop apps in a notebook environment.\n\nDevelop in an editor\n\nHow to effectively develop apps in a Python or Markdown file.\n\n## Build apps[#](#build-apps \"Permalink to this heading\")\n\nConstruct components\n\nHow to construct and customize individual components like an image or slider widget.\n\nArrange Components\n\nHow to arrange and size components on the page.\n\nStyle components\n\nHow to apply designs, themes and custom styling to components to achieve a polished look and feel.\n\nAdd interactivity\n\nHow to link add interactivity to your applications using reactive APIs.\n\nApply templates\n\nHow to use a Template to customize the look and feel of a deployed Panel app.\n\n## Use specialized UIs and APIs[#](#use-specialized-uis-and-apis \"Permalink to this heading\")\n\nBuild a sequential UI\n\nHow to build a Panel Pipeline that connects multiple panels into a sequential user interface.\n\nBuild custom components\n\nHow to extend Panel by building custom components.\n\nGenerate UIs from declared parameters (`Declarative API`)\n\nHow to use Parameterized classes with Panel to generate UIs without writing GUI code.\n\nExplicitly link parameters (`Callbacks API`)\n\nHow to link the parameters of Panel components in Python and Javascript.\n\n## Manage session tasks[#](#manage-session-tasks \"Permalink to this heading\")\n\nRegister session callbacks\n\nHow to set up callbacks on session related events (e.g. on page load or when a session is destroyed) and define periodic tasks.\n\nAccess session state\n\nHow to access and manipulate state related to the user session, HTTP request and URL arguments.\n\n## Test and debug[#](#test-and-debug \"Permalink to this heading\")\n\nEnable profiling and debugging\n\nHow to profile and debug your application using the admin dashboard and other tools.\n\nSet up testing for an application\n\nHow to set up unit tests, UI tests and load testing to ensure your applications are (and stay) robust and scalable.\n\n## Share your work[#](#share-your-work \"Permalink to this heading\")\n\nConfigure the server\n\nHow to configure the Panel server.\n\nIntegrate with other servers\n\nHow to integrate Panel in other application based on Flask, FastAPI or Django.\n\nDeploy applications\n\nHow to deploy Panel applications to various cloud providers (e.g. Azure, GCP, AWS etc.)\n\nExport apps\n\nHow to export and save Panel applications as static files.\n\nRun panel in WebAssembly\n\nHow to run Panel applications entirely in the browser using WebAssembly (Wasm), Pyodide, and PyScript.\n\n## Migrate to Panel[#](#migrate-to-panel \"Permalink to this heading\")\n\nMigrate from Streamlit\n\n[![https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)\n\nHow to migrate existing Streamlit applications to Panel."
},
{
  "markdown": "## Create nested UIs[#](#create-nested-uis \"Permalink to this heading\")\n\nThis guide addresses how to structure `Parameterized` classes with subobjects to create nested UIs automatically.\n\nPrerequisites\n\n1.  The [How to > Generate Widgets from Parameters](https://panel.holoviz.org/how_to/param/uis.html) guide demonstrates the generation of widgets.\n    \n2.  The [How to >](https://panel.holoviz.org/how_to/param/dependencies.html) guide demonstrates how to use `@param.depends` to express dependencies between parameters and functions.\n    \n\n* * *\n\n`Parameterized` objects often have parameter values which are themselves `Parameterized` objects, forming a tree-like structure. Panel allows you to edit not just the main object’s parameters but also lets you drill down to the subobject. Let us first define some classes declaring a hierarchy of Shape classes which draw a Bokeh plot of the selected shape:\n\nimport numpy as np\nimport panel as pn\nimport param\n\nfrom bokeh.plotting import figure\n\npn.extension()\n\nclass Shape(param.Parameterized):\n\n    radius \\= param.Number(default\\=1, bounds\\=(0, 1))\n\n    def \\_\\_init\\_\\_(self, \\*\\*params):\n        super(Shape, self).\\_\\_init\\_\\_(\\*\\*params)\n        self.figure \\= figure(x\\_range\\=(\\-1, 1), y\\_range\\=(\\-1, 1))\n        self.renderer \\= self.figure.line(\\*self.\\_get\\_coords())\n\n    def \\_get\\_coords(self):\n        return \\[\\], \\[\\]\n\n    def view(self):\n        return self.figure\n\nclass Circle(Shape):\n\n    n \\= param.Integer(default\\=100, precedence\\=-1)\n\n    def \\_get\\_coords(self):\n        angles \\= np.linspace(0, 2 \\* np.pi, self.n + 1)\n        return (self.radius \\* np.sin(angles),\n                self.radius \\* np.cos(angles))\n\n    @param.depends('radius', watch\\=True)\n    def update(self):\n        xs, ys \\= self.\\_get\\_coords()\n        self.renderer.data\\_source.data.update({'x': xs, 'y': ys})\n\nclass NGon(Circle):\n\n    n \\= param.Integer(default\\=3, bounds\\=(3, 10), precedence\\=1)\n\n    @param.depends('radius', 'n', watch\\=True)\n    def update(self):\n        xs, ys \\= self.\\_get\\_coords()\n        self.renderer.data\\_source.data.update({'x': xs, 'y': ys})\n\nNow that we have multiple Shape classes we can make instances of them and declare a `ShapeViewer` to select between them. We can also declare two methods with parameter dependencies, updating the plot and the plot title. The important thing to note here is that the `param.depends` decorator can not only depend on parameters on the object itself but also on specific parameters on the subobject, e.g. `shape.radius`, or on all parameters of the subobject, expressed as `shape.param`.\n\nshapes \\= \\[NGon(), Circle()\\]\n\nclass ShapeViewer(param.Parameterized):\n\n    shape \\= param.ObjectSelector(default\\=shapes\\[0\\], objects\\=shapes)\n\n    @param.depends('shape')\n    def view(self):\n        return self.shape.view()\n\n    @param.depends('shape', 'shape.radius')\n    def title(self):\n        return '## %s (radius=%.1f)' % (type(self.shape).\\_\\_name\\_\\_, self.shape.radius)\n\n    def panel(self):\n        return pn.Column(self.title, self.view)\n\nNow that we have a class with subobjects we can display it as usual. Three main options control how the subobject is rendered:\n\n*   `expand`: Whether the subobject is expanded on initialization (`default=False`).\n    \n*   `expand_button`: Whether there should be a button to toggle expansion; otherwise it is fixed to the initial `expand` value (`default=True`).\n    \n*   `expand_layout`: A layout type or instance to expand the plot into (`default=Column`).\n    \n\nLet us start with the default view, which provides a toggle button to expand the subobject as desired:\n\nviewer \\= ShapeViewer()\n\npn.Row(viewer.param, viewer.panel())\n\nAlternatively we can provide a completely separate `expand_layout` instance to the Param pane and request that it always remains expanded using the `expand` and `expand_button` option. This allows us to lay out the main widgets and the subobject’s widgets separately:\n\nviewer \\= ShapeViewer()\n\nexpand\\_layout \\= pn.Column()\n\npn.Row(\n    pn.Column(\n        pn.panel(viewer.param, expand\\_button\\=False, expand\\=True, expand\\_layout\\=expand\\_layout),\n        \"#### Subobject parameters:\",\n        expand\\_layout),\n    viewer.panel())\n\n* * *"
},
{
  "markdown": "## Declare parameter dependencies[#](#declare-parameter-dependencies \"Permalink to this heading\")\n\nThis guide addresses how to leverage `@param.depends` to express dependencies and trigger events based on UI interactions.\n\n* * *\n\nDeclaring parameters is usually only the beginning of a workflow. In most applications these parameters are then tied to some computation. To express the relationship between a computation and the parameters it depends on, the `param.depends` decorator may be used on Parameterized methods. This decorator provides a hint to Panel and other Param-based libraries (e.g. HoloViews) that the method should be re-evaluated when a parameter changes.\n\nAs a straightforward example without any additional dependencies we will write a small class that returns an ASCII representation of a sine wave, which depends on `phase` and `frequency` parameters. If we supply the `.view` method to a panel, it will automatically recompute and update the view when one or more of the parameters changes:\n\nimport panel as pn\nimport param\nimport numpy as np\n\npn.extension()\n\nclass Sine(param.Parameterized):\n\n    phase \\= param.Number(default\\=0, bounds\\=(0, np.pi))\n\n    frequency \\= param.Number(default\\=1, bounds\\=(0.1, 2))\n\n    @param.depends('phase', 'frequency')\n    def view(self):\n        y \\= np.sin(np.linspace(0, np.pi \\* 3, 40) \\* self.frequency + self.phase)\n        y \\= ((y \\- y.min()) / y.ptp()) \\* 20\n        array \\= np.array(\n            \\[list((' ' \\* (int(round(d)) \\- 1) + '\\*').ljust(20)) for d in y\\])\n        return pn.pane.Str('\\\\n'.join(\\[''.join(r) for r in array.T\\]), height\\=380, width\\=500)\n\nsine \\= Sine(name\\='ASCII Sine Wave')\n\npn.Row(sine.param, sine.view)\n\nThe parameterized and annotated `view` method could return any one of the types handled by the Pane objects Panel provides, making it easy to link parameters and their associated widgets to a plot or other output. Parameterized classes can therefore be a very useful pattern for encapsulating a part of a computational workflow with an associated visualization, declaratively expressing the dependencies between the parameters and the computation.\n\nBy default, a Param pane will show widgets for all parameters with a `precedence` value above the value `pn.Param.display_threshold`, so you can use `precedence` to automatically hide parameters that are not meant to have widgets. You can also explicitly choose which parameters should have widgets in a given pane, by passing a `parameters` argument. For example, this code gives a `phase` widget, while maintaining `sine.frequency` at the initial value of `1`:\n\npn.Row(pn.panel(sine.param, parameters\\=\\['phase'\\]), sine.view)\n\nAnother common pattern is linking the values of one parameter to another parameter, e.g. when dependencies between parameters exist. In the example below we will define two parameters, one for the continent and one for the country. Since we want the selection of valid countries to change when we change the continent, we define a method to do that for us. In order to link the two we express the dependency using the `param.depends` decorator and then ensure that we will run the method whenever the continent changes by setting `watch=True`.\n\nWe also define a `view` method that returns an HTML iframe displaying the country using Google Maps.\n\nclass GoogleMapViewer(param.Parameterized):\n\n    continent \\= param.ObjectSelector(default\\='Asia', objects\\=\\['Africa', 'Asia', 'Europe'\\])\n\n    country \\= param.ObjectSelector(default\\='China', objects\\=\\['China', 'Thailand', 'Japan'\\])\n\n    \\_countries \\= {'Africa': \\['Ghana', 'Togo', 'South Africa', 'Tanzania'\\],\n                  'Asia'  : \\['China', 'Thailand', 'Japan'\\],\n                  'Europe': \\['Austria', 'Bulgaria', 'Greece', 'Portugal', 'Switzerland'\\]}\n\n    @param.depends('continent', watch\\=True)\n    def \\_update\\_countries(self):\n        countries \\= self.\\_countries\\[self.continent\\]\n        self.param\\['country'\\].objects \\= countries\n        self.country \\= countries\\[0\\]\n\n    @param.depends('country')\n    def view(self):\n        iframe \\= \"\"\"\n        <iframe width=\"800\" height=\"400\" src=\"https://maps.google.com/maps?q={country}&z=6&output=embed\"\n        frameborder=\"0\" scrolling=\"no\" marginheight=\"0\" marginwidth=\"0\"></iframe>\n        \"\"\".format(country\\=self.country)\n        return pn.pane.HTML(iframe, height\\=400)\n\nviewer \\= GoogleMapViewer(name\\='Google Map Viewer')\npn.Row(viewer.param, viewer.view)\n\nWhenever the continent changes Param will now eagerly execute the `_update_countries` method to change the list of countries that is displayed, which in turn triggers an update in the view method updating the map. Note that there is no need to add `watch=True` to decorators of methods that are passed to a Panel layout (e.g. `viewer.View` being passed to `pn.Row` here), because Panel will already handle dependencies on those methods, executing the method automatically when the dependent parameters change. Indeed, if you specify `watch=True` for such a method, the method will get invoked _twice_ each time a dependency changes (once by Param internally and once by Panel), so you should reserve `watch=True` only for methods that aren’t otherwise being monitored for dependencies.\n\n* * *"
},
{
  "markdown": "## Register Session Callbacks[#](#register-session-callbacks \"Permalink to this heading\")\n\nThese How-to pages provide solutions for common tasks related to setting up callbacks on session related events (e.g. on page load or when a session is destroyed) and defining periodic tasks.\n\nUse Asynchronous Callbacks\n\nHow to leverage asynchronous callbacks to run I/O bound tasks in parallel.\n\nDefer Bound Functions Until Load\n\nHow to defer execution of bound and displayed functions until the application is loaded with `defer_load`.\n\nDefer Callbacks Until Load\n\nHow to set up callbacks to defer a task until the application is loaded with `pn.state.onload`.\n\nPeriodically Run Callbacks\n\nHow to set up per-session callbacks that run periodically.\n\nRun Tasks at Session Start or End\n\nHow to set up callbacks when a session is created and destroyed.\n\nSchedule Global Tasks\n\nHow to schedule tasks that run independently of any user visiting an application.\n\nModify Bokeh Models\n\nHow to safely modify Bokeh models to avoid running into issues with the Bokeh `Document` lock.\n\nConnection Notifications\n\nHow to add notifications when the application is ready and when it loses the server connection.\n\n## Examples[#](#examples \"Permalink to this heading\")\n\n![](https://assets.holoviz.org/panel/how_to/callbacks/streaming_bokeh.png)\n\nStreaming Bokeh\n\nUse `add_periodic_callback` to stream data to a Bokeh plot.\n\n![](https://assets.holoviz.org/panel/how_to/callbacks/streaming_indicator.png)\n\nStreaming Indicators\n\nUse `add_periodic_callback` to stream data to `Trend` indicators.\n\n![](https://assets.holoviz.org/panel/how_to/callbacks/streaming_perspective.png)\n\nStreaming Perspective\n\nUse `add_periodic_callback` to stream data to a `Perspective` pane.\n\n![](https://assets.holoviz.org/panel/how_to/callbacks/streaming_tabulator.png)\n\nStreaming Tabulator\n\nUse `add_periodic_callback` to stream data to a `Tabulator` widget."
},
{
  "markdown": "## Use Asynchronous Callbacks[#](#use-asynchronous-callbacks \"Permalink to this heading\")\n\nThis guide addresses how to leverage asynchronous callbacks to run I/O bound tasks in parallel.\n\nPrerequisites\n\n1.  Python has natively supported asynchronous functions since version 3.5, for a quick overview of some of the concepts involved see [the Python documentation](https://docs.python.org/3/library/asyncio-task.html).\n    \n\n* * *\n\n## `.param.watch`[#](#param-watch \"Permalink to this heading\")\n\nOne of the major benefits of leveraging async functions is that it is simple to write callbacks which will perform some longer running IO tasks in the background. Below we simulate this by creating a `Button` which will update some text when it starts and finishes running a long-running background task (here simulated using `asyncio.sleep`. If you are running this in the notebook you will note that you can start multiple tasks and it will update the text immediately but continue in the background:\n\nimport panel as pn\nimport asyncio\n\npn.extension()\n\nbutton \\= pn.widgets.Button(name\\='Click me!')\ntext \\= pn.widgets.StaticText()\n\nasync def run\\_async(event):\n    text.value \\= f'Running {event.new}'\n    await asyncio.sleep(2)\n    text.value \\= f'Finished {event.new}'\n\nbutton.on\\_click(run\\_async)\n\npn.Row(button, text)\n\nNote that `on_click` is simple one way of registering an asynchronous callback, but the more flexible `.param.watch` is also supported. Scheduling asynchronous periodic callbacks can be done with `pn.state.add_periodic_callback`.\n\nIt is important to note that asynchronous callbacks operate without locking the underlying Bokeh Document, which means Bokeh models cannot be safely modified by default. Usually this is not an issue because modifying Panel components appropriately schedules updates to underlying Bokeh models, however in cases where we want to modify a Bokeh model directly, e.g. when embedding and updating a Bokeh plot in a Panel application we explicitly have to decorate the asynchronous callback with `pn.io.with_lock`.\n\nimport numpy as np\nfrom bokeh.plotting import figure\nfrom bokeh.models import ColumnDataSource\n\nbutton \\= pn.widgets.Button(name\\='Click me!')\n\np \\= figure(width\\=500, height\\=300)\ncds \\= ColumnDataSource(data\\={'x': \\[0\\], 'y': \\[0\\]})\np.line(x\\='x', y\\='y', source\\=cds)\npane \\= pn.pane.Bokeh(p)\n\n@pn.io.with\\_lock\nasync def stream(event):\n    await asyncio.sleep(1)\n    x, y \\= cds.data\\['x'\\]\\[\\-1\\], cds.data\\['y'\\]\\[\\-1\\]\n    cds.stream({'x': list(range(x+1, x+6)), 'y': y+np.random.randn(5).cumsum()})\n    pane.param.trigger('object')\n\n\\# Equivalent to \\`.on\\_click\\` but shown\nbutton.param.watch(stream, 'clicks')\n\npn.Row(button, pane)\n\n## `pn.bind`[#](#pn-bind \"Permalink to this heading\")\n\nwidget \\= pn.widgets.IntSlider(start\\=0, end\\=10)\n\nasync def get\\_img(index):\n    url \\= f\"https://picsum.photos/800/300?image={index}\"\n    if pn.state.\\_is\\_pyodide:\n        from pyodide.http import pyfetch\n        return pn.pane.JPG(await (await pyfetch(url)).bytes())\n\n    import aiohttp\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as resp:\n            return pn.pane.JPG(await resp.read())\n\npn.Column(widget, pn.bind(get\\_img, widget))\n\nIn this example Panel will invoke the function and update the output when the function returns while leaving the process unblocked for the duration of the `aiohttp` request.\n\nThe equivalent can be written using `.param.watch` as:\n\nwidget \\= pn.widgets.IntSlider(start\\=0, end\\=10)\n\nimage \\= pn.pane.JPG()\n\nasync def update\\_img(event):\n    url \\= f\"https://picsum.photos/800/300?image={event.new}\"\n    if pn.state.\\_is\\_pyodide:\n        from pyodide.http import pyfetch\n        image.object \\= await (await pyfetch(url)).bytes()\n        return\n\n    import aiohttp\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as resp:\n            image.object \\= await resp.read()\n\nwidget.param.watch(update\\_img, 'value')\nwidget.param.trigger('value')\n\npn.Column(widget, image)\n\nIn this example Param will await the asynchronous function and the image will be updated when the request completes."
},
{
  "markdown": "This guide addresses how to defer long running, bound and displayed functions with `defer_load`. You can use this to improve the user experience of your app.\n\nIf you need to defer and orchestrate multiple, dependent tasks then check out the [Defer Long Running Tasks Guide](https://panel.holoviz.org/how_to/callbacks/load.html).\n\n* * *\n\n## Motivation[#](#motivation \"Permalink to this heading\")\n\nWhen a user opens your app, the app is _loaded_ as follows\n\n*   the app file is executed\n    \n*   the app template is sent to the user and rendered\n    \n*   a web socket connection is opened to enable fast, bi-directional communication as your interact with the app.\n    \n\nThus any long running code executed before the app is loaded will increase the the waiting time before your users see your apps template. **If the waiting time is more than 2-5 seconds your users might get confused and even leave the application behind**.\n\nHere is an example of an app that takes +5 seconds to load.\n\nimport time\nimport panel as pn\n\npn.extension(template\\=\"bootstrap\")\n\ndef some\\_long\\_running\\_task():\n    time.sleep(5)\n    return \"# Wow. That took some time. Are you still here?\"\n\npn.panel(some\\_long\\_running\\_task).servable()\n\n![panel-longrunning-task-example](https://assets.holoviz.org/panel/gifs/long_running_task.gif)\n\nNow lets learn how to defer long running tasks to after the application has loaded.\n\n## Defer all Tasks[#](#defer-all-tasks \"Permalink to this heading\")\n\nIts easy defer the execution of all bound and displayed functions with `pn.extension(..., defer_load=True)`.\n\nimport time\nimport panel as pn\n\npn.extension(defer\\_load\\=True, loading\\_indicator\\=True, template\\=\"bootstrap\")\n\ndef long\\_running\\_task():\n    time.sleep(3)\n    return \"# I'm deferred and shown after load\"\n\npn.Column(\"# I'm shown on load\", long\\_running\\_task).servable()\n\n![panel-defer-all-example](https://assets.holoviz.org/panel/gifs/defer_all_tasks.gif)\n\n## Defer Specific Tasks[#](#defer-specific-tasks \"Permalink to this heading\")\n\nIts also easy to defer the execution of specific, bound and displayed functions with `pn.panel(..., defer_load=True)`.\n\nimport time\nimport panel as pn\n\npn.extension(loading\\_indicator\\=True, template\\=\"bootstrap\")\n\ndef short\\_running\\_task():\n    return \"# I'm shown on load\"\n\ndef long\\_running\\_task():\n    time.sleep(3)\n    return \"# I'm deferred and shown after load\"\n\npn.Column(\n    short\\_running\\_task,\n    pn.panel(long\\_running\\_task, defer\\_load\\=True, min\\_height\\=50, min\\_width\\=200),\n).servable()\n\n![panel-defer-specific-example](https://assets.holoviz.org/panel/gifs/defer_specific_task.gif)\n\nNote\n\nIf you [enable threading](https://panel.holoviz.org/how_to/concurrency/threading.html) by setting `config.nthreads` or `--num-threads` on the commandline deferred callbacks will be executed concurrently on separate threads."
},
{
  "markdown": "This guide addresses how to defer and orchestrate long running background tasks with `pn.state.on_load`. You can use this to improve the user experience of your app.\n\n* * *\n\n## Motivation[#](#motivation \"Permalink to this heading\")\n\nWhen a user opens your app, the app is _loaded_ as follows\n\n*   the app file is executed\n    \n*   the app template is sent to the user and rendered\n    \n*   a web socket connection is opened to enable fast, bi-directional communication as your interact with the app.\n    \n\nThus any long running code executed before the app is loaded will increase the the waiting time before your users see your apps template. **If the waiting time is more than 2-5 seconds your users might get confused and even leave the application behind**.\n\nHere is an example of an app that takes +5 seconds to load.\n\nimport time\nimport panel as pn\n\npn.extension(template\\=\"bootstrap\")\n\nlayout \\= pn.pane.Markdown()\n\ndef some\\_long\\_running\\_task():\n    time.sleep(5) \\# Some long running task\n    layout.object \\= \"# Wow. That took some time. Are you still here?\"\n\nsome\\_long\\_running\\_task()\n\nlayout.servable()\n\n![panel-longrunning-task-example](https://assets.holoviz.org/panel/gifs/long_load.gif)\n\nNow lets learn how to defer long running tasks to after the application has loaded.\n\n## Defer a Task[#](#defer-a-task \"Permalink to this heading\")\n\nimport time\nimport panel as pn\n\npn.extension(template\\=\"bootstrap\")\n\nlayout \\= pn.pane.Markdown(\"# Loading...\")\n\ndef some\\_long\\_running\\_task():\n    time.sleep(5) \\# Some long running task\n    layout.object \\= \"# Done\"\n\npn.state.onload(some\\_long\\_running\\_task)\n\nlayout.servable()\n\n![panel-onload-example](https://assets.holoviz.org/panel/gifs/onload_callback.gif)\n\nNote that `pn.state.onload` accepts both _sync_ and _async_ functions and also accepts a `threaded` argument, which, when combined with [enabling `config.nthreads`](https://panel.holoviz.org/how_to/concurrency/threading.html) will run the callbacks concurrently on separate threads.\n\nThis example could also be implemented using a _bound and displayed function_. We recommend using that method together with `defer_load` when possible. See the [Defer Bound and Displayed Functions Guide](https://panel.holoviz.org/how_to/callbacks/defer_load.html).\n\n## Defer and Orchestrate Dependent Tasks[#](#defer-and-orchestrate-dependent-tasks \"Permalink to this heading\")\n\nSometimes you have multiple tasks that depend on each other and you need to _orchestrate_ them. To handle those scenarios you use `pn.state.onload` to defer background tasks and `pn.bind` to trigger _bound and displayed_ functions when the the background tasks have finished.\n\nLets take an example where we\n\n*   load a shared dataset.\n    \n*   display the dataset in a Table\n    \n*   transform the dataset and display it as a plot\n    \n\nimport time\nimport panel as pn\nimport pandas as pd\nimport param\nimport hvplot.pandas\n\npn.extension(sizing\\_mode\\=\"stretch\\_width\", template\\=\"bootstrap\", theme\\=\"dark\")\n\nclass AppState(param.Parameterized):\n    data \\= param.DataFrame()\n\n    def update(self):\n        time.sleep(2)\n        state.data \\= pd.DataFrame({\"x\": \\[1, 2, 3, 4\\], \"y\": \\[1, 3, 2, 4\\]})\n\ndef loading\\_indicator(label):\n    return pn.indicators.LoadingSpinner(\n        value\\=True, name\\=label, size\\=25, align\\=\"center\"\n    )\n\ndef short\\_running\\_task():\n    return \"# I'm shown on load\"\n\ndef table(data):\n    if data is None:\n        return loading\\_indicator(\"Loading data\")\n\n    return pn.pane.DataFrame(data)\n\ndef plot(data):\n    if data is None:\n        yield loading\\_indicator(\"Waiting for data\")\n        return\n\n    yield loading\\_indicator(\"Transforming data\")\n    time.sleep(2)  \\# Some long running transformation\n    yield data.hvplot()\n\nstate \\= AppState()\npn.state.onload(state.update)\n\npn.Column(\n    short\\_running\\_task,\n    pn.bind(table, data\\=state.param.data),\n    pn.bind(plot, data\\=state.param.data),\n).servable()\n\n![panel-onload-dependent-tasks-example](https://assets.holoviz.org/panel/gifs/onload_dependent.gif)"
},
{
  "markdown": "This guide addresses how to set up callbacks when a session is created and destroyed.\n\n* * *\n\nWhenever a request is made to an endpoint that is serving a Panel application a new session is created. If you have to perform some setup or tear down tasks on session creation (e.g. logging) you can define `on_session_created` and `on_session_destroyed` callbacks.\n\nNote\n\n`on_session_destroyed` callbacks can be registered globally or from within a session, while `on_session_created` callbacks can only be created globally.\n\n## pn.state.on\\_session\\_created[#](#pn-state-on-session-created \"Permalink to this heading\")\n\nA session creation callback can be registered globally using the `pn.state.on_session_created` method. When we are already in a session it is not possible to set up such a callback. This means that to set up session creation callbacks when using `panel serve` on the commandline you must provide a `--setup` script, that will run before the server is started. In the case of a dynamically started server using `pn.serve` you can set the callback up before starting the server.\n\nThe callback must accept a `BokehSessionContext` as the first and only argument:\n\ndef session\\_created(session\\_context: BokehSessionContext):\n    print(f'Created a session running at the {session\\_context.request.uri} endpoint')\n\npn.state.on\\_session\\_created(session\\_created)\n\n## pn.state.on\\_session\\_destroyed[#](#pn-state-on-session-destroyed \"Permalink to this heading\")\n\nIn many cases it is useful to define `on_session_destroyed` callbacks to perform any custom cleanup that is required, e.g. dispose a database engine, log out a user etc. This can also be done globally in the `--setup` script or before launching the server but you may also register a session destroyed callback for a particular session by setting it up from inside a session. The callback must have the same signature as session creation callbacks:\n\ndef session\\_destroyed(session\\_context):\n    ...\n\nand can be registered with `pn.state.on_session_destroyed(session_destroyed)`."
},
{
  "markdown": "## Periodically Run Callbacks[#](#periodically-run-callbacks \"Permalink to this heading\")\n\nThis guide addresses how to set up per-session callbacks that run periodically.\n\n* * *\n\nPeriodic callbacks allow periodically updating your application with new data. Below we will create a simple Bokeh plot and display it with Panel:\n\nimport numpy as np\nimport panel as pn\n\nfrom bokeh.models import ColumnDataSource\nfrom bokeh.plotting import figure\n\npn.extension()\n\nsource \\= ColumnDataSource({\"x\": np.arange(10), \"y\": np.arange(10)})\np \\= figure()\np.line(x\\=\"x\", y\\=\"y\", source\\=source)\n\nbokeh\\_pane \\= pn.pane.Bokeh(p)\nbokeh\\_pane.servable()\n\nNow we will define a callback that updates the data on the `ColumnDataSource` and use the `pn.state.add_periodic_callback` method to schedule updates every 200 ms. We will also set a timeout of 5 seconds after which the callback will automatically stop.\n\nWarning\n\nThe dynamic callbacks may not function properly in the online documentation. Please use them in a notebook or script.\n\ndef update():\n    data \\= np.random.randint(0, 2 \\*\\* 31, 10)\n    source.data.update({\"y\": data})\n    bokeh\\_pane.param.trigger('object') \\# Only needed in notebook\n\ncb \\= pn.state.add\\_periodic\\_callback(update, 200, timeout\\=5000)\n\nIn a notebook or bokeh server context we should now see the plot update periodically. The other nice thing about this is that `pn.state.add_periodic_callback` returns `PeriodicCallback` we can call `.stop()` and `.start()` on if we want to stop or pause the periodic execution. Additionally we can also dynamically adjust the period by setting the `timeout` parameter to speed up or slow down the callback.\n\nOther nice features on a periodic callback are the ability to check the number of executions using the `cb.counter` property and the ability to toggle the callback on and off simply by setting the `running` parameter. This makes it possible to link a widget to the running state:\n\ntoggle \\= pn.widgets.Toggle(name\\='Toggle callback', value\\=True)\n\ntoggle.link(cb, bidirectional\\=True, value\\='running')\ntoggle\n\nNote that when starting a server dynamically with `pn.serve` you cannot start a periodic callback before the application is actually being served. Therefore you should create the application and start the callback in a wrapping function:\n\nfrom functools import partial\n\nimport numpy as np\nimport panel as pn\n\nfrom bokeh.models import ColumnDataSource\nfrom bokeh.plotting import figure\n\ndef update(source):\n    data \\= np.random.randint(0, 2 \\*\\* 31, 10)\n    source.data.update({\"y\": data})\n\ndef panel\\_app():\n    source \\= ColumnDataSource({\"x\": np.arange(10), \"y\": np.arange(10)})\n    p \\= figure()\n    p.line(x\\=\"x\", y\\=\"y\", source\\=source)\n    cb \\= pn.state.add\\_periodic\\_callback(partial(update, source), 200, timeout\\=5000)\n    toggle \\= pn.widgets.Toggle(name\\='Toggle callback', value\\=True)\n    toggle.link(cb, bidirectional\\=True, value\\='running')\n    return pn.Column(pn.pane.Bokeh(p), toggle)\n\npn.serve(panel\\_app)"
},
{
  "markdown": "## Modify Bokeh Models[#](#modify-bokeh-models \"Permalink to this heading\")\n\nThis guide addresses how to safely modify Bokeh models to avoid running into issues with the Bokeh `Document` lock.\n\n* * *\n\nThe Bokeh server that Panel builds on is designed to be thread safe which requires a set of locks to avoid multiple threads modifying the Bokeh models simultaneously. Panel being a high-level wrapper around Bokeh handles this locking for you. However, when you update Bokeh components directly you may need to schedule a callback to get around Bokeh’s document lock to avoid errors like this:\n\nRuntimeError: \\_pending\\_writes should be non\\-None when we have a document lock, and we should have the lock when the document changes\n\nIn the example below we will launch an application on a thread using `pn.serve` and make the Bokeh plot (in practice you may provide handles to this object on a class). To schedule a callback which updates the `y_range` by using the `pn.state.execute` method. This pattern will ensure that the update to the Bokeh model is executed on the correct thread:\n\nimport time\nimport panel as pn\n\nfrom bokeh.plotting import figure\n\ndef app():\n    p \\= figure()\n    p.line(\\[1, 2, 3\\], \\[1, 2, 3\\])\n    return p\n\npn.serve(app, threaded\\=True)\n\npn.state.execute(lambda: p.y\\_range.update(start\\=0, end\\=4))"
},
{
  "markdown": "## Schedule Global Tasks[#](#schedule-global-tasks \"Permalink to this heading\")\n\nThis guide addresses how to schedule tasks that run independently of any user visiting an application.\n\n* * *\n\nThe `pn.state.schedule_task` functionality allows scheduling global tasks at certain times or on a specific schedule. This is distinct from [periodic callbacks](https://panel.holoviz.org/how_to/callbacks/periodic.html), which are scheduled per user session. Global tasks are useful for performing periodic actions like updating cached data, performing cleanup actions or other housekeeping tasks, while periodic callbacks should be reserved for making periodic updates to an application.\n\nThe different contexts in which global tasks and periodic callbacks run also has implications on how they should be scheduled. Scheduled task **must not** be declared in the application code itself, i.e. if you are serving `panel serve app.py` the callback you are scheduling must not be declared in the `app.py`. It must be defined in an external module or in a separate script declared as part of the `panel serve` invocation using the `--setup` commandline argument.\n\nScheduling using `pn.state.schedule_task` is idempotent, i.e. if a callback has already been scheduled under the same name subsequent calls will have no effect. By default the starting time is immediate but may be overridden with the `at` keyword argument. The period may be declared using the `period` argument or a cron expression (which requires the `croniter` library). Note that the `at` time should be in local time but if a callable is provided it must return a UTC time. If `croniter` is installed a `cron` expression can be provided using the `cron` argument.\n\nHere is a simple example of a task scheduled at a fixed interval:\n\nimport panel as pn\nimport datetime as dt\nimport asyncio\n\nasync def task():\n    print(f'Task executed at: {dt.datetime.now()}')\n\npn.state.schedule\\_task('task', task, period\\='1s')\nawait asyncio.sleep(3)\n\npn.state.cancel\\_task('task')\n\nNote that while both `async` and regular callbacks are supported, asynchronous callbacks are preferred if you are performing any I/O operations to avoid interfering with any running applications.\n\nIf you have the `croniter` library installed you may also provide a cron expression, e.g. the following will schedule a task to be repeated at 4:02 am every Monday and Friday:\n\npn.state.schedule\\_task('task', task, cron\\='2 4 \\* \\* mon,fri')"
},
{
  "markdown": "## Access Session State[#](#access-session-state \"Permalink to this heading\")\n\nWhenever a Panel application is being served the `panel.state` object will provide a variety of information about the current user session. This includes the HTTP request that initiated the session, information about the browser and the current URL, and more. These How-to pages provide solutions for common tasks for managing the session state.\n\nAccess and Manipulate the URL\n\nHow to access and manipulate the URL.\n\nAccess HTTP Request State\n\nHow to access information about the HTTP request associated with a session.\n\nAccess the Busyness State\n\nHow to access the busy state.\n\n## Examples[#](#examples \"Permalink to this heading\")\n\n![](https://assets.holoviz.org/panel/how_to/state/sync_url.png)\n\nSync Widgets and URL\n\nSync the widget state with the URL to allow deep linking your application state using `pn.state.location`."
},
{
  "markdown": "This guide addresses how to access and manipulate the URL.\n\nThis powerful technique enables you to save the state of your app via the url. You can bookmark the URL or share the URL with friends or colleagues to open the app in the exact same state later.\n\n## Access[#](#access \"Permalink to this heading\")\n\nWhen starting a server session Panel will attach a `Location` component which can be accessed using `pn.state.location`. The `Location` component serves a number of functions:\n\n*   Navigation between pages via `pathname`\n    \n*   Sharing (parts of) the page state in the url as `search` parameters for bookmarking and sharing.\n    \n*   Navigating to subsections of the page via the `hash_` parameter.\n    \n\n### Core[#](#core \"Permalink to this heading\")\n\n*   **`pathname`** (string): pathname part of the url, e.g. ‘/how\\_to/layout/spacing.html’.\n    \n*   **`search`** (string): search part of the url e.g. ‘?color=blue’.\n    \n*   **`hash_`** (string): hash part of the url e.g. ‘#margin-parameter’.\n    \n*   **`reload`** (bool): Whether or not to reload the page when the url is updated.\n    \n    *   For independent apps this should be set to True.\n        \n    *   For integrated or single page apps this should be set to False.\n        \n\n### Readonly[#](#readonly \"Permalink to this heading\")\n\n*   **`href`** (string): The full url, e.g. ‘https://panel.holoviz.org:443/how\\_to/layout/spacing.html?color=blue#margin-parameter’.\n    \n*   **`protocol`** (string): protocol part of the url, e.g. ‘http:’ or ‘https:’\n    \n*   **`port`** (string): port number, e.g. ‘80’\n    \n\nNote\n\nIn a notebook environment `pn.state.location` is not initialized until the first plot has been displayed\n\n## Manipulate[#](#manipulate \"Permalink to this heading\")\n\nBy default the current [query parameters](https://en.wikipedia.org/wiki/Query_string) in the URL (specified as a URL suffix such as `?color=blue`) are made available on `pn.state.location.query_params`.\n\n## Sync and Unsync[#](#sync-and-unsync \"Permalink to this heading\")\n\nTo make working with query parameters straightforward the `Location` object provides a `sync` method which allows syncing query parameters with the parameters on a `Parameterized` object.\n\nWe will start by defining a `Parameterized` class:\n\nimport panel as pn\nimport param\n\nclass Settings(param.Parameterized):\n    integer \\= param.Integer(default\\=1, bounds\\=(0, 10))\n    string \\= param.String(default\\='A string')\n\n    dont\\_sync \\= param.String(default\\='A string')\n\nNow we will use the `pn.state.location` object to sync it with the URL query string. The sync method takes the **`Parameterized` class or instance** to sync with as the first argument and a list or dictionary of the parameters as the second argument. If a dictionary is provided it should map from the Parameterized object’s parameters to the query parameter name in the URL:\n\nsettings \\= Settings()\n\npn.state.location.sync(settings, {'integer': 'int', 'string': 'str'})\n\nNow the Parameterized object is bi-directionally linked to the URL query parameter.\n\nLets try to serve it as an app\n\npn.Param(settings).servable()\n\n Your browser does not support the video tag.\n\nNote to _unsync_ the Parameterized object you can simply call `pn.state.location.unsync(query_example)`."
},
{
  "markdown": "## Access HTTP Request State[#](#access-http-request-state \"Permalink to this heading\")\n\nThis guide addresses how to access information about the HTTP request associated with a session.\n\n* * *\n\nThe `panel.state` object holds a wide range of information about the HTTP request that is associated with a running session. Note that if you are running Panel inside a notebook session these attributes will simply return `None`.\n\n## Request arguments[#](#request-arguments \"Permalink to this heading\")\n\nThe request arguments are made available to be accessed on `pn.state.session_args`. For example if your application is hosted at `localhost:8001/app`, appending `?phase=0.5` to the URL will allow you to access the phase variable using the following code:\n\ntry:\n    phase \\= int(pn.state.session\\_args.get('phase')\\[0\\])\nexcept Exception:\n    phase \\= 1\n\nThis mechanism may be used to modify the behavior of an app depending on parameters provided in the URL.\n\n## Cookies[#](#cookies \"Permalink to this heading\")\n\nThe `panel.state.cookies` will allow accessing the cookies stored in the browser and on the bokeh server."
},
{
  "markdown": "## Access Busyness state[#](#access-busyness-state \"Permalink to this heading\")\n\nThis guide addresses how to access the busy state.\n\n* * *\n\nOften an application will have longer running callbacks which are being processed on the server, to give users some indication that the server is busy you may therefore have some way of indicating that busy state. The `pn.state.busy` parameter indicates whether a callback is being actively processed and may be linked to some visual indicator.\n\nBelow we will create a little application to demonstrate this, we will create a button which executes some longer running task on click and then create an indicator function that displays `'I'm busy'` when the `pn.state.busy` parameter is `True` and `'I'm idle'` when it is not:\n\nimport time\nimport panel as pn\npn.extension() \\# for notebook\n\ndef processing(event):\n    \\# Some longer running task\n    time.sleep(1)\n\nbutton \\= pn.widgets.Button(name\\='Click me!')\nbutton.on\\_click(processing)\n\ndef indicator(busy):\n    return \"I'm busy\" if busy else \"I'm idle\"\n\npn.Row(button, pn.bind(indicator, pn.state.param.busy)).servable()\n\nThis way we can create a global indicator for the busy state instead of modifying all our callbacks.\n\n## Relate Resources[#](#relate-resources \"Permalink to this heading\")"
},
{
  "markdown": "## How-to[#](#how-to \"Permalink to this heading\")\n\nThe Panel How-to guides provide step by step recipes for solving essential problems and tasks that arise during your work. They assume that you’ve completed the Getting Started material and therefore already have some knowledge of how Panel works. There is no order to the guides, other than any potential prerequisites listed at the top of a page. Jump to the topic that is relevant to you now.\n\n## Prepare to develop[#](#prepare-to-develop \"Permalink to this heading\")\n\nDevelop in a notebook\n\nHow to effectively develop apps in a notebook environment.\n\nDevelop in an editor\n\nHow to effectively develop apps in a Python or Markdown file.\n\n## Build apps[#](#build-apps \"Permalink to this heading\")\n\nConstruct components\n\nHow to construct and customize individual components like an image or slider widget.\n\nArrange Components\n\nHow to arrange and size components on the page.\n\nStyle components\n\nHow to apply designs, themes and custom styling to components to achieve a polished look and feel.\n\nAdd interactivity\n\nHow to link add interactivity to your applications using reactive APIs.\n\nApply templates\n\nHow to use a Template to customize the look and feel of a deployed Panel app.\n\n## Use specialized UIs and APIs[#](#use-specialized-uis-and-apis \"Permalink to this heading\")\n\nBuild a sequential UI\n\nHow to build a Panel Pipeline that connects multiple panels into a sequential user interface.\n\nBuild custom components\n\nHow to extend Panel by building custom components.\n\nGenerate UIs from declared parameters (`Declarative API`)\n\nHow to use Parameterized classes with Panel to generate UIs without writing GUI code.\n\nExplicitly link parameters (`Callbacks API`)\n\nHow to link the parameters of Panel components in Python and Javascript.\n\n## Manage session tasks[#](#manage-session-tasks \"Permalink to this heading\")\n\nRegister session callbacks\n\nHow to set up callbacks on session related events (e.g. on page load or when a session is destroyed) and define periodic tasks.\n\nAccess session state\n\nHow to access and manipulate state related to the user session, HTTP request and URL arguments.\n\n## Test and debug[#](#test-and-debug \"Permalink to this heading\")\n\nEnable profiling and debugging\n\nHow to profile and debug your application using the admin dashboard and other tools.\n\nSet up testing for an application\n\nHow to set up unit tests, UI tests and load testing to ensure your applications are (and stay) robust and scalable.\n\n## Share your work[#](#share-your-work \"Permalink to this heading\")\n\nConfigure the server\n\nHow to configure the Panel server.\n\nIntegrate with other servers\n\nHow to integrate Panel in other application based on Flask, FastAPI or Django.\n\nDeploy applications\n\nHow to deploy Panel applications to various cloud providers (e.g. Azure, GCP, AWS etc.)\n\nExport apps\n\nHow to export and save Panel applications as static files.\n\nRun panel in WebAssembly\n\nHow to run Panel applications entirely in the browser using WebAssembly (Wasm), Pyodide, and PyScript.\n\n## Migrate to Panel[#](#migrate-to-panel \"Permalink to this heading\")\n\nMigrate from Streamlit\n\n[![https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)\n\nHow to migrate existing Streamlit applications to Panel."
},
{
  "markdown": "## Enable Profiling and Debugging[#](#enable-profiling-and-debugging \"Permalink to this heading\")\n\nWhen trying to understand the performance profiles or track down issues with an application the server logs are rarely sufficient to gain insights. For that reason Panel ships with an admin dashboard that allows tracking resource usage, user behavior, and provides ways of visualizing profiling output to discover bottlenecks in an application.\n\nEnable the admin panel\n\nHow to enable the admin Panel to begin monitoring resource usage and user behavior.\n\nProfile your application\n\nHow to enable profilers like snakeviz or memray to track down bottlenecks in your application.\n\nView application logs\n\nHow to view application logs in the admin dashboard."
},
{
  "markdown": "## Enable the admin panel[#](#enable-the-admin-panel \"Permalink to this heading\")\n\nThis guide addresses how to enable the admin Panel to begin monitoring resource usage and user behavior.\n\n* * *\n\nThe `/admin` panel provides an overview of the current application and provides tools for debugging and profiling. It can be enabled by passing the `--admin` argument to the `panel serve` command.\n\npanel serve my-app.py \\--admin\n\nWhen you have successfully enabled it you should be able to visit the `/admin` endpoint of your application, e.g. if you are serving locally on port 5006, visit `http://localhost:5006/admin`. You should now be greeted with the overview page, which provides some details about currently active sessions, running versions and resource usage (if `psutil` is installed):\n\n![](https://panel.holoviz.org/_static/images/admin_overview.png)\n\n## Changing the admin panel endpoint[#](#changing-the-admin-panel-endpoint \"Permalink to this heading\")\n\nYou can change the endpoint that the admin page is rendered at by using the flag `--admin-endpoint=\"/my-new-admin-endpoint\"`. This will change where the admin endpoint is in the Bokeh server, and cause a `404: Not Found` page to be shown if you navigate to the default `/admin` path discussed above. As an example, using the following command to start your Panel app\n\npanel serve my-app.py \\--admin \\--admin-endpoint\\=\"/my-new-admin-endpoint\"\n\nand navigating to [http://localhost:5006/admin](http://localhost:5006/admin) will result in a 404 page, however, navigating to [http://localhost:5006/my-new-admin-endpoint](http://localhost:5006/my-new-admin-endpoint) will result in the admin panel."
},
{
  "markdown": "## Profile your Application[#](#profile-your-application \"Permalink to this heading\")\n\nThis guide addresses how to enable profilers like snakeviz or memray to track down bottlenecks in your application in terms of execution time and memory usage.\n\n* * *\n\n## Launch profiling[#](#launch-profiling \"Permalink to this heading\")\n\nThe launch profiler profiles the execution time of the initialization of a particular application. It can be enabled by setting a profiler using the commandline `--profiler` option to `panel serve`. Available profilers include:\n\n*   [`pyinstrument`](https://pyinstrument.readthedocs.io/): A statistical profiler with nice visual output\n    \n*   [`snakeviz`](https://jiffyclub.github.io/snakeviz/): SnakeViz is a browser based graphical viewer for the output of Python’s cProfile module and an alternative to using the standard library pstats module.\n    \n*   [`memray`](https://bloomberg.github.io/memray/): memray is a memory profiler for Python. It can track memory allocations in Python code, in native extension modules, and in the Python interpreter itself.\n    \n\nOnce enabled the launch profiler will profile each application separately and provide the profiler output generated by the selected profiling engine.\n\n![](https://panel.holoviz.org/_static/images/launch_profiler.png)\n\n## User profiling[#](#user-profiling \"Permalink to this heading\")\n\nIn addition to profiling the launch step of an application it is often also important to get insight into the interactive performance of an application. For that reason Panel also provides the `pn.io.profile` decorator that can be added to any callback and will report the profiling results in the `/admin` panel. The `profile` helper takes to arguments, the name to record the profiling results under and the profiling `engine` to use.\n\n@pn.io.profile('clustering', engine\\='snakeviz')\ndef get\\_clustering(event):\n    \\# some expensive calculation\n    ...\n\nwidget.param.watch(my\\_callback, 'value')\n\n![](https://panel.holoviz.org/_static/images/user_profiling.png)\n\nThe user profiling may also be used in an interactive session, e.g. we might decorate a simple callback with the `profile` decorator:\n\nimport time\n\nslider \\= pn.widgets.FloatSlider(name\\='Test')\n\n@pn.io.profile('formatting')\ndef format\\_value(value):\n    time.sleep(1)\n    return f'Value: {value+1}'\n\npn.Row(slider, pn.bind(format\\_value, slider))\n\nThen we can request the named profile ‘formatting’ using the `pn.state.get_profile` function:\n\npn.state.get\\_profile('formatting')"
},
{
  "markdown": "## View application logs[#](#view-application-logs \"Permalink to this heading\")\n\nThis guide addresses how to view application logs in the admin dashboard.\n\n* * *\n\nThe logs page provides a detailed breakdown of the user interaction with the application. The log level of the logs stream sent to the Logs console can be set with the `PANEL_ADMIN_LOG_LEVEL` environment variable or with the `--admin-log-level` command line parameter, both accepting either `'debug'` (default), `'info'`, `'warning'`, `'error'` or `'critical'`. Additionally users may also log to this logger using the `pn.state.log` function, e.g. in this example we log the arguments to the clustering function:\n\ndef get\\_clusters(x, y, n\\_clusters):\n    pn.state.log(f'clustering {x!r} vs {y!r} into {n\\_clusters} clusters.')\n    ...\n    return ...\n\n![](https://panel.holoviz.org/_static/images/admin_logs.png)"
},
{
  "markdown": "## Configuring a Panel server[#](#configuring-a-panel-server \"Permalink to this heading\")\n\nThe Panel server can be launched either from the commandline (using `panel serve`) or programmatically (using `panel.serve()`). In this guide we will discover how to run and configure server instances using these two options.\n\n## The server[#](#the-server \"Permalink to this heading\")\n\nThe Bokeh server is built on Tornado, which handles all of the communication between the browser and the backend. Whenever a user accesses the app or dashboard in a browser a new session is created which executes the app code and creates a new `Document` containing the models served to the browser where they are rendered by BokehJS.\n\n![](https://bokeh.pydata.org/en/latest/_images/bokeh_serve.svg)\n\nIf you do not want to maintain your own web server and/or set up complex reverse proxies various cloud providers make it relatively simple to quickly deploy arbitrary apps on their system. See the [deployment how-to guides](https://panel.holoviz.org/how_to/deployment/index.html) for more details.\n\nLaunch from the commandline\n\nDiscover how to launch and configure a Panel application from the commandline.\n\nLaunch programmatically\n\nDiscover how to launch and configure a Panel application programmatically.\n\nServing multiple applications\n\nDiscover how-to launch and configure multiple applications on the same server.\n\nSetting up a (reverse) proxy\n\nDiscover how-to configure a reverse proxy to scale your deployment.\n\nAccess via SSH\n\nDiscover how to access a Panel deployment running remotely via SSH.\n\nServing static files\n\nDiscover how to serve static files alongside your Panel application(s)."
},
{
  "markdown": "Once the app is ready for deployment it can be served using the Bokeh server. For a detailed breakdown of the design and functionality of Bokeh server, see the [Bokeh documentation](https://bokeh.pydata.org/en/latest/docs/user_guide/server.html). The most important thing to know is that Panel (and Bokeh) provide a CLI command to serve a Python script, app directory, or Jupyter notebook containing a Bokeh or Panel app. To launch a server using the CLI, simply run:\n\nAlternatively you can also list multiple apps:\n\npanel serve app1.py app2.ipynb\n\nor even serve a number of apps at once:\n\nFor development it can be particularly helpful to use the `--autoreload` option to `panel serve` as that will automatically reload the page whenever the application code or any of its imports change.\n\nThe `panel serve` command has the following options:\n\npositional arguments:\n  DIRECTORY-OR-SCRIPT   The app directories or scripts to serve (serve empty document if not specified)\n\noptions:\n  -h, --help            show this help message and exit\n  --port PORT           Port to listen on\n  --address ADDRESS     Address to listen on\n  --unix-socket UNIX-SOCKET\n                        Unix socket to bind. Network options such as port, address, ssl options are incompatible with unix socket\n  --log-level LOG-LEVEL\n                        One of: trace, debug, info, warning, error or critical\n  --log-format LOG-FORMAT\n                        A standard Python logging format string (default: '%(asctime)s %(message)s')\n  --log-file LOG-FILE   A filename to write logs to, or None to write to the standard stream (default: None)\n  --use-config CONFIG   Use a YAML config file for settings\n  --args ...            Command line arguments remaining to passed on to the application handler. NOTE: if this argument precedes DIRECTORY-OR-SCRIPT then some other argument, e.g. --show, must be placed before the directory or script.\n  --dev \\[FILES-TO-WATCH ...\\]\n                        Enable live reloading during app development. By default it watches all \\*.py \\*.html \\*.css \\*.yaml files in the app directory tree. Additional files can be passed as arguments. NOTE: if this argument precedes DIRECTORY-OR-SCRIPT then some other argument, e.g\n                        --show, must be placed before the directory or script. NOTE: This setting only works with a single app. It also restricts the number of processes to 1. NOTE FOR WINDOWS USERS : this option must be invoked using 'python -m bokeh'. If not Tornado will fail to\n                        restart the server\n  --show                Open server app(s) in a browser\n  --allow-websocket-origin HOST\\[:PORT\\]\n                        Public hostnames which may connect to the Bokeh websocket With unix socket, the websocket origin restrictions should be enforced by the proxy.\n  --prefix PREFIX       URL prefix for Bokeh server URLs\n  --ico-path ICO\\_PATH   Path to a .ico file to use as the favicon.ico, or 'none' to disable favicon.ico support. If unset, a default Bokeh .ico file will be used\n  --keep-alive MILLISECONDS\n                        How often to send a keep-alive ping to clients, 0 to disable.\n  --check-unused-sessions MILLISECONDS\n                        How often to check for unused sessions\n  --unused-session-lifetime MILLISECONDS\n                        How long unused sessions last\n  --stats-log-frequency MILLISECONDS\n                        How often to log stats\n  --mem-log-frequency MILLISECONDS\n                        How often to log memory usage information\n  --use-xheaders        Prefer X-headers for IP/protocol information\n  --ssl-certfile CERTFILE\n                        Absolute path to a certificate file for SSL termination\n  --ssl-keyfile KEYFILE\n                        Absolute path to a private key file for SSL termination\n  --session-ids MODE    One of: unsigned, signed or external-signed\n  --auth-module AUTH\\_MODULE\n                        Absolute path to a Python module that implements auth hooks\n  --enable-xsrf-cookies\n                        Whether to enable Tornado support for XSRF cookies. All PUT, POST, or DELETE handlers must be properly instrumented when this setting is enabled.\n  --exclude-headers EXCLUDE\\_HEADERS \\[EXCLUDE\\_HEADERS ...\\]\n                        A list of request headers to exclude from the session context (by default all headers are included).\n  --exclude-cookies EXCLUDE\\_COOKIES \\[EXCLUDE\\_COOKIES ...\\]\n                        A list of request cookies to exclude from the session context (by default all cookies are included).\n  --include-headers INCLUDE\\_HEADERS \\[INCLUDE\\_HEADERS ...\\]\n                        A list of request headers to make available in the session context (by default all headers are included).\n  --include-cookies INCLUDE\\_COOKIES \\[INCLUDE\\_COOKIES ...\\]\n                        A list of request cookies to make available in the session context (by default all cookies are included).\n  --cookie-secret COOKIE\\_SECRET\n                        Configure to enable getting/setting secure cookies\n  --index INDEX         Path to a template to use for the site index\n  --disable-index       Do not use the default index on the root path\n  --disable-index-redirect\n                        Do not redirect to running app from root path\n  --num-procs N         Number of worker processes for an app. Using 0 will autodetect number of cores (defaults to 1)\n  --session-token-expiration N\n                        Duration in seconds that a new session token is valid for session creation. After the expiry time has elapsed, the token will not be able create a new session (defaults to seconds).\n  --websocket-max-message-size BYTES\n                        Set the Tornado websocket\\_max\\_message\\_size value (default: 20MB)\n  --websocket-compression-level LEVEL\n                        Set the Tornado WebSocket compression\\_level\n  --websocket-compression-mem-level LEVEL\n                        Set the Tornado WebSocket compression mem\\_level\n  --glob                Process all filename arguments as globs\n  --static-dirs KEY=VALUE \\[KEY=VALUE ...\\]\n                        Static directories to serve specified as key=value pairs mapping from URL route to static file directory.\n  --basic-auth BASIC\\_AUTH\n                        Password or filepath to use with Basic Authentication.\n  --oauth-provider OAUTH\\_PROVIDER\n                        The OAuth2 provider to use.\n  --oauth-key OAUTH\\_KEY\n                        The OAuth2 key to use\n  --oauth-secret OAUTH\\_SECRET\n                        The OAuth2 secret to use\n  --oauth-redirect-uri OAUTH\\_REDIRECT\\_URI\n                        The OAuth2 redirect URI\n  --oauth-extra-params OAUTH\\_EXTRA\\_PARAMS\n                        Additional parameters to use.\n  --oauth-jwt-user OAUTH\\_JWT\\_USER\n                        The key in the ID JWT token to consider the user.\n  --oauth-encryption-key OAUTH\\_ENCRYPTION\\_KEY\n                        A random string used to encode the user information.\n  --oauth-error-template OAUTH\\_ERROR\\_TEMPLATE\n                        A random string used to encode the user information.\n  --oauth-expiry-days OAUTH\\_EXPIRY\\_DAYS\n                        Expiry off the OAuth cookie in number of days.\n  --oauth-refresh-tokens OAUTH\\_REFRESH\\_TOKENS\n                        Whether to automatically refresh OAuth access tokens when they expire.\n  --auth-template AUTH\\_TEMPLATE\n                        Template to serve when user is unauthenticated.\n  --basic-login-template BASIC\\_LOGIN\\_TEMPLATE\n                        Template to serve for Basic Authentication login page.\n  --rest-provider REST\\_PROVIDER\n                        The interface to use to serve REST API\n  --rest-endpoint REST\\_ENDPOINT\n                        Endpoint to store REST API on.\n  --rest-session-info   Whether to serve session info on the REST API\n  --session-history SESSION\\_HISTORY\n                        The length of the session history to record.\n  --warm                Whether to execute scripts on startup to warm up the server.\n  --admin               Whether to add an admin panel.\n  --admin-log-level {debug,info,warning,error,critical}\n                        One of: debug (default), info, warning, error or critical\n  --profiler PROFILER   The profiler to use by default, e.g. pyinstrument, snakeviz or memray.\n  --autoreload          Whether to autoreload source when script changes.\n  --num-threads NUM\\_THREADS\n                        Whether to start a thread pool which events are dispatched to.\n  --setup SETUP         Path to a setup script to run before server starts.\n  --liveness            Whether to add a liveness endpoint.\n  --liveness-endpoint LIVENESS\\_ENDPOINT\n                        The endpoint for the liveness API.\n  --reuse-sessions      Whether to reuse sessions when serving the initial request.\n  --global-loading-spinner\n                        Whether to add a global loading spinner to the application(s).\n\nTo turn a notebook into a deployable app simply append `.servable()` to one or more Panel objects, which will add the app to Bokeh’s `curdoc`, ensuring it can be discovered by Bokeh server on deployment. In this way it is trivial to build dashboards that can be used interactively in a notebook and then seamlessly deployed on Bokeh server.\n\nWhen called on a notebook, `panel serve` first converts it to a python script using [`nbconvert.PythonExporter()`](https://nbconvert.readthedocs.io/en/stable/api/exporters.html), albeit with [IPython magics](https://ipython.readthedocs.io/en/stable/interactive/magics.html) stripped out. This means that non-code cells, such as raw cells, are entirely handled by `nbconvert` and [may modify the served app](https://nbsphinx.readthedocs.io/en/latest/raw-cells.html)."
},
{
  "markdown": "Test functionality and performance\n\nHow to add unit and performance testing with Pytest.\n\nTest UI rendering\n\nThis guide addresses how to test the rendered UI with Pytest and Playwright.\n\nTest operating capacity\n\nHow to test performance by simulating multiple users accessing an app concurrently."
},
{
  "markdown": "## Test functionality and performance[#](#test-functionality-and-performance \"Permalink to this heading\")\n\nThis guide addresses how to use unit and performance testing on a Panel app with Pytest.\n\n* * *\n\nTesting is key to developing robust and performant applications. You can test Panel data apps using familiar Python testing tools.\n\n[Pytest](https://docs.pytest.org/en/latest/) is the most common Python testing framework. We will use it below to write unit and performance tests. Before we get started, you should\n\npip install panel pytest pytest-benchmark\n\n## Create the app[#](#create-the-app \"Permalink to this heading\")\n\nLet’s create a simple data app for testing. The app sleeps 0.5 seconds (default) when loaded and when the button is clicked.\n\n![app.py](https://assets.holoviz.org/panel/gifs/pytest.gif)\n\nCreate the file `app.py` and add the code below (don’t worry about the contents of the app for now):\n\napp.py\n\nimport time\n\nimport panel as pn\nimport param\n\nclass App(pn.viewable.Viewer):\n    run \\= param.Event(doc\\=\"Runs for click\\_delay seconds when clicked\")\n    runs \\= param.Integer(doc\\=\"The number of runs\")\n    status \\= param.String(default\\=\"No runs yet\")\n\n    load\\_delay \\= param.Number(default\\=0.5)\n    run\\_delay \\= param.Number(default\\=0.5)\n\n    def \\_\\_init\\_\\_(self, \\*\\*params):\n        super().\\_\\_init\\_\\_(\\*\\*params)\n\n        result \\= self.\\_load()\n        self.\\_time \\= time.time()\n\n        self.\\_status\\_pane \\= pn.pane.Markdown(self.status, height\\=40, align\\=\"start\", margin\\=(0,5,10,5))\n        self.\\_result\\_pane \\= pn.Column(result)\n\n        button \\= pn.widgets.Button.from\\_param(self.param.run, sizing\\_mode\\=\"fixed\")\n        self.\\_view \\= pn.Column(\n            pn.Row(button, self.\\_status\\_pane),\n            self.\\_result\\_pane\n        )\n\n    def \\_\\_panel\\_\\_(self):\n        return self.\\_view\n\n    def \\_start\\_run(self):\n        self.status \\= f\"Running ...\"\n        self.\\_time \\= time.time()\n\n    def \\_stop\\_run(self):\n        now \\= time.time()\n        duration \\= round(now\\-self.\\_time,3)\n        self.\\_time \\= now\n        self.runs += 1\n        self.status \\= f\"Finished run {self.runs} in {duration}sec\"\n\n    @param.depends(\"run\", watch\\=True)\n    def \\_run\\_with\\_status\\_update(self):\n        self.\\_start\\_run()\n        self.\\_result\\_pane\\[:\\] \\= \\[self.\\_run()\\]\n        self.\\_stop\\_run()\n\n    @param.depends(\"status\", watch\\=True)\n    def \\_update\\_status\\_pane(self):\n        self.\\_status\\_pane.object \\= self.status\n\n    def \\_load(self):\n        time.sleep(self.load\\_delay)\n        return \"Loaded\"\n\n    def \\_run(self):\n        time.sleep(self.run\\_delay)\n        return f\"Result {self.runs+1}\"\n\nif pn.state.served:\n    pn.extension(sizing\\_mode\\=\"stretch\\_width\")\n\n    App().servable()\n\nNow serve the app via `panel serve app.py` and open [http://localhost:5006/app](http://localhost:5006/app) in your browser to see what it does.\n\n## Create the unit tests[#](#create-the-unit-tests \"Permalink to this heading\")\n\nLet’s test:\n\n*   The initial _state_ of the App\n    \n*   That the app _state_ changes appropriately when the _Run_ button is clicked.\n    \n\nCreate the file `test_app.py` and add the code below.\n\ntest\\_app.py\n\nimport pytest\n\nfrom app import App\n\n@pytest.fixture\ndef app():\n    return App(sleep\\_delay\\=0.001, load\\_delay\\=0.001)\n\ndef test\\_constructor(app):\n    \"\"\"Tests default values of App\"\"\"\n    \\# Then\n    assert app.run \\== False\n    assert app.status \\== \"No runs yet\"\n    assert app.runs \\== 0\n\ndef test\\_run(app):\n    \"\"\"Tests behaviour when Run button is clicked once\"\"\"\n    \\# When\n    app.param.trigger('run')\n    \\# Then\n    assert app.runs \\== 1\n    assert app.status.startswith(\"Finished run 1 in\")\n\ndef test\\_run\\_twice(app):\n    \"\"\"Tests behaviour when Run button is clicked twice\"\"\"\n    \\# When\n    app.param.trigger('run')\n    app.param.trigger('run')\n    \\# Then\n    assert app.runs \\== 2\n    assert app.status.startswith(\"Finished run 2 in\")\n\nLet’s run `pytest test_app.py`:\n\n$ pytest test\\_app.py\n\\=================================== test session starts\n...\ncollected 3 items\n\ntest\\_app.py ...                                                                       \\[100%\\]\n\n\\=============================== 3 passed\n\n## Create a performance test[#](#create-a-performance-test \"Permalink to this heading\")\n\nThe performance of your data app is key to providing a good user experience. You can test the performance of functions and methods using [pytest-benchmark](https://github.com/ionelmc/pytest-benchmark).\n\nLet’s test that:\n\n*   the _duration_ of the run is as expected.\n    \n\nCreate the file `test_app_performance.py`:\n\ntest\\_app\\_performance.py\n\n\\# test\\_app\\_performance.py\nimport pytest\nfrom app import App\n\n@pytest.fixture\ndef app():\n    return App(run\\_delay\\=0.001, load\\_delay\\=0.001)\n\ndef test\\_run\\_performance(app: App, benchmark):\n    \"\"\"Test the duration when the Run button is clicked\"\"\"\n    app.run\\_delay\\=0.3\n\n    def run():\n        app.param.trigger('run')\n\n    benchmark(run)\n    assert benchmark.stats\\['min'\\] \\>= 0.3\n    assert benchmark.stats\\['max'\\] < 0.4\n\nRun `pytest test_app_performance.py`.\n\n$ pytest test\\_app\\_performance.py\n\\============================================================================================================================= test session starts\n...\ncollected 1 item\n\ntest\\_app\\_performance.py .                                                                                                                                                                                                                                                 \\[100%\\]\n\n------------------------------------------------- benchmark: 1 tests \\------------------------------------------------\nName (time in ms)             Min       Max      Mean  StdDev    Median     IQR  Outliers     OPS  Rounds  Iterations\n---------------------------------------------------------------------------------------------------------------------\ntest\\_run\\_performance     307.6315  316.8270  312.2731  4.2335  314.1614  7.5190       3;0  3.2023       5           1\n---------------------------------------------------------------------------------------------------------------------\n\nLegend:\n  Outliers: 1 Standard Deviation from Mean; 1.5 IQR (InterQuartile Range) from 1st Quartile and 3rd Quartile.\n  OPS: Operations Per Second, computed as 1 / Mean\n\\========================================================================================================================= 1 passed in 3.23s\n\nNotice how we used the `benchmark` _fixture_ of [pytest-benchmark](https://pytest-benchmark.readthedocs.io/en/latest/) to test the performance of the `run` event."
},
{
  "markdown": "## Launching a server dynamically[#](#launching-a-server-dynamically \"Permalink to this heading\")\n\nThe CLI `panel serve` command described below is usually the best approach for deploying applications. However when working on the REPL or embedding a Panel/Bokeh server in another application it is sometimes useful to dynamically launch a server, either using the `.show` method or using the `pn.serve` function.\n\n## Previewing an application[#](#previewing-an-application \"Permalink to this heading\")\n\nWorking from the command line will not automatically display rich representations inline as in a notebook, but you can still interact with your Panel components if you start a Bokeh server instance and open a separate browser window using the `show` method. The method has the following arguments:\n\ntitle : str | None\n  A string title to give the Document (if served as an app)\nport: int (optional, default=0)\n  Allows specifying a specific port\naddress : str\n  The address the server should listen on for HTTP requests.\nwebsocket\\_origin: str or list(str) (optional)\n  A list of hosts that can connect to the websocket.\n  This is typically required when embedding a server app in\n  an external web site.\n  If None, \"localhost\" is used.\nthreaded: boolean (optional, default=False)\n  Whether to launch the Server on a separate thread, allowing\n  interactive use.\nverbose: boolean (optional, default=True)\n  Whether to print the address and port\nopen : boolean (optional, default=True)\n  Whether to open the server in a new browser tab\nlocation : boolean or panel.io.location.Location\n  Whether to create a Location component to observe and\n  set the URL location.\n\nTo work with an app completely interactively you can set `threaded=True` which will launch the server on a separate thread and let you interactively play with the app.\n\n![](https://assets.holoviews.org/panel/gifs/commandline_show.gif)\n\nThe `.show` call will return either a Bokeh server instance (if `threaded=False`) or a `StoppableThread` instance (if `threaded=True`) which both provide a `stop` method to stop the server instance.\n\nThe `pn.serve` accepts a number of arguments:\n\n    panel: Viewable, function or {str: Viewable or function}\n      A Panel object, a function returning a Panel object or a\n      dictionary mapping from the URL slug to either.\n    port: int (optional, default=0)\n      Allows specifying a specific port\n    address : str\n      The address the server should listen on for HTTP requests.\n    websocket\\_origin: str or list(str) (optional)\n      A list of hosts that can connect to the websocket.\n\n      This is typically required when embedding a server app in\n      an external web site.\n\n      If None, \"localhost\" is used.\n    loop : tornado.ioloop.IOLoop (optional, default=IOLoop.current())\n      The tornado IOLoop to run the Server on\n    show : boolean (optional, default=True)\n      Whether to open the server in a new browser tab on start\n    start : boolean(optional, default=True)\n      Whether to start the Server\n    title: str or {str: str} (optional, default=None)\n      An HTML title for the application or a dictionary mapping\n      from the URL slug to a customized title\n    verbose: boolean (optional, default=True)\n      Whether to print the address and port\n    location : boolean or panel.io.location.Location\n      Whether to create a Location component to observe and\n      set the URL location.\n    threaded: boolean (default=False)\n      Whether to start the server on a new Thread\n    admin: boolean (default=False)\n      Whether to enable the admin panel\n    kwargs: dict\n      Additional keyword arguments to pass to Server instance"
},
{
  "markdown": "## Test UI rendering[#](#test-ui-rendering \"Permalink to this heading\")\n\nThis guide addresses how to test the UI with Pytest and Playwright.\n\n* * *\n\nTesting is key to developing robust and performant applications. Particularly when you build complex UIs you will want to ensure that it behaves as expected. Unit tests will allow you test that the logic on the backend behaves correctly, but it is also useful to test that the UI is rendered correctly and responds appropriately.\n\nFor testing the UI we recommend the framework [Playwright](https://playwright.dev/). Panel itself is tested with this framework.\n\nBefore you get started ensure you have installed the required dependencies:\n\npip install panel pytest pytest-playwright\n\nand ensure `playwright` sets up the browsers it will use to display the applications:\n\n## Create the app[#](#create-the-app \"Permalink to this heading\")\n\nLet’s create a simple data app for testing. The app sleeps 0.5 seconds (default) when loaded and when the button is clicked.\n\n![app.py](https://assets.holoviz.org/panel/gifs/pytest.gif)\n\nCreate the file `app.py` and add the code below (don’t worry about the contents of the app for now):\n\napp.py\n\nimport time\n\nimport panel as pn\nimport param\n\nclass App(pn.viewable.Viewer):\n    run \\= param.Event(doc\\=\"Runs for click\\_delay seconds when clicked\")\n    runs \\= param.Integer(doc\\=\"The number of runs\")\n    status \\= param.String(default\\=\"No runs yet\")\n\n    load\\_delay \\= param.Number(default\\=0.5)\n    run\\_delay \\= param.Number(default\\=0.5)\n\n    def \\_\\_init\\_\\_(self, \\*\\*params):\n        super().\\_\\_init\\_\\_(\\*\\*params)\n\n        result \\= self.\\_load()\n        self.\\_time \\= time.time()\n\n        self.\\_status\\_pane \\= pn.pane.Markdown(self.status, height\\=40, align\\=\"start\", margin\\=(0,5,10,5))\n        self.\\_result\\_pane \\= pn.Column(result)\n        self.\\_view \\= pn.Column(\n            pn.Row(pn.widgets.Button.from\\_param(self.param.run, sizing\\_mode\\=\"fixed\"), self.\\_status\\_pane),\n            self.\\_result\\_pane\n        )\n\n    def \\_\\_panel\\_\\_(self):\n        return self.\\_view\n\n    def \\_start\\_run(self):\n        self.status \\= f\"Running ...\"\n        self.\\_time \\= time.time()\n\n    def \\_stop\\_run(self):\n        now \\= time.time()\n        duration \\= round(now\\-self.\\_time,3)\n        self.\\_time \\= now\n        self.runs+=1\n        self.status\\=f\"Finished run {self.runs} in {duration}sec\"\n\n    @param.depends(\"run\", watch\\=True)\n    def \\_run\\_with\\_status\\_update(self):\n        self.\\_start\\_run()\n        self.\\_result\\_pane\\[:\\] \\= \\[self.\\_run()\\]\n        self.\\_stop\\_run()\n\n    @param.depends(\"status\", watch\\=True)\n    def \\_update\\_status\\_pane(self):\n        self.\\_status\\_pane.object \\= self.status\n\n    def \\_load(self):\n        time.sleep(self.load\\_delay)\n        return \"Loaded\"\n\n    def \\_run(self):\n        time.sleep(self.run\\_delay)\n        return f\"Result {self.runs+1}\"\n\nif pn.state.served:\n    pn.extension(sizing\\_mode\\=\"stretch\\_width\")\n\n    App().servable()\n\nServe the app via `panel serve app.py` and open [http://localhost:5006/app](http://localhost:5006/app) in your browser to see what it does.\n\n## Create a conftest.py[#](#create-a-conftest-py \"Permalink to this heading\")\n\nThe `conftest.py` file should be placed alongside your tests and will be loaded automatically by pytest. It is often used to declare [fixtures](https://docs.pytest.org/en/latest/explanation/fixtures.html) that allow you declare reusable components. It will:\n\n*   provide us with an available `port`.\n    \n*   clean up the Panel _state_ after each test.\n    \n\nCreate the file `conftest.py` and add the code below.\n\nconftest.py\n\n\"\"\"Shared configuration and fixtures for testing Panel\"\"\"\nimport panel as pn\nimport pytest\n\nPORT \\= \\[6000\\]\n\n@pytest.fixture\ndef port():\n    PORT\\[0\\] += 1\n    return PORT\\[0\\]\n\n@pytest.fixture(autouse\\=True)\ndef server\\_cleanup():\n    \"\"\"\n    Clean up server state after each test.\n    \"\"\"\n    try:\n        yield\n    finally:\n        pn.state.reset()\n\nFor more inspiration see the [Panel `conftest.py` file](https://github.com/holoviz/panel/blob/main/panel/tests/conftest.py)\n\n### Test the app UI[#](#test-the-app-ui \"Permalink to this heading\")\n\nNow let us actually set up some UI tests, we will want to assert that the app:\n\n*   Responds when we make an initial request\n    \n*   Renders a _Run_ button\n    \n*   Updates as expected when the _Run_ button is clicked\n    \n\nCreate the file `test_app_frontend.py` and add the code below.\n\ntest\\_app\\_frontend.py\n\nimport time\n\nimport panel as pn\nfrom app import App\n\nCLICKS \\= 2\n\ndef test\\_component(page, port):\n    \\# Given\n    component \\= App()\n    url \\= f\"http://localhost:{port}\"\n    \\# When\n    server \\= pn.serve(component, port\\=port, threaded\\=True, show\\=False)\n    time.sleep(0.2)\n    \\# Then\n    page.goto(url)\n    page.get\\_by\\_role(\"button\", name\\=\"Run\").wait\\_for()\n\n    for index in range(CLICKS):\n        page.get\\_by\\_role(\"button\", name\\=\"Run\").first.click()\n        page.get\\_by\\_text(f\"Finished run {index+1}\").wait\\_for()\n    \\# Clean up\n    server.stop()\n\nLet’s run `pytest`. We will add the `--headed` and `--slowmo` arguments to see what is going on in the browser. This is very illustrative and also helpful for debugging purposes.\n\npytest test\\_app\\_frontend.py \\--headed \\--slowmo 1000\n\n![Playwright UI test with --headed enabled](https://assets.holoviz.org/panel/gifs/uitest.gif)\n\n### Record the test code[#](#record-the-test-code \"Permalink to this heading\")\n\nWriting code to test complex UIs can be quite cumbersome, thankfully there is an easier way. Playwright allows you to record UI interactions as you navigate your live app and translates these interactions as code (see the [Playwright codegen](https://playwright.dev/python/docs/codegen) documentation for more detail).\n\nYou can try it yourself by launching the app again:\n\nand starting the Playwright recorder:\n\nplaywright codegen http://localhost:5006/app\n\n![Playwright Code generation demo](https://assets.holoviz.org/panel/gifs/codegen.gif)"
},
{
  "markdown": "## Serving multiple applications[#](#serving-multiple-applications \"Permalink to this heading\")\n\nIf you want to serve more than one app on a single server you can use the `pn.serve` function. By supplying a dictionary where the keys represent the URL slugs and the values must be either Panel objects or functions returning Panel objects you can easily launch a server with a number of apps, e.g.:\n\nimport panel as pn\npn.serve({\n    'markdown': '# This is a Panel app',\n    'json': pn.pane.JSON({'abc': 123})\n})\n\nNote that when you serve an object directly all sessions will share the same state, i.e. the parameters of all components will be synced across sessions such that the change in a widget by one user will affect all other users. Therefore you will usually want to wrap your app in a function, ensuring that each user gets a new instance of the application:\n\ndef markdown\\_app():\n    return '# This is a Panel app'\n\ndef json\\_app():\n    return pn.pane.JSON({'abc': 123})\n\npn.serve({\n    'markdown': markdown\\_app,\n    'json': json\\_app\n})\n\nYou can customize the HTML title of each application by supplying a dictionary where the keys represent the URL slugs and the values represent the titles, e.g.:\n\npn.serve({\n    'markdown': '# This is a Panel app',\n    'json': pn.pane.JSON({'abc': 123})\n}, title\\={'markdown': 'A Markdown App', 'json': 'A JSON App'}\n)"
},
{
  "markdown": "In some scenarios a standalone bokeh server may be running on remote host. In such cases, SSH can be used to “tunnel” to the server. In the simplest scenario, the Bokeh server will run on one host and will be accessed from another location, e.g., a laptop, with no intermediary machines.\n\nRun the server as usual on the remote host:\n\nNext, issue the following command on the local machine to establish an SSH tunnel to the remote host:\n\nssh \\-NfL localhost:5006:localhost:5006 user@remote.host\n\nReplace user with your username on the remote host and remote.host with the hostname/IP address of the system hosting the Bokeh server. You may be prompted for login credentials for the remote system. After the connection is set up you will be able to navigate to localhost:5006 as though the Bokeh server were running on the local machine.\n\nThe second, slightly more complicated case occurs when there is a gateway between the server and the local machine. In that situation a reverse tunnel must be established from the server to the gateway. Additionally the tunnel from the local machine will also point to the gateway.\n\nIssue the following commands on the remote host where the Bokeh server will run:\n\nnohup bokeh server &\nssh \\-NfR 5006:localhost:5006 user@gateway.host\n\nReplace user with your username on the gateway and gateway.host with the hostname/IP address of the gateway. You may be prompted for login credentials for the gateway.\n\nNow set up the other half of the tunnel, from the local machine to the gateway. On the local machine:\n\nssh \\-NfL localhost:5006:localhost:5006 user@gateway.host\n\nAgain, replace user with your username on the gateway and gateway.host with the hostname/IP address of the gateway. You should now be able to access the Bokeh server from the local machine by navigating to localhost:5006 on the local machine, as if the Bokeh server were running on the local machine. You can even set up client connections from a Jupyter notebook running on the local machine."
},
{
  "markdown": "## How-to[#](#how-to \"Permalink to this heading\")\n\nThe Panel How-to guides provide step by step recipes for solving essential problems and tasks that arise during your work. They assume that you’ve completed the Getting Started material and therefore already have some knowledge of how Panel works. There is no order to the guides, other than any potential prerequisites listed at the top of a page. Jump to the topic that is relevant to you now.\n\n## Prepare to develop[#](#prepare-to-develop \"Permalink to this heading\")\n\nDevelop in a notebook\n\nHow to effectively develop apps in a notebook environment.\n\nDevelop in an editor\n\nHow to effectively develop apps in a Python or Markdown file.\n\n## Build apps[#](#build-apps \"Permalink to this heading\")\n\nConstruct components\n\nHow to construct and customize individual components like an image or slider widget.\n\nArrange Components\n\nHow to arrange and size components on the page.\n\nStyle components\n\nHow to apply designs, themes and custom styling to components to achieve a polished look and feel.\n\nAdd interactivity\n\nHow to link add interactivity to your applications using reactive APIs.\n\nApply templates\n\nHow to use a Template to customize the look and feel of a deployed Panel app.\n\n## Use specialized UIs and APIs[#](#use-specialized-uis-and-apis \"Permalink to this heading\")\n\nBuild a sequential UI\n\nHow to build a Panel Pipeline that connects multiple panels into a sequential user interface.\n\nBuild custom components\n\nHow to extend Panel by building custom components.\n\nGenerate UIs from declared parameters (`Declarative API`)\n\nHow to use Parameterized classes with Panel to generate UIs without writing GUI code.\n\nExplicitly link parameters (`Callbacks API`)\n\nHow to link the parameters of Panel components in Python and Javascript.\n\n## Manage session tasks[#](#manage-session-tasks \"Permalink to this heading\")\n\nRegister session callbacks\n\nHow to set up callbacks on session related events (e.g. on page load or when a session is destroyed) and define periodic tasks.\n\nAccess session state\n\nHow to access and manipulate state related to the user session, HTTP request and URL arguments.\n\n## Test and debug[#](#test-and-debug \"Permalink to this heading\")\n\nEnable profiling and debugging\n\nHow to profile and debug your application using the admin dashboard and other tools.\n\nSet up testing for an application\n\nHow to set up unit tests, UI tests and load testing to ensure your applications are (and stay) robust and scalable.\n\n## Share your work[#](#share-your-work \"Permalink to this heading\")\n\nConfigure the server\n\nHow to configure the Panel server.\n\nIntegrate with other servers\n\nHow to integrate Panel in other application based on Flask, FastAPI or Django.\n\nDeploy applications\n\nHow to deploy Panel applications to various cloud providers (e.g. Azure, GCP, AWS etc.)\n\nExport apps\n\nHow to export and save Panel applications as static files.\n\nRun panel in WebAssembly\n\nHow to run Panel applications entirely in the browser using WebAssembly (Wasm), Pyodide, and PyScript.\n\n## Migrate to Panel[#](#migrate-to-panel \"Permalink to this heading\")\n\nMigrate from Streamlit\n\n[![https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)\n\nHow to migrate existing Streamlit applications to Panel."
},
{
  "markdown": "## Configuring a reverse proxy[#](#configuring-a-reverse-proxy \"Permalink to this heading\")\n\nIf the goal is to serve an web application to the general Internet, it is often desirable to host the application on an internal network, and proxy connections to it through some dedicated HTTP server. For some basic configurations to set up a Bokeh server behind some common reverse proxies, including Nginx and Apache, refer to the [Bokeh documentation](https://bokeh.pydata.org/en/latest/docs/user_guide/server.html#basic-reverse-proxy-setup)."
},
{
  "markdown": "## Test operating capacity[#](#test-operating-capacity \"Permalink to this heading\")\n\nThis guide addresses how to test performance by simulating multiple users accessing an app concurrently.\n\n* * *\n\n_Load testing_ means testing the performance of the entire Panel application and the server(s) running it.\n\nThis kind of testing is really useful if you want to\n\n*   develop fast and snappy applications and/ or\n    \n*   develop applications that scale to many users\n    \n\nBefore you get started ensure you have installed the required dependencies:\n\npip install panel pytest locust pytest-playwright pytest-asyncio loadwright\n\nand ensure `playwright` sets up the browsers it will use to display the applications:\n\n## Create the app[#](#create-the-app \"Permalink to this heading\")\n\nLets create a simple data app for testing. The app sleeps 0.5 seconds (default) when loaded and when the button is clicked.\n\n![app.py](https://assets.holoviz.org/panel/gifs/pytest.gif)\n\nCreate the file `app.py` and add the code below:\n\napp.py\n\nimport time\n\nimport panel as pn\nimport param\n\nclass App(pn.viewable.Viewer):\n    run \\= param.Event(doc\\=\"Runs for click\\_delay seconds when clicked\")\n    runs \\= param.Integer(doc\\=\"The number of runs\")\n    status \\= param.String(default\\=\"No runs yet\")\n\n    load\\_delay \\= param.Number(default\\=0.5)\n    run\\_delay \\= param.Number(default\\=0.5)\n\n    def \\_\\_init\\_\\_(self, \\*\\*params):\n        super().\\_\\_init\\_\\_(\\*\\*params)\n\n        result \\= self.\\_load()\n        self.\\_time \\= time.time()\n\n        self.\\_status\\_pane \\= pn.pane.Markdown(self.status, height\\=40, align\\=\"start\", margin\\=(0,5,10,5))\n        self.\\_result\\_pane \\= pn.Column(result)\n        self.\\_view \\= pn.Column(\n            pn.Row(pn.widgets.Button.from\\_param(self.param.run, sizing\\_mode\\=\"fixed\"), self.\\_status\\_pane),\n            self.\\_result\\_pane\n        )\n\n    def \\_\\_panel\\_\\_(self):\n        return self.\\_view\n\n    def \\_start\\_run(self):\n        self.status \\= f\"Running ...\"\n        self.\\_time \\= time.time()\n\n    def \\_stop\\_run(self):\n        now \\= time.time()\n        duration \\= round(now\\-self.\\_time,3)\n        self.\\_time \\= now\n        self.runs+=1\n        self.status\\=f\"Finished run {self.runs} in {duration}sec\"\n\n    @param.depends(\"run\", watch\\=True)\n    def \\_run\\_with\\_status\\_update(self):\n        self.\\_start\\_run()\n        self.\\_result\\_pane\\[:\\] \\= \\[self.\\_run()\\]\n        self.\\_stop\\_run()\n\n    @param.depends(\"status\", watch\\=True)\n    def \\_update\\_status\\_pane(self):\n        self.\\_status\\_pane.object \\= self.status\n\n    def \\_load(self):\n        time.sleep(self.load\\_delay)\n        return \"Loaded\"\n\n    def \\_run(self):\n        time.sleep(self.run\\_delay)\n        return f\"Result {self.runs+1}\"\n\nif pn.state.served:\n    pn.extension(sizing\\_mode\\=\"stretch\\_width\")\n    App().servable()\n\nServe the app via `panel serve app.py` and open [http://localhost:5006/app](http://localhost:5006/app) in your browser.\n\n## Create a conftest.py[#](#create-a-conftest-py \"Permalink to this heading\")\n\nThe `conftest.py` file should be placed alongside your tests and will be loaded automatically by pytest. It is often used to declare [fixtures](https://docs.pytest.org/en/6.2.x/fixture.html) that allow you declare reusable components. It will:\n\n*   provide us with an available `port`.\n    \n*   clean up the Panel _state_ after each test.\n    \n\nCreate the file `conftest.py` and add the code below.\n\nconftest.py\n\n\"\"\"Shared configuration and fixtures for testing Panel\"\"\"\nimport panel as pn\nimport pytest\n\nPORT \\= \\[6000\\]\n\n@pytest.fixture\ndef port():\n    PORT\\[0\\] += 1\n    return PORT\\[0\\]\n\n@pytest.fixture(autouse\\=True)\ndef server\\_cleanup():\n    \"\"\"\n    Clean up server state after each test.\n    \"\"\"\n    try:\n        yield\n    finally:\n        pn.state.reset()\n\nFor more inspiration see the [Panel `conftest.py` file](https://github.com/holoviz/panel/blob/main/panel/tests/conftest.py)\n\n## Test the initial load with Locust[#](#test-the-initial-load-with-locust \"Permalink to this heading\")\n\n[Locust](https://locust.io/) can help you test the behaviour of users that load (i.e. request) your Panel app. Locust provides many useful performance related statistics and charts.\n\nCreate the file `locustfile.py` and add the code below.\n\nlocustfile.py\n\nfrom locust import HttpUser, task\n\nclass RequestOnlyUser(HttpUser):\n    @task\n    def goto(self):\n        self.client.get(\"/app\")\n\nStart the Panel server:\n\nStart the Locust server\n\nlocust \\--host http://localhost:5006\n\nOpen [http://localhost:8089](http://localhost:8089/). Keep the default settings and click the _Start swarming_ button. This should look like the below:\n\n![panel-locust.gif](https://assets.holoviz.org/panel/gifs/locust.gif)\n\nThe median response time is ~530ms when one user requests the page every second. If you try to increase to 10 simultaneous users you will see a median response time of ~5300ms. If this is a likely scenario, you will have to look into how to improve the performance of your app.\n\n## Test advanced interactions with Loadwright[#](#test-advanced-interactions-with-loadwright \"Permalink to this heading\")\n\n[Loadwright](https://github.com/awesome-panel/loadwright) is a young load testing framework built on top of Playwright and Panel.\n\nLets replicate a user that:\n\n*   Opens the app in the browser\n    \n*   Clicks the _Run_ button `n_clicks` times.\n    \n\nCreate the file `test_loadwright.py` and add the code below:\n\ntest\\_loadwright.py\n\nimport param\nimport pytest\n\nfrom loadwright import LoadTestRunner, LoadTestViewer, User\n\nimport panel as pn\n\nfrom app import App\n\nHEADLESS \\= False\n\nclass LoadAndClickUser(User):\n    \"\"\"A custom User that loads a page and clicks a button n\\_clicks times\"\"\"\n\n    n\\_clicks \\= param.Integer(\n        default\\=1, bounds\\=(0, None), doc\\=\"The number of times to click the button\"\n    )\n\n    async def run(self):\n        with self.event(name\\=\"load\", user\\=self.name):\n            await self.page.goto(self.url)\n            await self.page.get\\_by\\_role(\"button\", name\\=\"Run\").wait\\_for()\n        await self.sleep()\n\n        for click\\_index in range(self.n\\_clicks):\n            with self.event(name\\=\"interact\", user\\=self.name):\n                await self.page.get\\_by\\_role(\"button\", name\\=\"Run\").first.click()\n                await self.page.get\\_by\\_text(f\"Finished run {click\\_index+1}\").wait\\_for()\n            await self.sleep()\n\n@pytest.mark.asyncio\nasync def test\\_component\\_2(port\\=6001):\n    \"\"\"We can run the LoadTestRunner with 5 users each clicking 5 times\"\"\"\n    async with LoadTestRunner.serve(App, port\\=port) as host:\n        runner \\= LoadTestRunner(host\\=host, headless\\=HEADLESS, user\\=LoadAndClickUser(n\\_clicks\\=5), n\\_users\\=5)\n        await runner.run()\n        \\# You can access the data of the run via runner.logger.data\n        assert runner.logger.data.duration.mean()<=10\n\nif pn.state.served:\n    import panel as pn\n    pn.extension(sizing\\_mode\\=\"stretch\\_width\")\n    viewer \\= LoadTestViewer(data\\=\"test\\_results/loadwright.csv\")\n    pn.template.FastListTemplate(\n        site\\=\"LoadWright\",\n        title\\=\"Load Testing with Playwright and Panel\",\n        main\\=\\[viewer\\]\n    ).servable()\n\nRun the tests with pytest\n\npytest test\\_loadwright.py\n\nView the results with Panel\n\n$ panel serve test\\_loadwright.py\n...\n2023\\-01-01 15:53:03,396 Bokeh app running at: http://localhost:5006/test\\_loadwright\n\n![Loadwright Demo](https://assets.holoviz.org/panel/gifs/loadwright.gif).\n\nYou will find an _archive_ of _test results_ in the `tests_results/archive` folder."
},
{
  "markdown": "## Serving static files[#](#serving-static-files \"Permalink to this heading\")\n\nWhether you’re launching your application using `panel serve` from the commandline or using `pn.serve` in a script you can also serve static files. When using `panel serve` you can use the `--static-dirs` argument to specify a list of static directories to serve along with their routes, e.g.:\n\npanel serve some\\_script.py --static-dirs assets=./assets\n\nThis will serve the `./assets` directory on the servers `/assets` route. Note however that the `/static` route is reserved internally by Panel.\n\nSimilarly when using `pn.serve` or `panel_obj.show` the static routes may be defined as a dictionary, e.g. the equivalent to the example would be:\n\npn.serve(panel\\_obj, static\\_dirs={'assets': './assets'})"
},
{
  "markdown": "## Server Integrations[#](#server-integrations \"Permalink to this heading\")\n\nThese guides will cover how to integrate Panel applications with various external frameworks such as Django, FastAPI and Flask.\n\nFlask\n\nDiscover to run Panel applications alongside an existing Flask server.\n\n![Flask Logo](https://panel.holoviz.org/_images/flask.png)\n\nFastAPI\n\nDiscover to run Panel applications alongside an existing FastAPI server.\n\n![FastAPI Logo](https://panel.holoviz.org/_images/fastapi.png)\n\nDjango\n\nDiscover to run Panel applications on a Django server (replacing the standard Tornado based server).\n\n![Django Logo](https://panel.holoviz.org/_images/django.png)"
},
{
  "markdown": "## Integrating Panel with Flask[#](#integrating-panel-with-flask \"Permalink to this heading\")\n\nWIP"
},
{
  "markdown": "## Integrating Panel with FastAPI[#](#integrating-panel-with-fastapi \"Permalink to this heading\")\n\nPanel generally runs on the Bokeh server which itself runs on Tornado. However, it is also often useful to embed a Panel app in large web application, such as a FastAPI web server. [FastAPI](https://fastapi.tiangolo.com/) is especially useful compared to others like Flask and Django because of it’s lightning fast, lightweight framework. Using Panel with FastAPI requires a bit more work than for notebooks and Bokeh servers.\n\nFollowing FastAPI’s [Tutorial - User Guide](https://fastapi.tiangolo.com/tutorial/) make sure you first have FastAPI installed using: `conda install -c conda-forge fastapi`. Also make sure Panel is installed `conda install -c conda-forge panel`.\n\n## Configuration[#](#configuration \"Permalink to this heading\")\n\nBefore we start adding a bokeh app to our FastApi server we have to set up some of the basic plumbing. In the `examples/apps/fastApi` folder we will add some basic configurations.\n\nYou’ll need to create a file called `examples/apps/fastApi/main.py`.\n\nIn `main.py` you’ll need to import the following( which should all be already available from the above conda installs): i\n\nimport panel as pn\nfrom bokeh.embed import server\\_document\nfrom fastapi import FastAPI, Request\nfrom fastapi.templating import Jinja2Templates\n\nEach of these will be explained as we add them in.\n\nNext we are going to need to create an instance of FastAPI below your imports in `main.py` and set up the path to your templates like so:\n\napp \\= FastAPI()\ntemplates \\= Jinja2Templates(directory\\=\"examples/apps/fastApi/templates\")\n\nWe will now need to create our first rout via an async function and point it to the path of our server:\n\n@app.get(\"/\")\nasync def bkapp\\_page(request: Request):\n    script \\= server\\_document('http://127.0.0.1:5000/app')\n    return templates.TemplateResponse(\"base.html\", {\"request\": request, \"script\": script})\n\nAs you can see in this code we will also need to create an html [Jinja2](https://fastapi.tiangolo.com/advanced/templates/#using-jinja2templates) template. Create a new directory named `examples/apps/fastApi/templates` and create the file `examples/apps/fastApi/templates/base.html` in that directory.\n\nNow add the following to `base.html`. This is a minimal version but feel free to add whatever else you need to it.\n\n<!DOCTYPE html>\n<html\\>\n    <head\\>\n        <title\\>Panel in FastAPI: sliders</title\\>\n    </head\\>\n    <body\\>\n        {{ script|safe }}\n    </body\\>\n</html\\>\n\nReturn back to your `examples/apps/fastApi/main.py` file. We will use pn.serve() to start the bokeh server (Which Panel is built on). Configure it to whatever port and address you want, for our example we will use port 5000 and address 127.0.0.1. show=False will make it so the bokeh server is spun up but not shown yet. The allow\\_websocket\\_origin will list of hosts that can connect to the websocket, for us this is fastApi so we will use (127.0.0.1:8000). The `createApp` function call in this example is how we call our panel app. This is not set up yet but will be in the next section.\n\npn.serve({'/app': createApp},\n        port\\=5000, allow\\_websocket\\_origin\\=\\[\"127.0.0.1:8000\"\\],\n        address\\=\"127.0.0.1\", show\\=False)\n\nYou could optionally add BOKEH\\_ALLOW\\_WS\\_ORIGIN=127.0.0.1:8000 as an environment variable instead of setting it here. In conda it is done like this.\n\n`conda env config vars set BOKEH_ALLOW_WS_ORIGIN=127.0.0.1:8000`\n\n## Sliders app[#](#sliders-app \"Permalink to this heading\")\n\nBased on a standard FastAPI app template, this app shows how to integrate Panel and FastAPI.\n\nThe sliders app is in `examples/apps/fastApi/sliders`. We will cover the following additions/modifications to the Django2 app template:\n\n*   `sliders/sinewave.py`: a parameterized object (representing your pre-existing code)\n    \n*   `sliders/pn_app.py`: creates an app function from the SineWave class\n    \n\nTo start with, in `sliders/sinewave.py` we create a parameterized object to serve as a placeholder for your own, existing code:\n\nimport numpy as np\nimport param\nfrom bokeh.models import ColumnDataSource\nfrom bokeh.plotting import figure\n\nclass SineWave(param.Parameterized):\n    offset \\= param.Number(default\\=0.0, bounds\\=(\\-5.0, 5.0))\n    amplitude \\= param.Number(default\\=1.0, bounds\\=(\\-5.0, 5.0))\n    phase \\= param.Number(default\\=0.0, bounds\\=(0.0, 2 \\* np.pi))\n    frequency \\= param.Number(default\\=1.0, bounds\\=(0.1, 5.1))\n    N \\= param.Integer(default\\=200, bounds\\=(0, None))\n    x\\_range \\= param.Range(default\\=(0, 4 \\* np.pi), bounds\\=(0, 4 \\* np.pi))\n    y\\_range \\= param.Range(default\\=(\\-2.5, 2.5), bounds\\=(\\-10, 10))\n\n    def \\_\\_init\\_\\_(self, \\*\\*params):\n        super(SineWave, self).\\_\\_init\\_\\_(\\*\\*params)\n        x, y \\= self.sine()\n        self.cds \\= ColumnDataSource(data\\=dict(x\\=x, y\\=y))\n        self.plot \\= figure(plot\\_height\\=400, plot\\_width\\=400,\n                           tools\\=\"crosshair, pan, reset, save, wheel\\_zoom\",\n                           x\\_range\\=self.x\\_range, y\\_range\\=self.y\\_range)\n        self.plot.line('x', 'y', source\\=self.cds, line\\_width\\=3, line\\_alpha\\=0.6)\n\n    @param.depends('N', 'frequency', 'amplitude', 'offset', 'phase', 'x\\_range', 'y\\_range', watch\\=True)\n    def update\\_plot(self):\n        x, y \\= self.sine()\n        self.cds.data \\= dict(x\\=x, y\\=y)\n        self.plot.x\\_range.start, self.plot.x\\_range.end \\= self.x\\_range\n        self.plot.y\\_range.start, self.plot.y\\_range.end \\= self.y\\_range\n\n    def sine(self):\n        x \\= np.linspace(0, 4 \\* np.pi, self.N)\n        y \\= self.amplitude \\* np.sin(self.frequency \\* x + self.phase) + self.offset\n        return x, y\n\nHowever the app itself is defined we need to configure an entry point, which is a function that adds the application to it. In case of the slider app it looks like this in `sliders/pn_app.py`:\n\nimport panel as pn\n\nfrom .sinewave import SineWave\n\ndef createApp():\n    sw \\= SineWave()\n    return pn.Row(sw.param, sw.plot).servable()\n\nWe now need to return to our `main.py` and import the createApp function. Add the following import near the other imports:\n\nfrom sliders.pn\\_app import createApp\n\nYour file structure should now be like the following:\n\nfastApi\n│   main.py\n│\n└───sliders\n│   │   sinewave.py\n│   │   pn\\_app.py\n│\n└───templates\n    │   base.html\n\nAnd your finished `main.py` should look like this:\n\nimport panel as pn\nfrom bokeh.embed import server\\_document\nfrom fastapi import FastAPI, Request\nfrom fastapi.templating import Jinja2Templates\n\nfrom sliders.pn\\_app import createApp\n\napp \\= FastAPI()\ntemplates \\= Jinja2Templates(directory\\=\"templates\")\n\n@app.get(\"/\")\nasync def bkapp\\_page(request: Request):\n    script \\= server\\_document('http://127.0.0.1:5000/app')\n    return templates.TemplateResponse(\"base.html\", {\"request\": request, \"script\": script})\n\npn.serve({'/app': createApp},\n        port\\=5000, allow\\_websocket\\_origin\\=\\[\"127.0.0.1:8000\"\\],\n         address\\=\"127.0.0.1\", show\\=False)\n\nuvicorn main:app \\--reload\n\nThe output should give you a link to go to to view your app:\n\nUvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n\nGo to that address and your app should be there running!\n\n## Multiple apps[#](#multiple-apps \"Permalink to this heading\")\n\nThis is the most basic configuration for a bokeh server. It is of course possible to add multiple apps in the same way and then registering them with FastApi in the way described in the configuration section above. To see a multi-app fastApi server have a look at `examples/apps/fastApi_multi_apps` and launch it with `uvicorn main:app --reload` as before.\n\nTo run multiple apps you will need to do the following:\n\n1.  Create a new directory in your and a new file with your panel app (ex. `sinewave2.py`).\n    \n2.  Create another pn\\_app file in your new directory (ex. `pn_app2.py`) That might look something like this:\n    \n\nimport panel as pn\n\nfrom .sinewave import SineWave2\n\ndef createApp2():\n    sw \\= SineWave()\n    return pn.Row(sw.param, sw.plot).servable()\n\nWith this as your new file structure:\n\nfastApi\n│   main.py\n│\n└───sliders\n│   │   sinewave.py\n│   │   pn\\_app.py\n│   │\n└───sliders2\n│   │   sinewave2.py\n│   │   pn\\_app.py\n│\n└───templates\n    │   base.html\n\n3.  Create a new html template (ex. app2.html) with the same contents as base.html in `examples/apps/fastApi/templates`\n    \n4.  Import your new app in main.py `from sliders2.pn_app import createApp2`\n    \n5.  Add your new app to the dictionary in pn.serve()\n    \n\n{'/app': createApp, '/app2': createApp2}\n\n7.  Add a new async function to rout your new app (The bottom of `main.py` should look something like this now):\n    \n\n@app.get(\"/\")\nasync def bkapp\\_page(request: Request):\n    script \\= server\\_document('http://127.0.0.1:5000/app')\n    return templates.TemplateResponse(\"base.html\", {\"request\": request, \"script\": script})\n\n@app.get(\"/app2\")\nasync def bkapp\\_page2(request: Request):\n    script \\= server\\_document('http://127.0.0.1:5000/app2')\n    return templates.TemplateResponse(\"app2.html\", {\"request\": request, \"script\": script})\n\npn.serve({'/app': createApp, '/app2': createApp2},\n        port\\=5000, allow\\_websocket\\_origin\\=\\[\"127.0.0.1:8000\"\\],\n         address\\=\"127.0.0.1\", show\\=False)\n\nWith this as your file structure\n\nfastApi\n│   main.py\n│\n└───sliders\n│   │   sinewave.py\n│   │   pn\\_app.py\n│   │\n└───sliders2\n│   │   sinewave2.py\n│   │   pn\\_app.py\n│\n└───templates\n    │   base.html\n    │   app2.html\n\nSliders 2 will be available at `http://127.0.0.1:8000/app2`\n\n## Conclusion[#](#conclusion \"Permalink to this heading\")\n\nThat’s it! You now have embedded panel in FastAPI! You can now build off of this to create your own web app tailored to your needs."
},
{
  "markdown": "Panel generally runs on the Bokeh server which itself runs on Tornado. However, it is also often useful to embed a Panel app in large web application, such as a Django web server. Using Panel with Django requires a bit more work than for notebooks and Bokeh servers.\n\nTo run this example app yourself, you will first need to install django (e.g. `conda install \"django=2\"`).\n\nAdditionally, you should also install the `channels` library (using `pip install channels==2` or `conda install channels=2 -c conda-forge`). This makes it possible to run bokeh without launching a separate Tornado server.\n\nNote that these examples can also be run with django 3 or django 4 (which will require channels 3), by installing the additional `bokeh_django` library. In this case replace all instances of `bokeh.server.django` with `bokeh_django` in the example below.\n\n## Configuration[#](#configuration \"Permalink to this heading\")\n\nBefore we start adding a bokeh app to our Django server we have to set up some of the basic plumbing. In the `examples/apps/django/project` folder we will add some basic configurations.\n\nFirst of all we need to set up a Asynchronous Server Gateway Interface (ASGI) instead of the usual WSGI setup. For this purpose we add `examples/apps/django/project/asgi.py`:\n\nimport os\n\nimport django\n\nfrom channels.routing import get\\_default\\_application\n\nos.environ.setdefault('DJANGO\\_SETTINGS\\_MODULE', 'project.settings')\n\ndjango.setup()\n\napplication \\= get\\_default\\_application()\n\nNext we need to ensure the routing is configured correctly to handle a bokeh server in `examples/apps/django/project/routing.py`:\n\nfrom channels.auth import AuthMiddlewareStack\nfrom channels.routing import ProtocolTypeRouter, URLRouter\nfrom django.apps import apps\n\nbokeh\\_app\\_config \\= apps.get\\_app\\_config('bokeh.server.django')\n\napplication \\= ProtocolTypeRouter({\n    'websocket': AuthMiddlewareStack(URLRouter(bokeh\\_app\\_config.routes.get\\_websocket\\_urlpatterns())),\n    'http': AuthMiddlewareStack(URLRouter(bokeh\\_app\\_config.routes.get\\_http\\_urlpatterns())),\n})\n\nLastly we need to add some configuration to `examples/apps/django/project/settings.py`. As a first step we need to add both `channels` and `bokeh.server.django` to the `INSTALLED_APPS`:\n\nINSTALLED\\_APPS \\= \\[\n    ...,\n    'channels',\n    'bokeh.server.django',\n\\]\n\nSecondly we need to declare the `bokehjsdir` as part of the `STATICFILES_DIRS`:\n\nfrom bokeh.settings import bokehjsdir\n\nSTATICFILES\\_DIRS \\= \\[bokehjsdir()\\]\n\nNow we need to add any templates we have:\n\nTEMPLATES \\= \\[\n    {\n        'DIRS': \\[os.path.join(BASE\\_DIR, 'sliders', 'templates')\\],\n        ...: ...,\n    }\n\\]\n\nand lastly add the app(s) and `static_extensions()` to the `urlpatterns` in the `urls.py` file:\n\nfrom bokeh.server.django import autoload, static\\_extensions\nfrom django.apps import apps\nfrom django.contrib import admin\nfrom django.urls import path, include\nfrom django.contrib.staticfiles.urls import staticfiles\\_urlpatterns\n\nimport sliders.pn\\_app as sliders\\_app\n\npn\\_app\\_config \\= apps.get\\_app\\_config('bokeh.server.django')\n\nurlpatterns \\= \\[\n    path('sliders/', include('sliders.urls')),\n    path('admin/', admin.site.urls),\n\\]\n\nbokeh\\_apps \\= \\[\n    autoload(\"sliders\", sliders\\_app.app),\n\\]\n\nurlpatterns += static\\_extensions()\nurlpatterns += staticfiles\\_urlpatterns()\n\nNow it’s time to configure an actual app and add it to our Django server.\n\n## Sliders app[#](#sliders-app \"Permalink to this heading\")\n\nBased on a standard Django app template, this app shows how to integrate Panel with a Django view\n\nThe sliders app is in `examples/apps/django/sliders`. We will cover the following additions/modifications to the Django app template:\n\n*   `sliders/sinewave.py`: a parameterized object (representing your pre-existing code)\n    \n*   `sliders/pn_app.py`: creates an app function from the SineWave class\n    \n*   `sliders/apps.py`: how a Django app can import and use Bokeh server\n    \n*   `sliders/views.py` and `templates/base.html`: getting the Bokeh app into a Django view\n    \n\n![screenshot of sliders app](https://panel.holoviz.org/_images/django_sliders.png)\n\nTo start with, in `sliders/sinewave.py` we create a parameterized object to serve as a placeholder for your own, existing code:\n\nimport numpy as np\nimport param\nfrom bokeh.models import ColumnDataSource\nfrom bokeh.plotting import figure\n\nclass SineWave(param.Parameterized):\n    offset \\= param.Number(default\\=0.0, bounds\\=(\\-5.0, 5.0))\n    amplitude \\= param.Number(default\\=1.0, bounds\\=(\\-5.0, 5.0))\n    phase \\= param.Number(default\\=0.0, bounds\\=(0.0, 2 \\* np.pi))\n    frequency \\= param.Number(default\\=1.0, bounds\\=(0.1, 5.1))\n    N \\= param.Integer(default\\=200, bounds\\=(0, None))\n    x\\_range \\= param.Range(default\\=(0, 4 \\* np.pi), bounds\\=(0, 4 \\* np.pi))\n    y\\_range \\= param.Range(default\\=(\\-2.5, 2.5), bounds\\=(\\-10, 10))\n\n    def \\_\\_init\\_\\_(self, \\*\\*params):\n        super(SineWave, self).\\_\\_init\\_\\_(\\*\\*params)\n        x, y \\= self.sine()\n        self.cds \\= ColumnDataSource(data\\=dict(x\\=x, y\\=y))\n        self.plot \\= figure(plot\\_height\\=400, plot\\_width\\=400,\n                           tools\\=\"crosshair, pan, reset, save, wheel\\_zoom\",\n                           x\\_range\\=self.x\\_range, y\\_range\\=self.y\\_range)\n        self.plot.line('x', 'y', source\\=self.cds, line\\_width\\=3, line\\_alpha\\=0.6)\n\n    @param.depends('N', 'frequency', 'amplitude', 'offset', 'phase', 'x\\_range', 'y\\_range', watch\\=True)\n    def update\\_plot(self):\n        x, y \\= self.sine()\n        self.cds.data \\= dict(x\\=x, y\\=y)\n        self.plot.x\\_range.start, self.plot.x\\_range.end \\= self.x\\_range\n        self.plot.y\\_range.start, self.plot.y\\_range.end \\= self.y\\_range\n\n    def sine(self):\n        x \\= np.linspace(0, 4 \\* np.pi, self.N)\n        y \\= self.amplitude \\* np.sin(self.frequency \\* x + self.phase) + self.offset\n        return x, y\n\nHowever the app itself is defined we need to configure an entry point, which is a function that accepts a bokeh Document and adds the application to it. In case of the slider app it looks like this:\n\nimport panel as pn\n\nfrom .sinewave import SineWave\n\ndef app(doc):\n    sw \\= SineWave()\n    row \\= pn.Row(sw.param, sw.plot)\n    row.server\\_doc(doc)\n\nNext we create a `views.py` file which returns a view the Django server can render:\n\n\\# Create your views here.\nfrom bokeh.embed import server\\_document\n\nfrom django.http import HttpRequest, HttpResponse\nfrom django.shortcuts import render\n\ndef sliders(request: HttpRequest) \\-> HttpResponse:\n    script \\= server\\_document(request.build\\_absolute\\_uri())\n    return render(request, \"base.html\", dict(script\\=script))\n\nThe `base.html` template should be in the `TEMPLATES` `DIRS` directory we declared in the `settings.py` file above. A very basic template might look like this but can be as complex as you need:\n\n<!DOCTYPE html>\n<html\\>\n  <head\\>\n    <title\\>Panel in Django: sliders</title\\>\n  </head\\>\n  <body\\>\n  {% block content %}\n    {{ script|safe }}\n  {% endblock %}\n  </body\\>\n</html\\>\n\nNext we declare a `urls.py` file to declare the urlpattern where to serve the sliders app to Django:\n\nfrom django.urls import path\n\nfrom . import views\n\napp\\_name \\= 'sliders'\nurlpatterns \\= \\[\n    path('', views.sliders, name\\='sliders'),\n\\]\n\nYou should be able to run this app yourself by changing to the `examples/apps/django` directory and then running: `python manage.py runserver`; then visit http://localhost:8000/sliders in your browser to try the app.\n\n## Multiple apps[#](#multiple-apps \"Permalink to this heading\")\n\nThis is the most basic configuration for a bokeh server. It is of course possible to add multiple apps in the same way and then registering them with Django in the way described in the configuration section above. To see a multi-app Django server have a look at `examples/apps/django_multi_apps` and launch it with `python manage.py runserver` as before."
},
{
  "markdown": "## Deploying Panel Applications[#](#deploying-panel-applications \"Permalink to this heading\")\n\nPanel is built on top of Bokeh, which provides a powerful [Tornado](https://www.tornadoweb.org/en/stable/) based web-server to communicate between Python and the browser. The bokeh server makes it possible to share the app or dashboard you have built locally, your own web server or using any of the numerous cloud providers. In the deployment guides we will go through the details of deploying an app on a local system or cloud provider step-by-step.\n\nFor guides on running and configuring a Panel server see the [server how-to guides](https://panel.holoviz.org/how_to/server/index.html).\n\nAzure\n\n![Azure Logo](https://panel.holoviz.org/_images/azure.png)\n\nBinder\n\n![Binder Logo](https://panel.holoviz.org/_images/binder.png)\n\nGoogle Cloud Platform\n\n![GCP Logo](https://panel.holoviz.org/_images/gcp.png)\n\nHeroku\n\n![Heroku Logo](https://panel.holoviz.org/_images/heroku.png)\n\nHugging Face\n\n![Hugging Face Logo](https://panel.holoviz.org/_images/huggingface.png)\n\n## Other Cloud Providers[#](#other-cloud-providers \"Permalink to this heading\")\n\nPanel can be used with just about any cloud provider that can launch a Python process, including Amazon Web Services (AWS) and DigitalOcean. The Panel developers will add documentation for these services as they encounter them in their own work, but we would greatly appreciate step-by-step instructions from users working on each of these systems."
},
{
  "markdown": "## MyBinder[#](#mybinder \"Permalink to this heading\")\n\nBinder allows you to create custom computing environments that can be shared and used by many remote users. MyBinder is a public, free hosting option, with limited compute and memory resources, which will allow you to deploy your simple app quickly and easily.\n\nHere we will take you through the configuration to quickly set up a GitHub repository with notebooks containing Panel apps for deployment on MyBinder.org. As an example refer to the [Clifford demo repository](https://github.com/pyviz-demos/clifford).\n\n1.  Create a GitHub repository and add the notebook or script you want to serve (in the example repository this is the clifford.ipynb file)\n    \n2.  Add an `environment.yml` which declares a conda environment with the dependencies required to run the app (refer to the [conda documentation](https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#creating-an-environment-file-manually) to see how to declare your dependencies). Add `jupyter_panel_proxy` as a dependency by adding either `conda-forge` or `pyviz` to the channel list:\n    \n\nchannels:\n\\- pyviz\n\npackages:\n\\- jupyter\\-panel\\-proxy\n\n3.  Go to mybinder.org, enter the URL of your GitHub repository and hit `Launch`\n    \n4.  mybinder.org will give you a link to the deployment, e.g. for the example app it is https://mybinder.org/v2/gh/panel-demos/clifford-interact/master. To visit the app simply append `?urlpath=/panel/clifford` where you should replace clifford with the name of the notebook or script you are serving."
},
{
  "markdown": "## Microsoft Azure[#](#microsoft-azure \"Permalink to this heading\")\n\nAzure is popular choice for enterprises often in combination with an automated CI/CD pipeline via Azure DevOps. To get started you can use the [Azure Portal](https://portal.azure.com/) to deploy your app as a Linux Web App via the web based user interface.\n\nThere are a few things you need to be aware of in order to be able to start your app.\n\nPython Web Apps assumes your web app\n\n*   is using `gunicorn` (like Flask or Django) or alternative is started by a `python` command. Thus\n    \n    *   You **cannot use** `panel serve app.py ...` as a _Startup Command_.\n        \n    *   You **can use** `python -m panel serve app.py ...` or `python app.py ...` as a _Startup command_.\n        \n*   is served on address 0.0.0.0 and port 8000\n    \n\nThus you can use\n\npython \\-m panel serve app.py \\--address 0.0.0.0 \\--port 8000 \\--allow-websocket-origin\\=app-name.azurewebsites.net\n\nas a _Startup command_.\n\nYou might be able to use `python app.py` as a _Startup command_ with `.show()` or `panel.serve` inside your `app.py` file, if you can configure the `address`, `port` and `allow-websocket-origin` in the app.py file or via environment variables.\n\nYou also need to configure your app service **general settings** to\n\n*   allow `Web sockets` and\n    \n*   be `Always on`\n    \n\n![](https://panel.holoviz.org/_static/images/sazure_deployment.png)\n\nIf you would like to setup **automated CI/ CD** via Azure DevOps, Azure Pipelines and Docker to a Web App for Containers, you can find a good starting point in the [devops Folder](https://github.com/MarcSkovMadsen/awesome-panel/tree/master/devops) of [awesome-panel.org](https://awesome-panel.org/)."
},
{
  "markdown": "## Google Cloud Platform (GCP)[#](#google-cloud-platform-gcp \"Permalink to this heading\")\n\nFirst, you need to set up your Google cloud account following the [Cloud Run documentation](https://cloud.google.com/run/docs/quickstarts/build-and-deploy/python) or the [App Engine documentation](https://cloud.google.com/appengine/docs/standard/python3/quickstart) depending on whether you would like to deploy your Panel app to Cloud Run or App Engine.\n\nNext, you will need three files:\n\n1.  app.py: This is the Python file that creates the Panel App.\n    \n2.  requirements.txt: This file lists all the package dependencies of our Panel app. Here is an example for requirements.txt:\n    \n\n3.  app.yml (for App Engine) or Dockerfile (for Cloud Run)\n    \n\nHere is an example for app.yml (if you would like to deploy to App Engine):\n\nruntime: python\nenv: flex\nentrypoint: panel serve app.py \\--address 0.0.0.0 \\--port 8080 \\--allow\\-websocket\\-origin\\=\"\\*\"\n\nruntime\\_config:\n  python\\_version: 3\n\nHere is an example for Dockerfile (if you would like to deploy to Cloud Run):\n\n\\# Use the official lightweight Python image.\n# https://hub.docker.com/\\_/python\nFROM python:3.10-slim\n\n# Allow statements and log messages to immediately appear in the Knative logs\nENV PYTHONUNBUFFERED True\n\n# Copy local code to the container image.\nENV APP\\_HOME /app\nWORKDIR $APP\\_HOME\nCOPY . ./\n\n# Install production dependencies.\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Run the web service on container startup.\nCMD panel serve app.py --address 0.0.0.0 --port 8080 --allow-websocket-origin=\"\\*\"\n\nFinally, to deploy a Panel app to App Engine run `gcloud app create` and `gcloud app deploy`.\n\n## Deploying with Cloud Run[#](#deploying-with-cloud-run \"Permalink to this heading\")\n\nTo deploy a Panel app to Cloud Run, run `gcloud run deploy`.\n\nPanel apps use a websocket to the running Bokeh server. Websockets are considered by Cloud Run to be long-running HTTP requests.\n\nIf you deploy a panel app on GCP with Cloud Run, make sure you set up a long request timeout, with CLI parameter `--timeout=...`\n\nThe default timeout is 5 minutes, which makes the panel app lose its websocket connection after this time, leading to unresponsive UI, because Cloud Run considers the websocket as timed-out.\n\nYou can extend the timeout up to 60 minutes.\n\nTo extend the timeout duration, run `gcloud run deploy --timeout 60min`.\n\nFor detailed information and steps, check out this [example](https://towardsdatascience.com/deploy-a-python-visualization-panel-app-to-google-cloud-cafe558fe787?sk=98a75bd79e98cba241cc6711e6fc5be5) on how to deploy a Panel app to App Engine and this [example](https://towardsdatascience.com/deploy-a-python-visualization-panel-app-to-google-cloud-ii-416e487b44eb?sk=aac35055957ba95641a6947bbb436410) on how to deploy a Panel app to Cloud Run.\n\nRegarding Cloud Run, check out the documentation about [Cloud run and WebSockets](https://cloud.google.com/run/docs/triggering/websockets) and about the [`--timeout` option](https://cloud.google.com/run/docs/configuring/request-timeout)"
},
{
  "markdown": "## Heroku[#](#heroku \"Permalink to this heading\")\n\nHeroku makes deployment of arbitrary apps including Panel apps and dashboards very easy and provides a free tier to get you started. This makes it a great starting point for users not too familiar with web development and deployment.\n\nTo get started working with Heroku [signup](https://signup.heroku.com/) for a free account and [download and install the CLI](https://devcenter.heroku.com/articles/getting-started-with-python#set-up). Once you are set up follow the instructions to log into the CLI.\n\n1.  Create a new Git repo (or to follow along clone the [minimal-heroku-demo](https://github.com/pyviz-demos/minimal-heroku-demo) GitHub repo)\n    \n2.  Add a Jupyter notebook or Python script which declares a Panel app or dashboard to the repository.\n    \n3.  Define a requirements.txt containing all the requirements for your app (including Panel itself). For the sample app the requirements are as minimal as:\n    \n\npanel\nhvplot\nscikit\\-learn\n\n3.  Define a `Procfile` which declares the command Heroku should run to serve the app. In the sample app the following command serves the `iris_kmeans.ipynb` example. The websocket origin should match the name of the app on Heroku `app-name.herokuapp.com` which you will declare in the next step:\n    \n\nweb: panel serve --address=\"0.0.0.0\" --port=$PORT iris\\_kmeans.ipynb --allow-websocket-origin=app-name.herokuapp.com\n\n4.  Create a Heroku app using the CLI ensuring that the name matches the URL we declared in the previous step:\n    \n\n5.  Push the app to heroku and wait until it is deployed.\n    \n6.  Visit the app at app-name.herokuapp.com\n    \n\nOnce you have deployed the app you might find that if your app is visited by more than one user at a time it will become unresponsive. In this case you can use the Heroku CLI [to scale your deployment](https://devcenter.heroku.com/articles/getting-started-with-python#scale-the-app)."
},
{
  "markdown": "## Hugging Face[#](#hugging-face \"Permalink to this heading\")\n\nThe guides below assumes you have already signed up and logged into your account at [huggingface.co](https://huggingface.co/).\n\n## 🚀 Deploy Panel on Spaces[#](#deploy-panel-on-spaces \"Permalink to this heading\")\n\nYou can deploy Panel on Spaces with just a few clicks:\n\n[![](https://huggingface.co/datasets/huggingface/badges/raw/main/deploy-to-spaces-lg.svg)](https://huggingface.co/new-space?template=Panel-Org/panel-template)\n\nThere are a few key parameters you need to define: the Owner (either your personal account or an organization), a Space name, and Visibility. In case you intend to execute computationally intensive deep learning models, consider upgrading to a GPU to boost performance.\n\n![](https://panel.holoviz.org/_static/images/hugging_face_space.png)\n\nOnce you have created the space, it will start out in “Building” status, which will change to “Running” once your space is ready to go.\n\n## ⚡️ What will you see?[#](#what-will-you-see \"Permalink to this heading\")\n\nWhen your space is built and ready, you will see this image classification Panel app which will let you fetch a random image and run the OpenAI CLIP classifier model on it. Check out our [blog post](https://blog.holoviz.org/building_an_interactive_ml_dashboard_in_panel.html) for a walkthrough of this app.\n\n![](https://assets.holoviz.org/panel/gifs/hugging_face_template.gif)\n\n## 🛠️ How to customize and make your own app?[#](#how-to-customize-and-make-your-own-app \"Permalink to this heading\")\n\nThe Space template will populate a few files to get your app started:\n\n![](https://panel.holoviz.org/_static/images/hugging_face_space_files.png)\n\nThree files are important:\n\n### 1\\. app.py[#](#app-py \"Permalink to this heading\")\n\nThis file defines your Panel application code. You can start by modifying the existing application or replace it entirely to build your own application. To learn more about writing your own Panel app, refer to the [Panel documentation](https://panel.holoviz.org/).\n\n### 2\\. Dockerfile[#](#dockerfile \"Permalink to this heading\")\n\nThe Dockerfile contains a sequence of commands that Docker will execute to construct and launch an image as a container that your Panel app will run in. Typically, to serve a Panel app, we use the command “panel serve app.py”. In this specific file, we divide the command into a list of strings. Furthermore, we must define the address and port because Hugging Face will expects to serve your application on port 7860. Additionally, we need to specify the “allow-websocket-origin” flag to enable the connection to the server’s websocket.\n\n### 3\\. requirements.txt[#](#requirements-txt \"Permalink to this heading\")\n\nThis file defines the required packages for our Panel app. When using Space, dependencies listed in the requirements.txt file will be automatically installed. You have the freedom to modify this file by removing unnecessary packages or adding additional ones that are required for your application. Feel free to make the necessary changes to ensure your app has the appropriate packages installed."
},
{
  "markdown": "## Embedding state[#](#embedding-state \"Permalink to this heading\")\n\nThis guide addresses how to embed app state for usage entirely within Javascript.\n\n* * *\n\nPanel generally relies on either the Jupyter kernel or a Bokeh Server to be running in the background to provide interactive behavior. However for simple apps with a limited amount of state it is also possible to `embed` all the widget state, allowing the app to be used entirely from within Javascript. To demonstrate this we will create a simple app which simply takes a slider value, multiplies it by 5 and then display the result.\n\nslider \\= pn.widgets.IntSlider(start\\=0, end\\=10)\n\ndef callback(value):\n    return '%d \\* 5 = %d' % (value, value\\*5)\n\nrow \\= pn.Row(slider, pn.bind(callback, slider))\n\nIf we displayed this the normal way it would call back into Python every time the value changed. However, the `.embed()` method will record the state of the app for the different widget configurations.\n\nIf you try the widget above you will note that it only has 3 different states, 0, 5 and 10. This is because by default embed will try to limit the number of options of non-discrete or semi-discrete widgets to at most three values. This can be controlled using the `max_opts` argument to the embed method or you can provide an explicit list of `states` to embed for each widget:\n\nrow.embed(states\\={slider: list(range(0, 12, 2))})\n\nThe full set of options for the embed method include:\n\n*   **`max_states`**: The maximum number of states to embed\n    \n*   **`max_opts`**: The maximum number of states for a single widget\n    \n*   **`states`** (default={}): A dictionary specifying the widget values to embed for each widget\n    \n*   **`json`** (default=True): Whether to export the data to json files\n    \n*   **`save_path`** (default=’./’): The path to save json files to\n    \n*   **`load_path`** (default=None): The path or URL the json files will be loaded from (same as `save_path` if not specified)\n    \n\n*   **`progress`** (default=False): Whether to report progress\n    \n\nAs you might imagine if there are multiple widgets there can quickly be a combinatorial explosion of states so by default the output is limited to about 1000 states. For larger apps the states can also be exported to json files, e.g. if you want to serve the app on a website specify the `save_path` to declare where it will be stored and the `load_path` to declare where the JS code running on the website will look for the files."
},
{
  "markdown": "## Export Apps[#](#export-apps \"Permalink to this heading\")\n\nWhile Panel is primarily a library for building applications [backed by server](https://panel.holoviz.org/how_to/server/index.html) or a [Python process in the browser](https://panel.holoviz.org/how_to/wasm/index.html) it is sometimes useful to export static output, with or without embedded state to add interactivity. This section focuses on exporting Panel as static snapshots, embedding state and accessing the underlying Bokeh models.\n\nEmbed state\n\nHow to embed app state for usage entirely within Javascript.\n\nSave App to File\n\nHow to export an app to a HTML or PNG file.\n\nAccess the Bokeh model\n\nHow to access the underlying Bokeh model of Panel objects."
},
{
  "markdown": "## Save App to File[#](#save-app-to-file \"Permalink to this heading\")\n\nThis guide addresses how to export an app to a HTML or PNG file.\n\n* * *\n\nIn case you don’t need an actual server or simply want to export a static snapshot of a panel app, you can use the `save` method, which allows exporting the app to a standalone HTML or PNG file.\n\nBy default, the HTML file generated will depend on loading JavaScript code for BokehJS from the online `CDN` repository, to reduce the file size. If you need to work in an air-gapped or no-network environment, you can declare that `INLINE` resources should be used instead of `CDN`:\n\nfrom bokeh.resources import INLINE\npanel.save('test.html', resources\\=INLINE)\n\nAdditionally the save method also allows enabling the `embed` option, which, as explained above, will embed the apps state in the app or save the state to json files which you can ship alongside the exported HTML.\n\nFinally, if a ‘png’ file extension is specified, the exported plot will be rendered as a PNG, which currently requires Selenium and PhantomJS to be installed:"
},
{
  "markdown": "## Converting Panel applications[#](#converting-panel-applications \"Permalink to this heading\")\n\nWriting an HTML file from scratch with all the Javascript and Python dependencies and other boilerplate can be quite cumbersome, and requires learning a good bit of HTML. To avoid writing all the boilerplate, Panel provides support for converting an entire application (including Panel templates) to an HTML file, using the `panel convert` command-line interface (CLI). As a starting point create one or more Python scripts or notebook files containing your application. The only requirement is that they import only global modules and packages (relative imports of other scripts or modules is not supported) and that the libraries have been [compiled for Pyodide](https://github.com/pyodide/pyodide/tree/main/packages) or are available as pure-Python wheels from PyPI.\n\nThe `panel convert` command has the following options:\n\npositional arguments:\nDIRECTORY-OR-SCRIPT   The app directories or scripts to serve (serve empty document if not specified)\n\noptions:\n-h, --help            show this help message and exit\n--to TO               The format to convert to, one of 'pyodide' (default), 'pyodide-worker' or 'pyscript'\n--compiled            Whether to use the compiled and faster version of Pyodide.\n--out OUT             The directory to write the file to.\n--title TITLE         A custom title for the application(s).\n--skip-embed          Whether to skip embedding pre-rendered content in the converted file to display content while app is loading.\n--index               Whether to create an index if multiple files are served.\n--pwa                 Whether to add files to serve applications as a Progressive Web App.\n--requirements REQUIREMENTS \\[REQUIREMENTS ...\\]\n                        Explicit requirements to add to the converted file, a single requirements.txt file or a JSON file containing requirements per app. By default requirements are inferred from the code.\n--disable-http-patch  Whether to disable patching http requests using the pyodide-http library.\n--watch               Watch the files\n--num-procs NUM\\_PROCS\n                        The number of processes to start in parallel to convert the apps.\n\n## Example[#](#example \"Permalink to this heading\")\n\nThis example will demonstrate how to _convert_ and _serve_ a basic data app locally.\n\n*   Create a `script.py` file with the following content\n    \n\nimport panel as pn\n\nfrom sklearn.datasets import load\\_iris\nfrom sklearn.metrics import accuracy\\_score\nfrom xgboost import XGBClassifier\n\npn.extension(sizing\\_mode\\=\"stretch\\_width\", template\\=\"fast\")\npn.state.template.param.update(site\\=\"Panel in the Browser\", title\\=\"XGBoost Example\")\n\niris\\_df \\= load\\_iris(as\\_frame\\=True)\n\ntrees \\= pn.widgets.IntSlider(start\\=2, end\\=30, name\\=\"Number of trees\")\n\ndef pipeline(trees):\n    model \\= XGBClassifier(max\\_depth\\=2, n\\_estimators\\=trees)\n    model.fit(iris\\_df.data, iris\\_df.target)\n    accuracy \\= round(accuracy\\_score(iris\\_df.target, model.predict(iris\\_df.data)) \\* 100, 1)\n    return pn.indicators.Number(\n        name\\=\"Test score\",\n        value\\=accuracy,\n        format\\=\"{value}%\",\n        colors\\=\\[(97.5, \"red\"), (99.0, \"orange\"), (100, \"green\")\\],\n    )\n\npn.Column(\n    \"Simple example of training an XGBoost classification model on the small Iris dataset.\",\n    iris\\_df.data.head(),\n    \"Move the slider below to change the number of training rounds for the XGBoost classifier. The training accuracy score will adjust accordingly.\",\n    trees,\n    pn.bind(pipeline, trees),\n).servable()\n\n*   Run `panel convert script.py --to pyodide-worker --out pyodide`\n    \n*   Run `python3 -m http.server` to start a web server locally\n    \n*   Open `http://localhost:8000/pyodide/script.html` to try out the app.\n    \n\nThe app should look like this\n\n![Panel in the browser](https://panel.holoviz.org/_images/pyodide_xgboost_app.png)\n\nYou can now add the `script.html` (and `script.js` file if you used the `pyodide-worker` target) to your Github pages or similar. **no separate server needed!**\n\n## Tips & Tricks for development[#](#tips-tricks-for-development \"Permalink to this heading\")\n\n*   While developing you should run the script locally with _auto reload_: `panel serve script.py --autoreload`.\n    \n*   You can also watch your script for changes and rebuild it if you make an edit with `panel convert ... --watch`\n    \n*   If the converted app does not work as expected, you can most often find the errors in the browser console. [This guide](https://balsamiq.com/support/faqs/browserconsole/) describes how to open the console.\n    \n*   You can find answers to the most frequently asked questions about _Python in the browser_ in the [Pyodide - FAQ](https://pyodide.org/en/stable/usage/faq.html) or the [PyScript FAQ](https://docs.pyscript.net/latest/reference/faq.html). For example the answer to “How can I load external data?”.\n    \n\n## Formats[#](#formats \"Permalink to this heading\")\n\nUsing the `--to` argument on the CLI you can control the format of the file that is generated by `panel convert`. You have three options, each with distinct advantages and disadvantages:\n\n*   **`pyodide`** (default): Run application using Pyodide running in the main thread. This option is less performant than pyodide-worker but produces completely standalone HTML files that do not have to be hosted on a static file server (e.g. Github Pages).\n    \n*   **`pyodide-worker`**: Generates an HTML file and a JS file containing a Web Worker that runs in a separate thread. This is the most performant option, but files have to be hosted on a static file server.\n    \n*   **`pyscript`**: Generates an HTML leveraging PyScript. This produces standalone HTML files containing `<py-env>` and `<py-script>` tags containing the dependencies and the application code. This output is the most readable, and should have equivalent performance to the `pyodide` option.\n    \n\n## Requirements[#](#requirements \"Permalink to this heading\")\n\nThe `panel convert` command will try its best to figure out the requirements of your script based on the imports, which means that in most cases you won’t have to provide the explicit `--requirements` argument. However, if some library uses an optional import that cannot be inferred from the list of imports in your app you will have to provide an explicit list of dependencies. Note that `panel` and its dependencies including NumPy and Bokeh will be added loaded automatically, e.g. the explicit requirements for the app above would look like this:\n\npanel convert script.py \\--to pyodide-worker \\--out pyodide \\--requirements xgboost scikit-learn pandas\n\nAlternatively you may also provide a `requirements.txt` file:\n\npanel convert script.py \\--to pyodide-worker \\--out pyodide \\--requirements requirements.txt\n\n## Index[#](#index \"Permalink to this heading\")\n\nIf you convert multiple applications at once you may want to add an index to be able to navigate between the applications easily. To enable the index simply pass `--index` to the convert command.\n\n## Prerendering[#](#prerendering \"Permalink to this heading\")\n\nIn order to improve the loading experience Panel will pre-render and embed the initial render of the page and replace it with live components once the page is loaded. This is important because Pyodide has to fetch the entire Python runtime and all required packages from a CDN. This can be **very** slow depending on your internet connection. If you want to disable this behavior and render an initially blank page use the `--skip-embed` option. Otherwise Panel will render application using the current Python process (presumably outside the browser) into the HTML file as a “cached” copy of the application for the user to see while the Python runtime is initialized and the actual browser-generated application is ready for interaction.\n\n## Progressive Web Apps[#](#progressive-web-apps \"Permalink to this heading\")\n\nProgressive web applications (PWAs) provide a way for your web apps to behave almost like a native application, both on mobile devices and on the desktop. The `panel convert` CLI has a `--pwa` option that will generate the necessary files to turn your Panel + Pyodide application into a PWA. The web manifest, service worker script and assets such as thumbnails are exported alongside the other HTML and JS files and can then be hosted on your static file host. Note that Progressive web apps must be served via HTTPS to ensure user privacy, security, and content authenticity, including the application itself and all resources it references. Depending on your hosting service, you will have to enable HTTPS yourself. GitHub pages generally make this very simple and provide a great starting point.\n\nOnce generated, you can inspect the `site.webmanifest` file and modify it to your liking, including updating the favicons in the assets directory.\n\nNote\n\nIf you decide to enable the `--pwa` ensure that you also provide a unique `--title`. Otherwise the browser caches storing your apps dependencies will end up overwriting each other.\n\n## Handling HTTP requests[#](#handling-http-requests \"Permalink to this heading\")\n\nBy default Panel will install the [pyodide-http](https://github.com/koenvo/pyodide-http) library which patches `urllib3` and `requests` making it possible to use them within the pyodide process. To disable this behavior use the `--disable-http-patch` CLI option.\n\nNote that making HTTP requests when converting to the `pyodide` or `pyscript` target will block the main browser thread and result in a poor user experience. Therefore we strongly recommend converting to `pyodide-worker` if your app is making synchronous HTTP requests."
},
{
  "markdown": "Panel lets you write dashboards and other applications in Python that are accessed using a web browser. Typically, the Python interpreter runs as a separate Jupyter or Bokeh server process, communicating with JavaScript code running in the client browser. However, **it is now possible to run Python directly in the browser**, with **no separate server needed!**\n\nThe underlying technology involved is called [WebAssembly](https://webassembly.org/) (or WASM). More specifically, [Pyodide](https://pyodide.org/) pioneered the ability to install Python libraries, manipulate the web page’s [DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction) from Python, and execute regular Python code entirely in the browser. A number of libraries have sprung up around Python in WASM, including [PyScript](https://pyscript.net/).\n\nPanel can be run directly in Pyodide and has special support for rendering in PyScript.\n\nThis guide will take you through the process of either\n\n*   Automatically converting Panel applications into a Pyodide/PyScript based application\n    \n*   Manually installing Panel in the browser and using it to render components.\n    \n*   Embedding Panel in your Sphinx documentation.\n    \n*   Setting up a Jupyterlite instance with support for Panel\n    \n\nConvert to WASM.\n\nDiscover how to convert existing Panel applications to WebAssembly.\n\nUse from WASM\n\nDiscover how to set up and use Panel from Pyodide and PyScript.\n\nSphinx Integration\n\nDiscover how to integrate live Panel components in your Sphinx based documentation.\n\nJupyterLite\n\nDiscover how to set up a JupyterLite deployment capable of rendering interactive Panel output.\n\nNote that since Panel is built on Bokeh server and Tornado it is also possible to implement your own authentication independent of the OAuth components shipped with Panel, [see the Bokeh documentation](https://docs.bokeh.org/en/latest/docs/user_guide/server.html#authentication) for further information."
},
{
  "markdown": "## Access the Bokeh Model[#](#access-the-bokeh-model \"Permalink to this heading\")\n\nThis guide addresses how to access the underlying Bokeh model of Panel objects.\n\n* * *\n\nSince Panel is built on top of Bokeh, all Panel objects can easily be converted to a Bokeh model. The `get_root` method returns a model representing the contents of a Panel:\n\nimport panel as pn\n\nmodel \\= pn.Column('# Some markdown').get\\_root()\nmodel\n\nBy default this model will be associated with Bokeh’s `curdoc()`, so if you want to associate the model with some other `Document` ensure you supply it explicitly as the first argument. Once you have access to the underlying Bokeh model you can use all the usual Bokeh utilities such as `components`, `file_html`, or `show`\n\nfrom bokeh.embed import components, file\\_html\nfrom bokeh.io import show\n\nscript, html \\= components(model)\n\nprint(html)\n\n<div id=\"e3752a71-7cd1-4846-8deb-fe3d7b4aa182\" data-root-id=\"p1002\" style=\"display: contents;\"></div>"
},
{
  "markdown": "## Installing Panel in the browser[#](#installing-panel-in-the-browser \"Permalink to this heading\")\n\nTo install Panel in the browser you merely have to use the installation mechanism provided by each supported runtime:\n\n### Pyodide[#](#pyodide \"Permalink to this heading\")\n\nCurrently, the best supported mechanism for installing packages in Pyodide is `micropip`.\n\nTo get started with Pyodide simply follow their [Getting started guide](https://pyodide.org/en/stable/usage/quickstart.html). Note that if you want to render Panel output you will also have to load [Bokeh.js](https://docs.bokeh.org/en/2.4.1/docs/first_steps/installation.html#install-bokehjs:~:text=Installing%20standalone%20BokehJS%C2%B6) and Panel.js from CDN. The most basic pyodide application therefore looks like this:\n\n<!DOCTYPE html>\n<html\\>\n  <head\\>\n    <script src\\=\"https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js\"\\></script\\>\n\n    <script type\\=\"text/javascript\" src\\=\"https://cdn.bokeh.org/bokeh/release/bokeh-3.3.2.js\"\\></script\\>\n    <script type\\=\"text/javascript\" src\\=\"https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.3.2.min.js\"\\></script\\>\n    <script type\\=\"text/javascript\" src\\=\"https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.3.2.min.js\"\\></script\\>\n    <script type\\=\"text/javascript\" src\\=\"https://cdn.jsdelivr.net/npm/@holoviz/panel@1.3.4/dist/panel.min.js\"\\></script\\>\n\n  </head\\>\n  <body\\>\n    <div id\\=\"simple\\_app\"\\></div\\>\n    <script type\\=\"text/javascript\"\\>\n      async function main(){\n        let pyodide \\= await loadPyodide();\n        await pyodide.loadPackage(\"micropip\");\n        const micropip \\= pyodide.pyimport(\"micropip\");\n        await micropip.install(\\[\n          \"https://cdn.holoviz.org/panel/1.3.4/dist/wheels/bokeh-3.3.2-py3-none-any.whl\",\n          \"https://cdn.holoviz.org/panel/1.3.4/dist/wheels/panel-1.3.4-py3-none-any.whl\"\\]\n        )\n        pyodide.runPython(\\`\n          import panel as pn\n\n          pn.extension(sizing\\_mode=\"stretch\\_width\")\n\n          slider = pn.widgets.FloatSlider(start=0, end=10, name='Amplitude')\n\n          def callback(new):\n              return f'Amplitude is: {new}'\n\n          pn.Row(slider, pn.bind(callback, slider)).servable(target='simple\\_app');\n\t    \\`);\n      }\n      main();\n    </script\\>\n  </body\\>\n</html\\>\n\nThe app should look like this\n\n![Panel Pyodide App](https://panel.holoviz.org/_images/pyodide_app_simple.png)\n\nwarn\n\nThe default bokeh and panel packages are very large, therefore we recommend you pip install specialized wheels:\n\nconst bk\\_whl \\= \"https://cdn.holoviz.org/panel/1.3.4/dist/wheels/bokeh-3.3.2-py3-none-any.whl\"\nconst pn\\_whl \\= \"https://cdn.holoviz.org/panel/1.3.4/dist/wheels/panel-1.3.4-py3-none-any.whl\"\nawait micropip.install(bk\\_whl, pn\\_whl)\n\n### PyScript[#](#pyscript \"Permalink to this heading\")\n\nPyScript makes it even easier to manage your dependencies, with a `<py-config>` HTML tag. Simply include `panel` in the list of dependencies and PyScript will install it automatically:\n\n<py-config\\>\npackages = \\[\n  \"panel\",\n  ...\n\\]\n</py-config\\>\n\nOnce installed you will be able to `import panel` in your `<py-script>` tag. Again, make sure you also load Bokeh.js and Panel.js:\n\n<!DOCTYPE html>\n<html\\>\n  <head\\>\n    <script type\\=\"text/javascript\" src\\=\"https://cdn.bokeh.org/bokeh/release/bokeh-3.3.2.js\"\\></script\\>\n    <script type\\=\"text/javascript\" src\\=\"https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.3.2.min.js\"\\></script\\>\n    <script type\\=\"text/javascript\" src\\=\"https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.3.2.min.js\"\\></script\\>\n    <script type\\=\"text/javascript\" src\\=\"https://cdn.jsdelivr.net/npm/@holoviz/panel@1.3.4/dist/panel.min.js\"\\></script\\>\n\n    <link rel\\=\"stylesheet\" href\\=\"https://pyscript.net/releases/2023.05.1/pyscript.css\" />\n    <script defer src\\=\"https://pyscript.net/releases/2023.05.1/pyscript.js\"\\></script\\>\n  </head\\>\n  <body\\>\n    <py-config\\>\n       packages = \\[\n          \"https://cdn.holoviz.org/panel/1.3.4/dist/wheels/bokeh-3.3.2-py3-none-any.whl\",\n          \"https://cdn.holoviz.org/panel/1.3.4/dist/wheels/panel-1.3.4-py3-none-any.whl\"\n       \\]\n    </py-config\\>\n    <div id\\=\"simple\\_app\"\\></div\\>\n    <py-script\\>\n      import panel as pn\n\n      pn.extension(sizing\\_mode=\"stretch\\_width\")\n\n      slider = pn.widgets.FloatSlider(start=0, end=10, name='Amplitude')\n\n      def callback(new):\n         return f'Amplitude is: {new}'\n\n      pn.Row(slider, pn.bind(callback, slider)).servable(target='simple\\_app');\n    </py-script\\>\n  </body\\>\n</html\\>\n\nThe app should look identical to the one above but show a loading spinner while Pyodide is initializing.\n\n## Rendering Panel components in Pyodide or Pyscript[#](#rendering-panel-components-in-pyodide-or-pyscript \"Permalink to this heading\")\n\nRendering Panel components into the DOM is quite straightforward. You can simply use the `.servable()` method on any component and provide a target that should match the `id` of a DOM node:\n\nimport panel as pn\n\nslider \\= pn.widgets.FloatSlider(start\\=0, end\\=10, name\\='Amplitude')\n\ndef callback(new):\n    return f'Amplitude is: {new}'\n\npn.Row(slider, pn.bind(callback, slider)).servable(target\\='simple\\_app');\n\nThis code will render this simple application into the `simple_app` DOM node:\n\n<div id\\=\"simple\\_app\"\\></div\\>\n\nAlternatively you can also use the `panel.io.pyodide.write` function to write into a particular DOM node:\n\nawait pn.io.pyodide.write('simple\\_app', component)"
},
{
  "markdown": "## Embedding in Sphinx documentation[#](#embedding-in-sphinx-documentation \"Permalink to this heading\")\n\nOne more option is to include live Panel examples in your Sphinx documentation using the `nbsite.pyodide` directive.\n\n## Setup[#](#setup \"Permalink to this heading\")\n\nIn the near future we hope to make this a separate Sphinx extension, until then simply install latest nbsite with `pip` or `conda`:\n\nConda\n\nconda install \\-c pyviz nbsite\n\nPip\n\nadd the extension to the Sphinx `conf.py`:\n\nextensions += \\[\n    ...,\n    'nbsite.pyodide'\n\\]\n\n## Configuration[#](#configuration \"Permalink to this heading\")\n\nIn the `conf.py` of your project you can configure the extension in a number of ways by defining an `nbsite_pyodide_conf` dictionary with the following options:\n\n*   `PYODIDE_URL`: The URl to fetch Pyodide from\n    \n*   `autodetect_deps` (default=`True`): Whether to automatically detect dependencies in the executed code and install them.\n    \n*   `enable_pwa` (default=`True`): Whether to add a web manifest and service worker to configure the documentation as a progressive web app.\n    \n*   `requirements` (default=`['panel']`): Default requirements to include (by default this includes just panel.\n    \n*   `scripts`: Scripts to add to the website when a Pyodide cell is first executed.\n    \n*   `setup_code` (default=`''`): Python code to run when initializing the Pyodide runtime.\n    \n\nand then you can use the `pyodide` as an RST directive:\n\n.. pyodide::\n\n   import panel as pn\n\n   slider = pn.widgets.FloatSlider(start=0, end=10, name='Amplitude')\n\n   def callback(new):\n       return f'Amplitude is: {new}'\n\n   pn.Row(slider, pn.bind(callback, slider))\n\n## Examples[#](#examples \"Permalink to this heading\")\n\nThe resulting output looks like this:\n\nslider \\= pn.widgets.FloatSlider(start\\=0, end\\=10, name\\='Amplitude')\n\ndef callback(new):\n    return f'Amplitude is: {new}'\n\npn.Row(slider, pn.bind(callback, slider))\n\nIn addition to rendering Panel components it also renders regular Python types:\n\nand also handles stdout and stderr streams:\n\nimport numpy as np\nfor i in range(10):\n    print(f'Repeat {i}')\n    for i in range(10000):\n        np.random.rand(1000)\n\nRepeat 0\nRepeat 1\nRepeat 2\nRepeat 3\nRepeat 4\nRepeat 5\nRepeat 6\nRepeat 7\nRepeat 8\nRepeat 9\n\nraise ValueError('Encountered an error')\n\nTraceback (most recent call last):\n  File \"/Users/runner/work/panel/panel/panel/io/mime\\_render.py\", line 185, in exec\\_with\\_return\n    exec(compile(last\\_ast, \"<ast>\", \"exec\"), global\\_context)\n  File \"<ast>\", line 1, in <module>\nValueError: Encountered an error\n\nand supports `_repr_<mime>_` methods that are commonly used by the IPython and Jupyter ecosystem:\n\nclass HTML:\n\n    def \\_\\_init\\_\\_(self, html):\n\t    self.html \\= html\n\n    def \\_repr\\_html\\_(self):\n\t    return self.html\n\nHTML('<b>HTML!</b>')\n\n## Usage[#](#usage \"Permalink to this heading\")\n\nThe code cell will display a button to execute the cell, which will warn about downloading the Python runtime on first-click and ask you to confirm whether you want to proceed. It will then download Pyodide, all required packages and finally display the output."
},
{
  "markdown": "## Setting up JupyterLite[#](#setting-up-jupyterlite \"Permalink to this heading\")\n\n[JupyterLite](https://jupyterlite.readthedocs.io/en/latest/) is a JupyterLab distribution built from all the usual components and extensions that come with JupyterLab, but now running entirely in the browser with no external server needed. In order to use Panel in JupyterLite you will have to build your own distribution. We call this [Panelite](https://panelite.holoviz.org/). You can try out Panelite [here](https://panelite.holoviz.org/).\n\nAs a starting point we recommend [this guide](https://jupyterlite.readthedocs.io/en/latest/howto/configure/simple_extensions.html) in the JupyterLite documentation, which will tell you how to set up an environment to begin building JupyterLite.\n\n## Create a `<lite-dir>`[#](#create-a-lite-dir \"Permalink to this heading\")\n\nOnce your environment is set up, create a new directory, which will become the source for your JupyterLite distribution. Once created place the file contents you want to make available in JupyterLite into `<lite-dir>/files`.\n\n## Adding extensions[#](#adding-extensions \"Permalink to this heading\")\n\nIn order for Panel to set up communication channels inside JupyterLite we have to add the `pyviz_comms` extension to the environment. Ensure this package is installed in the environment you are building Panel from, e.g. by running `pip install pyviz_comms` OR by including it in the `requirements.txt` you used when setting up your build environment.\n\n## Optimized wheels (optional)[#](#optimized-wheels-optional \"Permalink to this heading\")\n\nTo get Panel installed inside a Jupyterlite session we have to install it with `piplite`. The default Bokeh and Panel packages are quite large since they contain contents which are needed in a server environment. Since we will be running inside Jupyter these contents are not needed. To bundle the optimized packages download them from the CDN and place them in the `<lite-dir>/pypi` directory. You can download them from the CDN (replacing the latest version numbers):\n\nhttps://cdn.holoviz.org/panel/1.3.4/dist/wheels/bokeh\\-3.3.2\\-py3\\-none\\-any.whl\nhttps://cdn.holoviz.org/panel/1.3.4/dist/wheels/panel\\-1.3.4\\-py3\\-none\\-any.whl\n\n## Building Panelite[#](#building-panelite \"Permalink to this heading\")\n\nFinally `cd` into your `<lite-dir>` and run `jupyter lite build --output-dir ./dist`. This will bundle up the file contents, extensions and wheels into your JupyterLite distribution. You can now easily deploy this to [GitHub pages](https://jupyterlite.readthedocs.io/en/latest/quickstart/deploy.html) or elsewhere."
},
{
  "markdown": "These guides addresses how to migrate from Streamlit to Panel.\n\n![Panel App Example](https://panel.holoviz.org/_images/panel_layout_example.png)\n\nThese guides can also be used as:\n\n*   An alternative _Introduction to Panel_ if you are already familiar with Streamlit.\n    \n*   A means of comparing Streamlit and Panel on a more detailed level, without going into some of the unique functionality that Panel provides.\n    \n\n* * *\n\nGet Started\n\nHow to convert a Hello World application from Streamlit to Panel\n\nDisplay Content\n\nHow to display content with panes\n\nOrganize Components\n\nHow to organize components with layouts\n\nAccept User Input\n\nHow to accept user input with widgets\n\nOrganize and Style\n\nHow to organize and style with templates\n\nShow Activity\n\nHow to show activity with indicators\n\nAdd Interactivity\n\nHow to add interactivity with `pn.bind`.\n\nImprove Performance\n\nHow to improve the performance with caching\n\nSession State\n\nHow to store state for a session\n\nChat Interfaces\n\nHow to create create chat interfaces\n\nMulti Page Apps\n\nHow to create multi page apps\n\nWe hope you will have fun with the Panel framework. If you have usage questions you can post them on [Discourse](https://discourse.holoviz.org/). If you experience issues or have requests for features please post them on [Github](https://github.com/holoviz/panel).\n\nIf you want to support Panel please\n\n*   give a ⭐ on [Github](https://github.com/holoviz/panel) or\n    \n*   donate to [HoloViz](https://holoviz.org/) via [Numfocus](https://numfocus.org/support#donate)"
},
{
  "markdown": "This guide addresses the basics of migrating from Streamlit to Panel.\n\n* * *\n\n## Migration Steps[#](#migration-steps \"Permalink to this heading\")\n\nYou should replace:\n\n*   `import streamlit as st` with `import panel as pn` and\n    \n*   `st.write` with `pn.panel`.\n    \n\nYou will have to:\n\n*   add `pn.extension` to configure your Panel application via optional arguments like `sizing_mode` and `template`.\n    \n*   add `.servable` to the Panel objects you want to include in your apps _template_ when served as a web app.\n    \n\nFor production you will also have to migrate some of your app configuration to `panel serve` [command line options](https://panel.holoviz.org/how_to/server/commandline.html) or environment variables.\n\n## Examples[#](#examples \"Permalink to this heading\")\n\n### Hello World[#](#hello-world \"Permalink to this heading\")\n\nLets show how to convert a _Hello World_ application.\n\n### Streamlit Hello World Example[#](#streamlit-hello-world-example \"Permalink to this heading\")\n\nimport streamlit as st\n\nst.write(\"Hello World\")\n\nYou _run_ and _show_ the app with _autoreload_ via\n\n![Streamlit Hello World Example](https://panel.holoviz.org/_images/streamlit_hello_world.png)\n\n### Panel Hello World Example[#](#panel-hello-world-example \"Permalink to this heading\")\n\nimport panel as pn\n\npn.extension(sizing\\_mode\\=\"stretch\\_width\", template\\=\"bootstrap\")\n\npn.panel(\"Hello World\").servable()\n\nYou _serve_ and _show_ (i.e. open) the app in your browser with _autoreload_ via\n\npanel serve app.py \\--autoreload \\--show\n\n![Panel Hello World Example](https://panel.holoviz.org/_images/panel_hello_world.png)"
},
{
  "markdown": "## Displaying Content with Panes[#](#displaying-content-with-panes \"Permalink to this heading\")\n\nIn Panel the objects that can display your Python objects are called _panes_. With Panels _panes_ you will be able to:\n\n*   Get notifications about interactions like click events on your plots and tables and react to them.\n    \n*   Use unique data visualization ecosystems like HoloViz, ipywidgets and VTK.\n    \n\nCheck out the Panes Section of the [Component Gallery](https://panel.holoviz.org/reference/index.html) for the full list of _panes_.\n\n* * *\n\n## Migration Steps[#](#migration-steps \"Permalink to this heading\")\n\nTo display content in Panel:\n\n*   Replace your Streamlit `st.some_object` _snake cased_ functions with the corresponding Panel `pn.pane.SomeObject` _CamelCased_ classes.\n    \n*   Replace your Streamlit text elements with `pn.pane.Markdown`.\n    \n\nIdentify the relevant Panel _pane_s in the Panes Section of the [Component Gallery](https://panel.holoviz.org/reference/index.html).\n\n## Examples[#](#examples \"Permalink to this heading\")\n\n### Matplotlib Pane[#](#matplotlib-pane \"Permalink to this heading\")\n\n#### Streamlit Matplotlib Example[#](#streamlit-matplotlib-example \"Permalink to this heading\")\n\nimport numpy as np\nimport streamlit as st\n\nimport matplotlib.pyplot as plt\n\ndata \\= np.random.normal(1, 1, size\\=100)\nfig, ax \\= plt.subplots(figsize\\=(8,4))\nax.hist(data, bins\\=20)\n\nst.pyplot(fig)\n\n![Streamlit Matplotlib Example](https://panel.holoviz.org/_images/streamlit_mpl_example.png)\n\n#### Panel Matplotlib Example[#](#panel-matplotlib-example \"Permalink to this heading\")\n\nYou will find Panels _panes_ in the `pn.pane` module.\n\nWe use Matplotlibs `Figure` interface instead of the `pyplot` interface to avoid memory leaks if you forget to close the figure. This is all described in the [Matplotlib Guide](https://panel.holoviz.org/reference/panes/Matplotlib.html).\n\nimport panel as pn\nimport numpy as np\n\nfrom matplotlib.figure import Figure\n\npn.extension(sizing\\_mode\\=\"stretch\\_width\", template\\=\"bootstrap\")\n\ndata \\= np.random.normal(1, 1, size\\=100)\nfig \\= Figure(figsize\\=(8,4))\nax \\= fig.subplots()\nax.hist(data, bins\\=20)\n\npn.pane.Matplotlib(fig, format\\='svg', sizing\\_mode\\='scale\\_both').servable()\n\n![Panel Matplotlib Example](https://panel.holoviz.org/_images/panel_mpl_example.png)\n\n### Markdown Pane[#](#markdown-pane \"Permalink to this heading\")\n\nYou can replace `st.markdown` with [`pn.pane.Markdown`](https://panel.holoviz.org/reference/panes/Markdown.html).\n\nYou can also use the `Markdown` pane to replace the text elements `st.title`, `st.header`, `st.sub_header`, `st.code` and `st.text`.\n\nYou may use the `Markdown` pane to replace `st.divider` and `st.latex`, but you can also use the _specialized_ Panel components [`pn.layout.Divider`](https://panel.holoviz.org/reference/layouts/Divider.html) and [`pn.pane.LaTeX`](https://panel.holoviz.org/reference/panes/LaTeX.html).\n\nHere is how to do it\n\nimport panel as pn\n\npn.extension(\"mathjax\", sizing\\_mode\\=\"stretch\\_width\", template\\=\"bootstrap\")\n\npn.pane.Markdown(r\"\"\"\n\\# Title\n\n\\## Header\n\n\\### Sub Header\n\n\\`\\`\\`python\nimport panel as pn\n\npn.extension()\n\\`\\`\\`\n\n\\---\n\n$$ a + ar + a r^2 + a r^3 + \\\\cdots + a r^{n-1} = \\\\sum\\_{k=0}^{n-1} ar^k = a \\\\left(\\\\frac{1-r^{n}}{1-r}\\\\right)$$\n\"\"\").servable()\n\n![Panel Markdown Example](https://panel.holoviz.org/_images/panel_markdown_example.png)"
},
{
  "markdown": "## Organize Components with Layouts[#](#organize-components-with-layouts \"Permalink to this heading\")\n\n_Layouts_ helps you organize your Panel _components_, i.e. _panes_, _widgets_ and _layouts_.\n\nPanel provides layouts similar to the ones you know from Streamlit and many unique ones too.\n\n* * *\n\n## Migration Steps[#](#migration-steps \"Permalink to this heading\")\n\nTo migrate your layouts to Panel\n\n*   replace your Streamlit `st.some_layout` _snake cased_ function with the corresponding Panel `pn.SomeLayout` _CamelCased_ class.\n    \n\nYou can identify the relevant layout to migrate to in the Layouts Section of the [Component Gallery](https://panel.holoviz.org/reference/index.html).\n\n## Example[#](#example \"Permalink to this heading\")\n\n### Columns Example[#](#columns-example \"Permalink to this heading\")\n\n#### Streamlit Columns Example[#](#streamlit-columns-example \"Permalink to this heading\")\n\nimport streamlit as st\n\ncol1, col2 \\= st.columns(2)\n\nwith col1:\n    st.image(\"https://streamlit.io/images/brand/streamlit-logo-primary-colormark-darktext.png\")\n    st.write(\"# A faster way to build and share data apps\")\n\nwith col2:\n    st.image(\"https://panel.holoviz.org/\\_images/logo\\_horizontal\\_light\\_theme.png\")\n    st.write(\"# The powerful data exploration & web app framework for Python\")\n\n![Streamlit Layout Example](https://panel.holoviz.org/_images/streamlit_layout_example.png)\n\n#### Panel Columns Example[#](#panel-columns-example \"Permalink to this heading\")\n\nYou can access Panel’s _layouts_ in the top-level `pn` namespace:\n\nimport panel as pn\n\npn.extension(sizing\\_mode\\=\"stretch\\_width\", template\\=\"bootstrap\")\n\nrow1 \\= pn.Row(\n    pn.pane.Image(\n        \"https://streamlit.io/images/brand/streamlit-logo-primary-colormark-darktext.png\",\n        align\\=\"center\",\n    ),\n    pn.pane.Image(\n        \"https://panel.holoviz.org/\\_images/logo\\_horizontal\\_light\\_theme.png\",\n        align\\=\"center\",\n    ),\n)\nrow2 \\= pn.Row(\n    \"# A faster way to build and share data apps\",\n    \"# The powerful data exploration & web app framework for Python\",\n)\n\npn.Column(row1, row2).servable()\n\n![Panel Layout Example](https://panel.holoviz.org/_images/panel_layout_example.png)\n\nPanels `Column` and `Row` are _list like_ objects. So you can use familiar methods like `.append`, `.pop` and `[]` indexing when you work with them. For the details check out the [`Column` Guide](https://panel.holoviz.org/reference/layouts/Column.html) and the [`Row` Guide](https://panel.holoviz.org/reference/layouts/Row.html)"
},
{
  "markdown": "In Panel the objects that can accept user inputs are called _widgets_.\n\nPanel provides widgets similar to the ones you know from Streamlit and some unique ones in addition.\n\n* * *\n\n## Migration Steps[#](#migration-steps \"Permalink to this heading\")\n\nTo migrate your app’s input widgets to Panel:\n\n*   Replace your Streamlit `st.some_widget` function with the corresponding Panel `pn.widgets.SomeWidget` class.\n    \n\nYou can identify the corresponding widget via the Widgets Section of the [Component Gallery](https://panel.holoviz.org/reference/index.html).\n\n## Example[#](#example \"Permalink to this heading\")\n\n### Integer Slider Example[#](#integer-slider-example \"Permalink to this heading\")\n\nLets try to migrate an app using integer slider.\n\n#### Streamlit Integer Slider Example[#](#streamlit-integer-slider-example \"Permalink to this heading\")\n\nimport streamlit as st\n\nbins \\= st.slider(value\\=20, min\\_value\\=10, max\\_value\\=30, step\\=1, label\\=\"Bins\")\n\nst.write(bins)\n\n![Streamlit Widgets Example](https://panel.holoviz.org/_images/streamlit_widgets_example.png)\n\n#### Panel Integer Slider Example[#](#panel-integer-slider-example \"Permalink to this heading\")\n\nYou will find Panels input _widgets_ in `pn.widgets` module.\n\nimport panel as pn\n\npn.extension(sizing\\_mode\\=\"stretch\\_width\", template\\=\"bootstrap\")\n\nbins \\= pn.widgets.IntSlider(value\\=20, start\\=10, end\\=30, step\\=1, name\\=\"Bins\")\n\npn.Column(bins, pn.pane.Str(bins)).servable()\n\n![Panel Widgets Example](https://panel.holoviz.org/_images/panel_widgets_example.png)\n\nPlease note that in Panel `bins` is an instance of `IntSlider` and not an integer value. To access the value of `bins` in Panel, you would need to call `bins.value`.\n\nCheck out the [`IntSlider` Guide](https://panel.holoviz.org/reference/widgets/IntSlider.html) if you want to learn more about it."
},
{
  "markdown": "Streamlit always uses the same _template_ with a _main_ and _sidebar_ area to layout and style your app.\n\nWith Panel you have the flexibility to use the _default, blank template_, one of the _built in templates_ or even create your own _custom template_.\n\n* * *\n\n## Migration Steps[#](#migration-steps \"Permalink to this heading\")\n\nWhen migrating you will have to decide which template to use\n\n*   Blank (default)\n    \n*   A built-in template like _vanilla_, _bootstrap_, _material_ or _fast_. See the Templates Section of the [Components Guide](https://panel.holoviz.org/reference/index.html).\n    \n*   A custom template declared using Jinja2 syntax.\n    \n\n## Example[#](#example \"Permalink to this heading\")\n\n### FastListTemplate Example[#](#fastlisttemplate-example \"Permalink to this heading\")\n\nHere is an example with the [`FastListTemplate`](https://panel.holoviz.org/reference/templates/FastListTemplate.html).\n\nfrom asyncio import sleep\nfrom datetime import datetime\n\nimport panel as pn\n\npn.extension(sizing\\_mode\\=\"stretch\\_width\", template\\=\"fast\", theme\\=\"dark\")\n\npn.Column(\n    \"# 📖 Info\",\n    \"\"\"This app is an example of a built in template with a\n\\*sidebar\\*, \\*header\\* and \\*main\\* area.\n\nWe have\n\n\\- set the \\*header\\* background, site and title parameters\n\\- set the default \\*theme\\* to \\`dark\\`\n\nThe app streams the current date and time using an \\*async generator function\\*.\n\"\"\",\n).servable(target\\=\"sidebar\")\n\nasync def stream():\n    for i in range(0, 100):\n        await sleep(0.25)\n        yield datetime.now()\n\npn.Column(\n    \"The current date and time:\", \\*(stream for i in range(5))\n).servable(target\\=\"main\")\n\npn.state.template.param.update(\n    site\\=\"Panel\",\n    title\\=\"Template Example\",\n    header\\_background\\=\"#E91E63\",\n    accent\\_base\\_color\\=\"#E91E63\",\n)\n\n![Panel Template Example](https://assets.holoviz.org/panel/gifs/panel_app_example.gif)"
},
{
  "markdown": "## Add Interactivity with `pn.bind`[#](#add-interactivity-with-pn-bind \"Permalink to this heading\")\n\nBoth Streamlit and Panel are _reactive_ frameworks that _react_ when you interact with your application. But they work very differently:\n\nIn Streamlit\n\n*   your script is run once when a user visits the page.\n    \n*   your script is rerun _top to bottom_ on user interactions.\n    \n\nIn Panel\n\n*   your script is run once when a user visits the page.\n    \n*   only _specific, bound functions_ are rerun on user interactions.\n    \n\nWith Panels interactivity architecture you will be able develop and maintain larger and more complex apps.\n\n* * *\n\n## Introduction[#](#introduction \"Permalink to this heading\")\n\nPanels `pn.bind` provides the functionality to _bind_ functions to widgets. We call the resulting functions _bound functions_.\n\nYou use `pn.bind` as follows\n\n\\# 1. Define your function(s)\ndef my\\_func(value):\n    return ...\n\\# 2. Define your widgets\nslider \\= pn.widgets.IntSlider(...)\n\\# 3. Bind your function to the widget(s)\nmy\\_bound\\_func \\= pn.bind(my\\_func, value\\=slider)\n\\# 4. Layout and display your bound functions and widgets\npn.Column(slider, my\\_bound\\_func)\n\nWhen you have bound and displayed your functions like above, they will automatically be rerun on user interactions.\n\n## Migration Steps[#](#migration-steps \"Permalink to this heading\")\n\nYou should\n\n*   Move your business logic to functions. Business logic can be code to load data, transform data, run calculations, create plots, calculate the mass of the milky way, train models, do inference etc.\n    \n*   Add interactivity by using `pn.bind` to bind your functions to widgets.\n    \n    *   Use generator functions (`yield`) if you want to update the UI multiple times during the functions execution.\n        \n*   Indicate activity using the options described in the [Show Activity Section](https://panel.holoviz.org/how_to/streamlit_migration/activity.html).\n    \n\n## Examples[#](#examples \"Permalink to this heading\")\n\n### Basic Interactivity Example[#](#basic-interactivity-example \"Permalink to this heading\")\n\nThis example will show you how to migrate code that produces a single result and only updates the UI once the code execution has completed.\n\n#### Streamlit Basic Interactivity Example[#](#streamlit-basic-interactivity-example \"Permalink to this heading\")\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport streamlit as st\n\nfrom matplotlib.figure import Figure\n\ndata \\= np.random.normal(1, 1, size\\=100)\nfig \\= Figure(figsize\\=(8,4))\nax \\= fig.subplots()\nbins \\= st.slider(value\\=20, min\\_value\\=10, max\\_value\\=30, step\\=1, label\\=\"Bins\")\nax.hist(data, bins\\=bins)\n\nst.pyplot(fig)\n\n![Streamlit Basic Interactivity Example](https://assets.holoviz.org/panel/gifs/streamlit_interactivity_example.gif)\n\nThe entire script is rerun _top to bottom_ when you change the `bins` slider.\n\n#### Panel Basic Interactivity Example[#](#panel-basic-interactivity-example \"Permalink to this heading\")\n\nimport panel as pn\nimport numpy as np\n\nfrom matplotlib.figure import Figure\n\npn.extension(sizing\\_mode\\=\"stretch\\_width\", template\\=\"bootstrap\")\n\ndef plot(data, bins):\n    fig \\= Figure(figsize\\=(8,4))\n    ax \\= fig.subplots()\n    ax.hist(data, bins\\=bins)\n    return fig\n\ndata \\= np.random.normal(1, 1, size\\=100)\nbins\\_input \\= pn.widgets.IntSlider(value\\=20, start\\=10, end\\=30, step\\=1, name\\=\"Bins\")\nbplot \\= pn.bind(plot, data\\=data, bins\\=bins\\_input)\n\npn.Column(bins, bplot).servable()\n\n![Panel Basic Interactivity Example](https://assets.holoviz.org/panel/gifs/panel_interactivity_example.gif)\n\nWith Panel only the `plot` function is rerun when you change the `bins` slider. This makes your Panel app update much quicker and more smoothly than the Streamlit app.\n\n### Multiple Updates Example[#](#multiple-updates-example \"Permalink to this heading\")\n\nThis example will show you how to migrate code that produces a single result and updates the UI multiple times during the code execution.\n\n#### Streamlit Multiple Updates Example[#](#streamlit-multiple-updates-example \"Permalink to this heading\")\n\nimport random\nimport time\n\nimport streamlit as st\n\ndef calculation\\_a():\n    time.sleep(1.5)\n    return random.randint(0, 100)\n\ndef calculation\\_b():\n    time.sleep(3.5)\n    return random.randint(\\-100, 0)\n\nst.write(\"# Calculation Runner\")\noption \\= st.radio(\"Which calculation would you like to perform?\", (\"A\", \"B\"))\nst.write(\"You chose: \", option)\nif st.button(\"Press to run calculation\"):\n    with st.spinner(\"Running... Please wait!\"):\n        time\\_start \\= time.perf\\_counter()\n        result \\= calculation\\_a() if option \\== \"A\" else calculation\\_b()\n        time\\_end \\= time.perf\\_counter()\n    st.write(f\"\"\"\nDone!\n\nResult: {result}\n\nThe function took {time\\_end \\- time\\_start:1.1f} seconds to complete\n\"\"\"\n    )\nelse:\n    st.write(f\"Calculation {option} did not run yet\")\n\n![Streamlit multiple updates example](https://assets.holoviz.org/panel/gifs/streamlit_runner_example.gif)\n\n#### Panel Multiple Updates Example[#](#panel-multiple-updates-example \"Permalink to this heading\")\n\nWith Panel you will use a _generator function_ to update a component multiple times during code execution.\n\n![Panel Multiple Updates Examples](https://assets.holoviz.org/panel/gifs/panel_runner_example.gif)\n\nYou will notice that we use the `pn.indicators.LoadingSpinner` to indicate the activity.\n\n#### Panel Multiple Updates Alternative Indicator Example[#](#panel-multiple-updates-alternative-indicator-example \"Permalink to this heading\")\n\nAn alternative to using an _indicator_ would be to change the `.disabled` and `.loading` parameters of the `calculation_input` and `run_input`.\n\nimport time\nimport random\n\nimport panel as pn\n\npn.extension(sizing\\_mode\\=\"stretch\\_width\", template\\=\"bootstrap\")\npn.state.template.param.update(site\\=\"Panel\", title\\=\"Calculation Runner\")\n\ndef notify\\_choice(calculation):\n    return f\"You chose: {calculation}\"\n\ndef calculation\\_a():\n    time.sleep(2)\n    return random.randint(0, 100)\n\ndef calculation\\_b():\n    time.sleep(1)\n    return random.randint(0, 100)\n\ndef run\\_calculation(running, calculation):\n    if not running:\n        yield \"Calculation did not run yet\"\n        return \\# This will break the execution\n\n    calc \\= calculation\\_a if calculation \\== \"A\" else calculation\\_b\n    with run\\_input.param.set(loading\\=True):\n        yield pn.indicators.LoadingSpinner(\n            value\\=True, size\\=50, name\\='Running... Please Wait!'\n        )\n        time\\_start \\= time.perf\\_counter()\n        result \\= calc()\n        time\\_end \\= time.perf\\_counter()\n        yield f\"\"\"\n        Done!\n\n        Result: {result}\n\n        The function took {time\\_end \\- time\\_start:1.1f} seconds to complete\n        \"\"\"\n\ncalculation\\_input \\= pn.widgets.RadioBoxGroup(name\\=\"Calculation\", options\\=\\[\"A\", \"B\"\\])\nrun\\_input \\= pn.widgets.Button(\n    name\\=\"Press to run calculation\",\n    icon\\=\"caret-right\",\n    button\\_type\\=\"primary\",\n    width\\=250,\n)\npn.Column(\n    \"Which calculation would you like to perform?\",\n    calculation\\_input,\n    pn.bind(notify\\_choice, calculation\\_input),\n    run\\_input,\n    pn.bind(run\\_calculation, run\\_input, calculation\\_input),\n).servable()\n\n![Panel Multiple Updates Alternative Example](https://assets.holoviz.org/panel/gifs/panel_generator_example.gif)\n\n### Multiple Results Example[#](#multiple-results-example \"Permalink to this heading\")\n\nSometimes you want to output multiple results individually as soon as they are ready.\n\nThis is for example the case for Large (AI) Language Models that generates one token after the other.\n\n#### Streamlit Multiple Results Example[#](#streamlit-multiple-results-example \"Permalink to this heading\")\n\nimport random\nimport time\n\nimport streamlit as st\n\nrun \\= st.button(\"Run model\")\n\ndef model():\n    time.sleep(1)\n    return random.randint(0, 100)\n\nif not run:\n    st.write(\"The model has not run yet\")\nelse:\n    with st.spinner(\"Running...\"):\n        for i in range(0,10):\n            result \\= model()\n            st.write(f\"Result {i}: {result}\")\n\n![Streamlit Multiple Results Example](https://assets.holoviz.org/panel/gifs/streamlit_multi_example.gif)\n\n#### Panel Multiple Results Example[#](#panel-multiple-results-example \"Permalink to this heading\")\n\nWith Panel you will use a _generator function_ to display multiple results from code execution as soon as they are ready.\n\nimport random\nimport time\nimport panel as pn\n\npn.extension(sizing\\_mode\\=\"stretch\\_width\")\n\ndef model():\n    time.sleep(1)\n    return random.randint(0, 100)\n\ndef results(running):\n    if not running:\n        return \"The model has not run yet\"\n\n    for i in range(0, 10):\n        result \\= model()\n        yield f\"Result {i}: {result}\"\n\nrun\\_input \\= pn.widgets.Button(name\\=\"Run model\")\noutput \\= pn.bind(results, run\\_input)\n\npn.Column(\n    run\\_input,\n    pn.panel(output, loading\\_indicator\\=True, generator\\_mode\\='append'),\n).servable()\n\n![Panel Multiple Results Example](https://assets.holoviz.org/panel/gifs/panel_sync_multi_example.gif)"
},
{
  "markdown": "## Show Activity[#](#show-activity \"Permalink to this heading\")\n\nPanel supports many ways of indicating activity\n\n*   Indicators. See the Indicators Section of the [Component Gallery](https://panel.holoviz.org/reference/index.html).\n    \n*   `disabled`/ `loading` parameters on Panel components\n    \n*   `loading_indicator` parameter for `pn.panel` or `pn.config`. If `True` a loading indicator will be shown on your _bound functions_ when they are re-run.\n    \n\n## Example[#](#example \"Permalink to this heading\")\n\nThe example below showcases some of the ways Panel can show activity.\n\nimport panel as pn\n\npn.extension(sizing\\_mode\\=\"stretch\\_width\", template\\=\"bootstrap\")\n\nSPIN\\_CSS \\= \"\"\"\n@keyframes icon-rotation {\n  from {transform: rotate(0deg);} to {transform: rotate(359deg);}\n}\n.bk-TablerIcon {animation: icon-rotation 2s infinite linear;}\n\"\"\"\n\npn.Row(\n    pn.Column(\n        \"## Loading Spinner\",\n        pn.Column(\n            pn.indicators.LoadingSpinner(value\\=False, height\\=25, width\\=25),\n            pn.indicators.LoadingSpinner(\n                value\\=True, height\\=25, width\\=25, color\\=\"secondary\"\n            ),\n        ),\n    ),\n    pn.Column(\n        \"## Progress\",\n        pn.Column(\n            pn.indicators.Progress(\n                name\\=\"Progress\", value\\=20, width\\=150, bar\\_color\\=\"secondary\"\n            ),\n            pn.indicators.Progress(\n                name\\=\"Progress\", active\\=True, width\\=150, bar\\_color\\=\"secondary\"\n            ),\n        ),\n    ),\n    pn.Column(\n        \"## Disabled\",\n        pn.Column(\n            pn.widgets.Button(name\\=\"Loading\", icon\\=\"progress\", disabled\\=True),\n            pn.widgets.Button(\n                name\\=\"Loading\", icon\\=\"progress\", disabled\\=True, stylesheets\\=\\[SPIN\\_CSS\\]\n            ),\n        ),\n    ),\n    pn.Column(\n        \"## Loading\",\n        pn.Column(\n            pn.widgets.Button(name\\=\"Loading\", loading\\=True, button\\_type\\=\"primary\"),\n            pn.WidgetBox(\n                pn.widgets.Checkbox(name\\=\"Checked\", value\\=True),\n                pn.widgets.Button(name\\=\"Submit\", button\\_type\\=\"primary\"),\n                loading\\=True, margin\\=(10,10),\n            ),\n        ),\n    ),\n).servable()\n\n![Show Activity](https://user-images.githubusercontent.com/42288570/246325570-11484dd6-4523-401f-b709-6c0cc7996410.gif)\n\nTo learn more about migrating activity indicators check out the [Migrate Streamlit Interactivity Guide](https://panel.holoviz.org/how_to/streamlit_migration/interactivity.html)."
},
{
  "markdown": "One of the key concepts in Streamlit is _caching_.\n\nIn Streamlit\n\n*   your script is run once when a user visits the page.\n    \n*   your script is rerun _top to bottom_ on user interactions.\n    \n\nThus with Streamlit you _must use_ caching to make the user experience nice and fast.\n\nIn Panel\n\n*   your script is run once when a user visits the page.\n    \n*   only _specific, bound functions_ are rerun on user interactions.\n    \n\nThus with Panel you _may use_ caching to to make the user experience nice and fast.\n\nIn Panel you use `pn.cache` to speed up your apps. Check out the [Cache How-To Guides](https://panel.holoviz.org/how_to/caching/index.html) for more details.\n\n* * *\n\n## Migration Steps[#](#migration-steps \"Permalink to this heading\")\n\nTo migrate\n\n*   replace `st.cache_data` and `st.cache_resource` with `pn.cache` on long running\n    \n    *   functions that are run when your page loads\n        \n    *   _bound functions_\n        \n\n## Example[#](#example \"Permalink to this heading\")\n\n### Cache Example[#](#cache-example \"Permalink to this heading\")\n\n#### Streamlit Cache Example[#](#streamlit-cache-example \"Permalink to this heading\")\n\nfrom time import sleep\n\nimport numpy as np\nimport streamlit as st\nfrom matplotlib.figure import Figure\n\n@st.cache\\_data\ndef get\\_data():\n    print(\"get\\_data func\")\n    sleep(1.0)\n    return np.random.normal(1, 1, size\\=100)\n\n@st.cache\\_data(hash\\_funcs\\={Figure: lambda \\_: None})\ndef plot(data, bins):\n    print(\"plot func\", bins)\n    sleep(2)\n    fig \\= Figure(figsize\\=(8,4))\n    ax \\= fig.subplots()\n    ax.hist(data, bins\\=bins)\n    return fig\n\ndata \\= get\\_data()\nbins \\= st.slider(value\\=20, min\\_value\\=10, max\\_value\\=30, step\\=1, label\\=\"Bins\")\nst.pyplot(plot(data, bins))\n\nI’ve added `sleep` statements to make the functions more _expensive_.\n\n#### Panel Cache Example[#](#panel-cache-example \"Permalink to this heading\")\n\nfrom time import sleep\n\nimport numpy as np\nimport panel as pn\nfrom matplotlib.figure import Figure\n\n@pn.cache\ndef get\\_data():\n    print(\"get\\_data func\")\n    sleep(1.0)\n    return np.random.normal(1, 1, size\\=100)\n\n@pn.cache\ndef plot(data, bins):\n    print(\"plot func\", bins)\n    sleep(2)\n    fig \\= Figure(figsize\\=(8,4))\n    ax \\= fig.subplots()\n    ax.hist(data, bins\\=bins)\n    return fig\n\npn.extension(sizing\\_mode\\=\"stretch\\_width\", template\\=\"bootstrap\")\n\ndata \\= get\\_data()\nbins \\= pn.widgets.IntSlider(value\\=20, start\\=10, end\\=30, step\\=1)\nbplot \\= pn.bind(plot, data, bins)\npn.Column(bins, pn.panel(bplot, loading\\_indicator\\=True)).servable()\n\n![Panel Cache Example](https://assets.holoviz.org/panel/gifs/panel_cache_example.gif)\n\nYou can also use `pn.cache` as an function. I.e. as\n\nUsing `pn.cache` as a function can help you keep your business logic (`data` and `plot` function) and your caching logic (when and how to apply caching) separate. This can help you reusable and maintainable code."
},
{
  "markdown": "## Session State[#](#session-state \"Permalink to this heading\")\n\nSession state was added to Streamlit as an after thought to enable sharing variables between re-runs and across apps inside a multipage app.\n\nPanels execution model is very different and session state can be handled automatically by storing variables in the applications namespace.\n\n* * *\n\n## Migration Steps[#](#migration-steps \"Permalink to this heading\")\n\n*   Move your session state to the applications namespace, i.e. to variables defined in your application file.\n    \n\n## Example[#](#example \"Permalink to this heading\")\n\n### Dynamic Layout Example[#](#dynamic-layout-example \"Permalink to this heading\")\n\n#### Streamlit Dynamic Layout Example[#](#streamlit-dynamic-layout-example \"Permalink to this heading\")\n\nimport random\nfrom uuid import uuid4\n\nimport streamlit as st\n\nst.session\\_state.setdefault(\"rows\", {})\n\ndef create\\_row(hex\\_id\\=None):\n    if hex\\_id is None:\n        hex\\_id \\= uuid4().hex\n        value \\= random.randint(0, 100)\n        st.session\\_state.rows\\[hex\\_id\\] \\= value\n    else:\n        value \\= st.session\\_state.rows\\[hex\\_id\\]\n\n    st.number\\_input(\"Enter a number\", value\\=value, key\\=f\"num\\_{hex\\_id}\")\n\nst.title(\"Dynamically add new rows\")\n\nbutton\\_cols \\= st.columns(2)\nwith button\\_cols\\[0\\]:\n    add\\_row \\= st.button(\"Add new row\", use\\_container\\_width\\=True)\nwith button\\_cols\\[1\\]:\n    clear\\_rows \\= st.button(\"Clear all rows\", use\\_container\\_width\\=True)\n\nif clear\\_rows:\n    st.session\\_state.rows \\= {}\n\nfor hex\\_id in st.session\\_state.rows.keys():\n    create\\_row(hex\\_id\\=hex\\_id)\n\nif add\\_row:\n    create\\_row()\n\n![Streamlit Session State Example](https://panel.holoviz.org/_images/streamlit_dymamic_layout.png)\n\nWith Streamlit you need session state to keep track of the dynamically created `rows`.\n\n#### Panel Dynamic Layout Example[#](#panel-dynamic-layout-example \"Permalink to this heading\")\n\nimport random\n\nimport panel as pn\n\npn.extension(sizing\\_mode\\=\"stretch\\_width\", template\\='bootstrap')\n\ndef create\\_row(event):\n    value \\= random.randint(0, 100)\n    row \\= pn.widgets.TextInput(name\\=\"Enter a number\", value\\=str(value))\n    rows.append(row)\n\nrows \\= pn.Column()\nadd\\_row \\= pn.widgets.Button(name\\=\"Add new row\", on\\_click\\=create\\_row)\nclear\\_rows \\= pn.widgets.Button(name\\=\"Clear all rows\", on\\_click\\=lambda event: rows.clear())\n\npn.Column(\n    \"# Dynamically add new rows\",\n    pn.Row(add\\_row, clear\\_rows),\n    rows\n).servable()\n\nAs the Panel script is only executed once per session the `rows` objects will keep track of your _session state_.\n\n![Panel Session State Example](https://panel.holoviz.org/_images/panel_dynamic_layout.png)"
},
{
  "markdown": "## Multi Page Apps[#](#multi-page-apps \"Permalink to this heading\")\n\nMigrating your Streamlit multi page app to Panel is simple. In Panel each page is simply a file that you _serve_\n\npanel serve home.py page1.py page2.ipynb\n\nYou can specify the _home_ page with the `--index` flag.\n\npanel serve home.py page1.py page2.ipynb \\--index\\=home"
},
{
  "markdown": "## How-to[#](#how-to \"Permalink to this heading\")\n\nThe Panel How-to guides provide step by step recipes for solving essential problems and tasks that arise during your work. They assume that you’ve completed the Getting Started material and therefore already have some knowledge of how Panel works. There is no order to the guides, other than any potential prerequisites listed at the top of a page. Jump to the topic that is relevant to you now.\n\n## Prepare to develop[#](#prepare-to-develop \"Permalink to this heading\")\n\nDevelop in a notebook\n\nHow to effectively develop apps in a notebook environment.\n\nDevelop in an editor\n\nHow to effectively develop apps in a Python or Markdown file.\n\n## Build apps[#](#build-apps \"Permalink to this heading\")\n\nConstruct components\n\nHow to construct and customize individual components like an image or slider widget.\n\nArrange Components\n\nHow to arrange and size components on the page.\n\nStyle components\n\nHow to apply designs, themes and custom styling to components to achieve a polished look and feel.\n\nAdd interactivity\n\nHow to link add interactivity to your applications using reactive APIs.\n\nApply templates\n\nHow to use a Template to customize the look and feel of a deployed Panel app.\n\n## Use specialized UIs and APIs[#](#use-specialized-uis-and-apis \"Permalink to this heading\")\n\nBuild a sequential UI\n\nHow to build a Panel Pipeline that connects multiple panels into a sequential user interface.\n\nBuild custom components\n\nHow to extend Panel by building custom components.\n\nGenerate UIs from declared parameters (`Declarative API`)\n\nHow to use Parameterized classes with Panel to generate UIs without writing GUI code.\n\nExplicitly link parameters (`Callbacks API`)\n\nHow to link the parameters of Panel components in Python and Javascript.\n\n## Manage session tasks[#](#manage-session-tasks \"Permalink to this heading\")\n\nRegister session callbacks\n\nHow to set up callbacks on session related events (e.g. on page load or when a session is destroyed) and define periodic tasks.\n\nAccess session state\n\nHow to access and manipulate state related to the user session, HTTP request and URL arguments.\n\n## Test and debug[#](#test-and-debug \"Permalink to this heading\")\n\nEnable profiling and debugging\n\nHow to profile and debug your application using the admin dashboard and other tools.\n\nSet up testing for an application\n\nHow to set up unit tests, UI tests and load testing to ensure your applications are (and stay) robust and scalable.\n\n## Share your work[#](#share-your-work \"Permalink to this heading\")\n\nConfigure the server\n\nHow to configure the Panel server.\n\nIntegrate with other servers\n\nHow to integrate Panel in other application based on Flask, FastAPI or Django.\n\nDeploy applications\n\nHow to deploy Panel applications to various cloud providers (e.g. Azure, GCP, AWS etc.)\n\nExport apps\n\nHow to export and save Panel applications as static files.\n\nRun panel in WebAssembly\n\nHow to run Panel applications entirely in the browser using WebAssembly (Wasm), Pyodide, and PyScript.\n\n## Migrate to Panel[#](#migrate-to-panel \"Permalink to this heading\")\n\nMigrate from Streamlit\n\n[![https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)\n\nHow to migrate existing Streamlit applications to Panel."
},
{
  "markdown": "## Develop in a notebook[#](#develop-in-a-notebook \"Permalink to this heading\")\n\nOne of the main design goals for Panel was to make it seamless to work across development environments. This section will provide simple how-to guides on how to develop with Panel in an notebook environment.\n\nDisplay output in notebooks\n\nHow to display output in Jupyter and non-Jupyter based notebook environments.\n\nPreview apps in JupyterLab\n\nHow to use the Preview functionality in JupyterLab to rapidly develop applications.\n\nDevelop in other notebook environments\n\nHow to develop apps in Google Colab, VSCode notebook, nteract, and other notebook environments."
},
{
  "markdown": "This guide addresses how to develop apps in Google Colab, VSCode, nteract, and other environments.\n\n* * *\n\n## Google Colab[#](#google-colab \"Permalink to this heading\")\n\nIn the Google Colaboratory notebook, first make sure to load the `pn.extension()`. Panel objects will then render themselves if they are the last item in a notebook cell. Please note that in Colab rendering for each notebook cell is isolated, which means that every cell must reload the Panel extension code separately. This will result in somewhat slower and larger notebook than with other notebook technologies.\n\n## VSCode notebook[#](#vscode-notebook \"Permalink to this heading\")\n\nVisual Studio Code (VSCode) versions 2020.4.74986 and later support ipywidgets, and Panel objects can be used as ipywidgets since Panel 0.10 thanks to `jupyter_bokeh`, which means that you can now use Panel components interactively in VSCode. Ensure you install `jupyter_bokeh` with `pip install jupyter_bokeh` or `conda install -c bokeh jupyter_bokeh` and then enable the extension with `pn.extension()`.\n\nSee also the [How-To Configure VS Code Guide](https://panel.holoviz.org/how_to/editor/vscode_configure.html).\n\n## nteract and other ipywidgets notebooks[#](#nteract-and-other-ipywidgets-notebooks \"Permalink to this heading\")\n\nIn other notebook environments that support rendering ipywidgets interactively, such as nteract, you can use the same underlying ipywidgets support as for vscode: Install `jupyter_bokeh` and then use `pn.extension(comms='ipywidgets')`.\n\n## Other environments[#](#other-environments \"Permalink to this heading\")\n\nIf your development environment offers embedded Python processes but does not support ipywidgets or Jupyter “comms” (communication channels), you will notice that some or all interactive functionality is missing. Some widgets that operate only in JavaScript will work fine, but others require communication channels between JavaScript and Python. In such cases you can either request ipywidgets or Panel support from the editor or environment, or else use the Editor + Server approach above."
},
{
  "markdown": "## Develop in an editor[#](#develop-in-an-editor \"Permalink to this heading\")\n\nOne of the main design goals for Panel was to make it seamless to work across development environments. This section will provide simple how-to guides on how to develop with Panel in an editor environment with either a Python or Markdown file.\n\nDevelop apps in an editor\n\nHow to rapidly develop a Panel application in your favorite IDE or editor.\n\nDebug apps in an editor\n\nHow to debug a Panel application in your favorite IDE or editor.\n\nConfigure VS Code\n\nHow to configure VS Code to work efficiently with Panel\n\nWrite apps in Markdown\n\nHow to write Panel applications inside Markdown files."
},
{
  "markdown": "## Display Output in Notebooks[#](#display-output-in-notebooks \"Permalink to this heading\")\n\nThis guide addresses how to display output in Jupyter and non-Jupyter based notebook environments.\n\n* * *\n\nOnce you have installed Panel it should automatically set up class Jupyter notebook and JupyterLab extensions for rendering Panel output and configuring communication channels to ensure the rendered output syncs bi-directionally with the Python process.\n\n## Loading the extension[#](#loading-the-extension \"Permalink to this heading\")\n\nThe first step when working in a notebook environment should always be to load the `panel.extension`:\n\nimport panel as pn\n\npn.extension()\n\nThe extension ensures that all required Javascript and CSS resources are added to your notebook environment. If you are going to be using any custom extensions, such as [Vega](https://panel.holoviz.org/reference/panes/Vega.html) or [Tabulator](https://panel.holoviz.org/reference/widgets/Tabulator.html) you must ensure that you initialize these as well:\n\npn.extension('vega', 'tabulator')\n\n## Display output[#](#display-output \"Permalink to this heading\")\n\nOne of the major benefits of notebook environments is that they support rich output. This means that if you place an object with rich output at the end of a cell the notebook will figure out how to render the rich representation. Panel uses this mechanism to ensure that all components return a rich representation:\n\npane \\= pn.panel('<marquee>Here is some custom HTML</marquee>')\n\npane\n\nTo instead see a textual representation of the component, you can use the `print` function on any Panel object:\n\nMarkdown(str)\n\n### The `display` function[#](#the-display-function \"Permalink to this heading\")\n\nAttention\n\nThe `display` function is an IPython built-in and will only work in notebooks.\n\nTo avoid having to put a Panel on the last line of a notebook cell, e.g. to display it from inside a function call, you can use the IPython built-in `display` function:\n\ndef display\\_marquee(text):\n    display(pn.panel('<marquee>{text}</marquee>'.format(text\\=text)))\n\ndisplay\\_marquee('This Panel was displayed from within a function')\n\n## Render as ipywidget[#](#render-as-ipywidget \"Permalink to this heading\")\n\nWhile Jupyter Notebook and JupyterLab support rendering arbitrary MIME types many other notebook environments (such as VSCode notebooks) only support bi-directional communication channels when rendering an IPyWidget. Therefore Panel provides a compatibility wrapper that makes it possible to wrap a Panel component in an IPywidget. To enable ipywidgets support globally you can set the `comms` option:\n\npn.extension(comms\\='ipywidgets')\n\\# or\npn.config.comms \\= 'ipywidgets'\n\nNote that this happens automatically when running Panel inside VSCode and Google Colab but may be needed in other notebook environments. This global setting can also be useful when trying to serve an entire notebook using [Voilà](https://github.com/voila-dashboards/voila). Alternatively, we can convert individual objects to an ipywidget one at a time using the `pn.ipywidget()` function:\n\nipywidget \\= pn.ipywidget(pane)\nipywidget\n\nThis approach also allows combining a Panel object with any other Jupyter-widget–based model:\n\nfrom ipywidgets import Accordion\nAccordion(children\\=\\[pn.ipywidget(pane)\\])\n\nTo use Panel’s ipywidgets support in JupyterLab, the following extensions have to be installed:\n\njupyter labextension install @jupyter\\-widgets/jupyterlab\\-manager\njupyter labextension install @bokeh/jupyter\\_bokeh\n\nAdditionally the `jupyter_bokeh` package should be installed using either pip:\n\npip install jupyter\\_bokeh\n\nor using conda:\n\nconda install \\-c bokeh jupyter\\_bokeh"
},
{
  "markdown": "This guide addresses how to rapidly develop a Panel application in your favorite IDE or editor.\n\n* * *\n\nYou can edit your Panel code as a `.py` file in any text editor, marking the objects you want to render as `.servable()`. For example:\n\napp.py\n\nimport panel as pn\nimport hvplot.pandas\nfrom bokeh.sampledata.autompg import autompg\n\ncolumns \\= list(autompg.columns\\[:\\-2\\])\n\nx \\= pn.widgets.Select(value\\='mpg', options\\=columns, name\\='x')\ny \\= pn.widgets.Select(value\\='hp', options\\=columns, name\\='y')\ncolor \\= pn.widgets.ColorPicker(name\\='Color', value\\='#AA0505')\n\npn.Row(\n    pn.Column('## MPG Explorer', x, y, color),\n    pn.bind(autompg.hvplot.scatter, x, y, c\\=color)\n).servable()\n\nThen, from the command line, launch a server with:\n\npanel serve app.py \\--show \\--autoreload\n\nNote\n\nThe `--show` flag will open a browser tab with the live app and the `--autoreload` flag ensures that the app reloads whenever you make a change to the Python source.\n\nIn VS Code this looks like\n\n![VS Code Script](https://panel.holoviz.org/_images/vscode-script.png)\n\nThe app looks like\n\n![App Developed in an Editor](https://panel.holoviz.org/_images/editor_server_app.png)"
},
{
  "markdown": "## Write apps in Markdown[#](#write-apps-in-markdown \"Permalink to this heading\")\n\nThis guide addresses how to write Panel apps inside Markdown files.\n\n* * *\n\nPanel applications can be written as Python scripts (`.py`), notebooks (`.ipynb`) and also Markdown files (`.md`). This is particularly useful when writing applications that serve both as documentation and as an application, e.g. when writing a demo.\n\nTo begin simply create a Markdown file with the `.md` file extension, e.g. `app.md`. Once created give your app a title:\n\nBefore adding any actual content add a code block with any imports your application needs. The code block should have one of two type declarations, either `python` or `{pyodide}`. The latter is useful if you also want to use [the Sphinx Pyodide integration](https://panel.holoviz.org/how_to/wasm/sphinx.html). In this case we will simply declare a `python` code block that imports Panel and calls the extension with a specific template:\n\n\\`\\`\\`python\nimport panel as pn\n\npn.extension(template\\='fast')\n\\`\\`\\`\n\nOnce we have initialized the extension any subsequent Markdown will be rendered as part of the application, e.g. we can put some description in our application. If you also want to render some Python code without having Panel interpret it as code, use `.py` as the language declaration:\n\nThis application provides a minimal example demonstrating how to write an app in a Markdown file.\n\n\\`\\`\\`.py\nwidget = pn.widgets.TextInput(value='world')\n\ndef hello\\_world(text):\n    return f'Hello {text}!'\n\npn.Row(widget, pn.bind(hello\\_world, widget)).servable()\n\\`\\`\\`\n\nNow we can add some actual Panel contents, again inside a `python` code block:\n\n\\`\\`\\`python\nwidget \\= pn.widgets.TextInput(value\\='world')\n\ndef hello\\_world(text):\n    return f'Hello {text}!'\n\npn.Row(widget, pn.bind(hello\\_world, widget)).servable()\n\\`\\`\\`\n\nTo put it all together, here is what our app looks like:\n\napp.md\n\n\\# My App\n\n\\`\\`\\`python\nimport panel as pn\n\npn.extension(template\\='fast')\n\\`\\`\\`\n\nThis application provides a minimal example demonstrating how to write an app in a Markdown file.\n\n\\`\\`\\`.py\nwidget = pn.widgets.TextInput(value='world')\n\ndef hello\\_world(text):\n    return f'Hello {text}!'\n\npn.Row(widget, pn.bind(hello\\_world, widget)).servable()\n\\`\\`\\`\n\n\\`\\`\\`python\nwidget = pn.widgets.TextInput(value='world')\n\ndef hello\\_world(text):\n    return f'Hello {text}!'\n\npn.Row(widget, pn.bind(hello\\_world, widget)).servable()\n\\`\\`\\`\n\nThen, from the command line, launch a server with:\n\npanel serve app.md \\--show \\--autoreload\n\n![The rendered Panel application written as a Markdown file.](https://panel.holoviz.org/_images/markdown_sample.png)"
},
{
  "markdown": "## How-to[#](#how-to \"Permalink to this heading\")\n\nThe Panel How-to guides provide step by step recipes for solving essential problems and tasks that arise during your work. They assume that you’ve completed the Getting Started material and therefore already have some knowledge of how Panel works. There is no order to the guides, other than any potential prerequisites listed at the top of a page. Jump to the topic that is relevant to you now.\n\n## Prepare to develop[#](#prepare-to-develop \"Permalink to this heading\")\n\nDevelop in a notebook\n\nHow to effectively develop apps in a notebook environment.\n\nDevelop in an editor\n\nHow to effectively develop apps in a Python or Markdown file.\n\n## Build apps[#](#build-apps \"Permalink to this heading\")\n\nConstruct components\n\nHow to construct and customize individual components like an image or slider widget.\n\nArrange Components\n\nHow to arrange and size components on the page.\n\nStyle components\n\nHow to apply designs, themes and custom styling to components to achieve a polished look and feel.\n\nAdd interactivity\n\nHow to link add interactivity to your applications using reactive APIs.\n\nApply templates\n\nHow to use a Template to customize the look and feel of a deployed Panel app.\n\n## Use specialized UIs and APIs[#](#use-specialized-uis-and-apis \"Permalink to this heading\")\n\nBuild a sequential UI\n\nHow to build a Panel Pipeline that connects multiple panels into a sequential user interface.\n\nBuild custom components\n\nHow to extend Panel by building custom components.\n\nGenerate UIs from declared parameters (`Declarative API`)\n\nHow to use Parameterized classes with Panel to generate UIs without writing GUI code.\n\nExplicitly link parameters (`Callbacks API`)\n\nHow to link the parameters of Panel components in Python and Javascript.\n\n## Manage session tasks[#](#manage-session-tasks \"Permalink to this heading\")\n\nRegister session callbacks\n\nHow to set up callbacks on session related events (e.g. on page load or when a session is destroyed) and define periodic tasks.\n\nAccess session state\n\nHow to access and manipulate state related to the user session, HTTP request and URL arguments.\n\n## Test and debug[#](#test-and-debug \"Permalink to this heading\")\n\nEnable profiling and debugging\n\nHow to profile and debug your application using the admin dashboard and other tools.\n\nSet up testing for an application\n\nHow to set up unit tests, UI tests and load testing to ensure your applications are (and stay) robust and scalable.\n\n## Share your work[#](#share-your-work \"Permalink to this heading\")\n\nConfigure the server\n\nHow to configure the Panel server.\n\nIntegrate with other servers\n\nHow to integrate Panel in other application based on Flask, FastAPI or Django.\n\nDeploy applications\n\nHow to deploy Panel applications to various cloud providers (e.g. Azure, GCP, AWS etc.)\n\nExport apps\n\nHow to export and save Panel applications as static files.\n\nRun panel in WebAssembly\n\nHow to run Panel applications entirely in the browser using WebAssembly (Wasm), Pyodide, and PyScript.\n\n## Migrate to Panel[#](#migrate-to-panel \"Permalink to this heading\")\n\nMigrate from Streamlit\n\n[![https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)\n\nHow to migrate existing Streamlit applications to Panel."
},
{
  "markdown": "## Create Components[#](#create-components \"Permalink to this heading\")\n\nPanel components are the building blocks and visual layouts of your app or dashboard. These How-to pages provide solutions for common tasks related to creating, using and updating components.\n\nConstruct Panes\n\nHow to construct Pane objects for displaying visible components.\n\nAccess Pane Type\n\nHow to access Pane Type.\n\nAccess Widget Values\n\nHow to access and set widget values.\n\nAdd or Remove Components\n\nHow to add or remove components from a panel."
},
{
  "markdown": "## Construct Panes[#](#construct-panes \"Permalink to this heading\")\n\nThis guide addresses how to construct Pane objects for displaying visible components.\n\n* * *\n\nThere are two main ways to construct a pane - explicitly or automatically.\n\nTo explicitly construct a pane, use one of the pane types listed in the component gallery. For example, you can create a Markdown pane as follows:\n\nimport panel as pn\npn.extension() \\# for notebook\n\npn.pane.Markdown('''\n\\# H1\n\\## H2\n\\### H3\n''')\n\nAlternatively, you can create a pane using the `pn.panel()` utility to automatically infer the pane type from the object being passed as the argument:\n\npng \\= pn.panel('https://upload.wikimedia.org/wikipedia/commons/4/47/PNG\\_transparency\\_demonstration\\_1.png', width\\=500)\n\npng\n\n* * *"
},
{
  "markdown": "## Access Pane Type[#](#access-pane-type \"Permalink to this heading\")\n\nThis guide addresses how to access the Pane Type.\n\n* * *\n\nTo access the type for a given component, use the `print` function. This can come in handy when a component was created in such a way where the type was not explicitly specified, such as with `pn.panel` as described on the [How to construct panes page](https://panel.holoviz.org/how_to/components/construct_panes.html).\n\nimport panel as pn\npn.extension() \\# for notebook\n\nexample\\_pane \\= pn.panel('https://upload.wikimedia.org/wikipedia/commons/b/b1/Loading\\_icon.gif', width\\=500)\n\nprint(example\\_pane)\n\nGIF(str, width=500)"
},
{
  "markdown": "This guide addresses how to add or remove components from `Panels`, starting with the most common: `Row` and `Column`.\n\n## Row & Column Panels[#](#row-column-panels \"Permalink to this heading\")\n\nTo start, we will declare a `Column` and populate it with some text and a widget:\n\nimport panel as pn\npn.extension() \\# for notebook\n\ncolumn \\= pn.Column('some text', pn.widgets.FloatSlider())\n\ncolumn\n\nAs we can manipulate a `Row` or `Column` object just like a Python list, we’ll use `.append` to add some markdown:\n\ncolumn.append('\\* Item 1\\\\n\\* Item 2')\n\ncolumn\n\nNext, we add a few more widgets:\n\ncolumn.extend(\\[pn.widgets.TextInput(), pn.widgets.Checkbox(name\\='Tick this!')\\])\n\ncolumn\n\nNow, we change our mind and replace the `Checkbox` with a button:\n\ncolumn\\[4\\] \\= pn.widgets.Button(name\\='Click here')\n\ncolumn\n\nFinally, we decide to remove the FloatSlider widget, but we forget its index. We can use `print` to see the index of the components:\n\nColumn\n    \\[0\\] Markdown(str)\n    \\[1\\] FloatSlider()\n    \\[2\\] Markdown(str)\n    \\[3\\] TextInput()\n    \\[4\\] Button(name='Click here')\n\nand then `.pop` to remove the FloatSlider:\n\nHere is the complete code for this subsection in case you want to easily copy it:\n\nimport panel as pn\npn.extension() \\# for notebook\n\ncolumn \\= pn.Column('some text', pn.widgets.FloatSlider())\ncolumn.append('\\* Item 1\\\\n\\* Item 2')\ncolumn.extend(\\[pn.widgets.TextInput(), pn.widgets.Checkbox(name\\='Tick this!')\\])\ncolumn\\[4\\] \\= pn.widgets.Button(name\\='Click here')\ncolumn.pop(1)\n\ncolumn\n\n## Tabs Panel[#](#tabs-panel \"Permalink to this heading\")\n\n`Tabs` can also be changed like a Python list. However, when adding or replacing tab items, it is also possible to pass a tuple providing a custom title for the tab. First, create a `Tabs` panel that contains a plot:\n\nfrom bokeh.plotting import figure\n\np1 \\= figure(width\\=300, height\\=300)\np1.line(\\[1, 2, 3\\], \\[1, 2, 3\\])\n\ntabs \\= pn.Tabs(p1)\n\ntabs\n\nThen, add a new tab for a slider widget and include a title for this new tab:\n\ntabs.append(('Slider', pn.widgets.FloatSlider()))\n\ntabs\n\nFinally, add multiple additional tabs at once using `.extend`, passing titles for each:\n\ntabs.extend(\\[\n    ('Text', pn.widgets.TextInput()),\n    ('Color', pn.widgets.ColorPicker())\n\\])\n\ntabs\n\nHere is the complete code for this subsection in case you want to easily copy it:\n\nimport panel as pn\npn.extension() \\# for notebook\nfrom bokeh.plotting import figure\n\np1 \\= figure(width\\=300, height\\=300)\np1.line(\\[1, 2, 3\\], \\[1, 2, 3\\])\n\ntabs \\= pn.Tabs(p1)\ntabs.append(('Slider', pn.widgets.FloatSlider()))\ntabs.extend(\\[\n    ('Text', pn.widgets.TextInput()),\n    ('Color', pn.widgets.ColorPicker())\n\\])\n\ntabs\n\n## GridSpec Panel[#](#gridspec-panel \"Permalink to this heading\")\n\nA `GridSpec` behaves like a 2D array. The indexing is zero-based and specifies the rows first and the columns second.\n\nFirst, declare a `GridSpec` and add red and blue blocks. The red block goes in the first row and spans 3 columns. The blue block spans from the second to fourth row, but only occupies the first column:\n\ngridspec \\= pn.GridSpec(sizing\\_mode\\='stretch\\_both', min\\_height\\=600)\n\ngridspec\\[0, :3\\] \\= pn.Spacer(styles\\={'background': '#FF0000'})\ngridspec\\[1:3, 0\\] \\= pn.Spacer(styles\\={'background': '#0000FF'})\n\ngridspec\n\nNext, add our previously created bokeh figure to the remaining slots of the second row:\n\ngridspec\\[1:3, 1:3\\] \\= p1\n\ngridspec\n\nThen, place an image and a `Column` of widgets under the plot:\n\ngridspec\\[3, 2\\] \\= pn.Column(\n    pn.widgets.FloatSlider(),\n    pn.widgets.ColorPicker(),\n    pn.widgets.Toggle(name\\='Toggle Me!'))\ngridspec\\[3, 1\\] \\= 'https://upload.wikimedia.org/wikipedia/commons/4/47/PNG\\_transparency\\_demonstration\\_1.png'\n\ngridspec\n\nFinally, remove the Spacers:\n\ndel gridspec\\[0, :3\\]\ndel gridspec\\[1:3, 0\\]\n\ngridspec\n\nHere is the complete code for this subsection in case you want to easily copy it:\n\nimport panel as pn\npn.extension() \\# for notebook\n\ngridspec \\= pn.GridSpec(sizing\\_mode\\='stretch\\_both', max\\_height\\=400)\n\ngridspec\\[0, :3\\] \\= pn.Spacer(styles\\={'background': '#FF0000'})\ngridspec\\[1:3, 0\\] \\= pn.Spacer(styles\\={'background': '#0000FF'})\n\ngridspec\\[1:3, 1:3\\] \\= p1\n\ngridspec\\[3, 2\\] \\= pn.Column(\n    pn.widgets.FloatSlider(),\n    pn.widgets.ColorPicker(),\n    pn.widgets.Toggle(name\\='Toggle Me!'))\ngridspec\\[3, 1\\] \\= 'https://upload.wikimedia.org/wikipedia/commons/4/47/PNG\\_transparency\\_demonstration\\_1.png'\n\ndel gridspec\\[0, :3\\]\ndel gridspec\\[1:3, 0\\]\n\ngridspec\n\n* * *"
},
{
  "markdown": "This guide addresses how to access and set widget values.\n\n* * *\n\nIn addition to other parameters that govern widget behavior and appearance, Widget objects have a `value` parameter that can be used to access the current value state.\n\nLet’s first create a `TextInput` widget:\n\nimport panel as pn\npn.extension() \\# for notebook\n\nwidget \\= pn.widgets.TextInput(name\\='A widget', value\\='A string')\nwidget\n\nNow we can programmatically access its value:\n\nWe can also use this value parameter to set the widget value:\n\n* * *"
},
{
  "markdown": "## Style Components[#](#style-components \"Permalink to this heading\")\n\nPanel provides a comprehensive system for applying designs, themes and custom styling for components. This section will take you through these concepts.\n\nApply a Design\n\nHow to switch between different design systems.\n\nToggle themes\n\nHow to toggle between themes (e.g. ‘light’ and ‘dark’).\n\nApply CSS\n\nHow to apply custom CSS styling.\n\nCustomize a Design\n\nHow to customize designs and themes with CSS variables.\n\nCustomize Loading Icon\n\nHow to customize the loading icon.\n\nControl Visibility\n\nHow to control the visibility of a component.\n\nThis section will show you how to style the most common plotting libraries for use with Panel.\n\nAltair\n\n[![../../_images/altair-logo.png](https://panel.holoviz.org/_images/altair-logo.png)](https://panel.holoviz.org/_images/altair-logo.png)\n\nHow to style an Altair plot\n\nECharts\n\n[![../../_images/echarts-logo.png](https://panel.holoviz.org/_images/echarts-logo.png)](https://panel.holoviz.org/_images/echarts-logo.png)\n\nHow to style an ECharts plot\n\nMatplotlib\n\n[![../../_images/matplotlib-logo.png](https://panel.holoviz.org/_images/matplotlib-logo.png)](https://panel.holoviz.org/_images/matplotlib-logo.png)\n\nHow to style a Matplotlib plot\n\nPlotly\n\n[![../../_images/plotly-logo.png](https://panel.holoviz.org/_images/plotly-logo.png)](https://panel.holoviz.org/_images/plotly-logo.png)\n\nHow to style a Plotly plot\n\nVega Lite\n\n[![../../_images/vegalite-logo.png](https://panel.holoviz.org/_images/vegalite-logo.png)](https://panel.holoviz.org/_images/vegalite-logo.png)\n\nHow to style a Vega Lite plot"
},
{
  "markdown": "## Toggling themes[#](#toggling-themes \"Permalink to this heading\")\n\nThis guide addresses how to toggle between different themes in Panel.\n\n* * *\n\nThe `theme` of a Panel app primarily determines the color scheme of our application. By default there are ‘default’ (i.e. light) and ‘dark’ themes defined in Panel and we can toggle between them by setting the `config` option:\n\nimport panel as pn\n\npn.config.theme \\= 'dark'\n\nTip\n\nAll `config` options can also be set via the extension, e.g. to set the theme use `pn.extension(theme='dark')`.\n\nNote that if you do not explicitly override the theme it will default to a light theme. The theme can also be overridden with by setting `theme` as a URL query parameter for your application, i.e. if your app is hosted at `https://mydomain.com/myapp` adding `?theme=dark` will switch the theme automatically.\n\nThe theme will apply to all components and combines with the [design](https://panel.holoviz.org/how_to/styling/design.html) to provide a consistent visual language.\n\nNote\n\nIn JupyterLab and when using the pydata-sphinx-theme Panel components will automatically adapt to the global CSS variables, regardless of what theme you set."
},
{
  "markdown": "## Apply a Design[#](#apply-a-design \"Permalink to this heading\")\n\nThis guide addresses how to select a design system to apply to the components to achieve a consistent design language.\n\nNew in version 1.0.0: The design feature was added in 1.0.0 and is actively being developed and improved.\n\n* * *\n\nApplying different design systems in Panel can be achieved globally or per component. To select a `design` globally set it via the extension:\n\nimport panel as pn\n\npn.extension(design\\='material')\n\nAlternatively you can also explicitly import and set a `design` on the config:\n\nfrom panel.theme import Material\n\npn.config.design \\= Material\n\nAny component that is rendered will now inherit this design. However, alternatively we can also set a `design` explicitly on a particular component, e.g.:\n\nfrom panel.theme import Bootstrap, Material, Native\n\ndef create\\_components(design):\n    return pn.Column(\n        pn.widgets.FloatSlider(name\\='Slider', design\\=design),\n        pn.widgets.TextInput(name\\='TextInput', design\\=design),\n        pn.widgets.Select(\n\t\t    name\\='Select', options\\=\\['Biology', 'Chemistry', 'Physics'\\], design\\=design\n        ),\n        pn.widgets.Button(\n            name\\='Click me!', icon\\='hand-click', button\\_type\\='primary', design\\=design\n        )\n    )\n\npn.Tabs(\n    ('Bootstrap', create\\_components(Bootstrap)),\n    ('Material', create\\_components(Material)),\n    ('Native', create\\_components(Native)),\n)"
},
{
  "markdown": "## Apply CSS[#](#apply-css \"Permalink to this heading\")\n\nThis guide addresses how to apply custom CSS styling to components.\n\n* * *\n\nimport panel as pn\n\npn.extension()\n\nPanel components are rendered into the [shadow DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM), if you are not familiar with the concept just know that it means that each component is isolated from all others meaning that we can easily apply CSS rules for specific components.\n\nTo set CSS styles we can use one of two parameters, the `styles` and the `stylesheets` parameter. The former is a dictionary of CSS styles that are applied to the container wrapping the component while stylesheets can contain entire CSS files or inline CSS rules.\n\n## `styles`[#](#styles \"Permalink to this heading\")\n\nApplying `styles` allows us to style the **container** in a straightforward manner, e.g. here we apply a background and a border around a widget:\n\ncustom\\_style \\= {\n    'background': '#f9f9f9',\n    'border': '1px solid black',\n    'padding': '10px',\n    'box-shadow': '5px 5px 5px #bcbcbc'\n}\n\npn.widgets.FloatSlider(name\\='Number', styles\\=custom\\_style)\n\n## `stylesheets`[#](#stylesheets \"Permalink to this heading\")\n\nSince `styles` only applies to the `<div>` that holds the component we cannot use it to directly modify the styling of the **contents** of the component. This is where `stylesheets` come in, allowing us to provide CSS rules that affect each part of the component. This can be done in one of two ways, either we modify CSS variables or we target the specific DOM node that we want to modify using CSS rules.\n\nNew in version 1.0.0: Note that `styles` and `stylesheets` are new in Panel 1.0.0. As we continue to build on this functionality we will provide ways of modifying the styling of components using CSS variables.\n\n### CSS Variables[#](#css-variables \"Permalink to this heading\")\n\nIn the case of the `FloatSlider` we can modify the dimensions of the handle and the slider using CSS variables like `--handle-width`, `--handle-height` and `--slider-size`. In future we aim to provide a comprehensive list of CSS variables for each component.\n\nstylesheet \\= \"\"\"\n:host {\n  --handle-width: 15px;\n  --handle-height: 25px;\n  --slider-size: 25px;\n}\n\"\"\"\n\npn.widgets.FloatSlider(\n    name\\='Number', styles\\=custom\\_style, stylesheets\\=\\[stylesheet\\]\n)\n\n### CSS rules[#](#css-rules \"Permalink to this heading\")\n\nIf we need full control over the precise styling of a component we can target specific parts of a component using standard CSS rules, e.g. by identifying the CSS classes applied to each component.\n\nTip\n\nTo discover how exactly a component is structured and how to target specific parts of a component use the inspect functionality of your browser. For example in Chrome right click on the component, then select inspect and look at the DOM structure, e.g. here is the DOM structure of the `FloatSlider`:\n\n<div class\\=\"bk-input-group\"\\>\n  <div class\\=\"bk-slider-title\"\\>Number: <span class\\=\"bk-slider-value\"\\>0</span\\></div\\>\n  <div class\\=\"noUi-target noUi-ltr noUi-horizontal noUi-txt-dir-ltr\"\\>\n    <div class\\=\"noUi-base\"\\>\n      <div class\\=\"noUi-connects\"\\>\n        <div class\\=\"noUi-connect\" style\\=\"transform: translate(0%, 0px) scale(0, 1); background-color: rgb(230, 230, 230);\"\\></div\\>\n      </div\\>\n      <div class\\=\"noUi-origin\" style\\=\"transform: translate(-100%, 0px); z-index: 4;\"\\>\n        <div class\\=\"noUi-handle noUi-handle-lower\" data-handle\\=\"0\" tabindex\\=\"0\" role\\=\"slider\" aria-orientation\\=\"horizontal\" aria-valuemin\\=\"0.0\" aria-valuemax\\=\"1.0\" aria-valuenow\\=\"0.0\" aria-valuetext\\=\"0.00\"\\>\n\t<div class\\=\"noUi-touch-area\"\\>\n      </div\\>\n      <div class\\=\"noUi-tooltip\"\\>0</div\\>\n    </div\\>\n  </div\\>\n</div\\>\n\nUsing the styles pane in the developer console you can then try out various styles before you translate them into specific CSS rules.\n\nLet’s say we want to make the slider handle circular and change its color. Inspecting the HTML we can see that the handle is defined with the CSS class `noUi-handle`. Now we can define a CSS rule with that class that sets a `border-radius` and `background-color`, additionally we unset the `box-shadow`:\n\nstylesheet \\= \"\"\"\n:host {\n  --slider-size: 5px;\n  --handle-width: 16px;\n  --handle-height: 16px;\n}\n\n.noUi-handle {\n  border-radius: 100%;\n  box-shadow: unset;\n  background-color: #0081f3;\n}\n\"\"\"\n\npn.widgets.FloatSlider(\n    name\\='Number', styles\\=custom\\_style, stylesheets\\=\\[stylesheet\\]\n)\n\n### External stylesheets[#](#external-stylesheets \"Permalink to this heading\")\n\nInlining stylesheets provides a quick way to override the style of a component but it also means we are sending the stylesheet to the frontend as a string. This can add up when we want to apply this stylesheet to multiple components. Therefore it is recommended that once you move to production the styles are served as an external stylesheet you reference.\n\nYou can either provide a full URL to the stylesheet and host it yourself or you can [serve static assets alongside your application](https://panel.holoviz.org/how_to/server/static_files.html). Here we load the stylesheet from an external URL:\n\npn.widgets.FloatSlider(\n    name\\='Number', stylesheets\\=\\['https://assets.holoviz.org/panel/how\\_to/styling/noUi.css'\\]\n)\n\n### CSS Classes[#](#css-classes \"Permalink to this heading\")\n\nWhen building complex stylesheets you will sometimes want to have multiple styles for one component. While it is possible to include a separate stylesheet for each you can also use CSS classes to distinguish between different components. The `css_classes` parameter will apply the CSS class to the shadow root (or container). Let us create two sliders with different CSS classes:\n\ncolor\\_stylesheet \\= \"\"\"\n:host(.red) .noUi-handle {\n  background-color: red\n}\n\n:host(.green) .noUi-handle {\n  background-color: green\n}\n\n:host(.blue) .noUi-handle {\n  background-color: blue\n}\n\"\"\"\n\npn.Column(\n    \\*(pn.widgets.FloatSlider(name\\='Number', stylesheets\\=\\[stylesheet, color\\_stylesheet\\], css\\_classes\\=\\[cls\\])\n      for cls in ('red', 'green', 'blue'))\n)\n\n## Global styles[#](#global-styles \"Permalink to this heading\")\n\nDeprecated since version 1.0.0: Before 1.0.0 CSS styling was generally applied globally by adding `raw_css` and `css_files` to the global `config` or `extension`. This approach is no longer recommended.\n\n* * *"
},
{
  "markdown": "## Control Visibility[#](#control-visibility \"Permalink to this heading\")\n\nThis guide addresses how to control the visibility of a component.\n\n* * *\n\nAll components provide a `visible` parameter which toggles a component’s visibility.\n\nLet’s create three simple components with different colors. We’ll set the visibility parameter of the blue one to `False`:\n\nimport panel as pn\n\npn.extension() \\# for notebook\n\na \\= pn.pane.HTML(width\\=60, height\\=60, styles\\={'background': 'green'})\nb \\= pn.pane.HTML(width\\=60, height\\=60, styles\\={'background': 'blue'}, visible\\=False)\nc \\= pn.pane.HTML(width\\=60, height\\=60, styles\\={'background': 'red'})\n\nlayout \\= pn.Row(a, b, c)\nlayout\n\nIn some cases, exposing control of component visibility within the user interface may come in handy. To achieve this, we can use the `controls` method on a component to create a widget that allows for the manipulation of the `visibility` parameter. For instance, after running the code cell, toggling the checkbox below will update the visibility of the blue `b` component above:\n\nb.controls(\\['visible'\\])\\[1\\]\n\n* * *"
},
{
  "markdown": "## Customize Loading Icon[#](#customize-loading-icon \"Permalink to this heading\")\n\nThis guide addresses how to customize the loading icon.\n\n* * *\n\nAll components also have a `loading` parameter which indicates that they are currently processing some event. Setting the parameter will display the global `loading_spinner` on top of the component.\n\nFirst, let’s configure the style and color of loading spinner:\n\n*   `pn.config.loading_spinner`: The style of the global loading indicator, e.g. ‘arc’, ‘arcs’, ‘bar’, ‘dots’, ‘petal’.\n    \n*   `pn.config.loading_color`: The color of the global loading indicator as a hex color or color name, e.g. ‘#6a6a6a’, ‘black’.\n    \n\nimport panel as pn\n\npn.config.loading\\_spinner \\= 'petal'\npn.config.loading\\_color \\= 'black'\n\nIf we are working in a notebook, we can now activate the panel extension after having set the config parameters. Alternatively, we could have set the config with `pn.extension(loading_spinner='petal', loading_color='black')`\n\npn.extension() \\# for notebook\n\nNext, let’s display a simple component and set `loading=True`:\n\npn.pane.HTML(styles\\={'background': '#00aa41'}, width\\=100, height\\=100, loading\\=True)\n\nAttention\n\nSetting the loading icon may not appear to function properly on this page due to incompatibility with the tooling specific to the documentation.\n\n* * *"
},
{
  "markdown": "## Style Altair Plots[#](#style-altair-plots \"Permalink to this heading\")\n\nThis guide addresses how to style Altair plots displayed using the Vega pane.\n\nYou can select the theme of Altair plots using [`altair.themes.enable`](https://altair-viz.github.io/user_guide/customization.html#changing-the-theme) and an accent color using the `configure_mark` method. The list of themes is available via `altair.themes.names()`.\n\nThe gif below displays an example of what can be achieved with a little styling of the Altair plot and the `FastListTemplate`.\n\n![VegaAltairStyle.gif](https://assets.holoviews.org/panel/thumbnails/gallery/styles/vega-styles.gif)\n\n## An Altair plot with custom theme and accent color[#](#an-altair-plot-with-custom-theme-and-accent-color \"Permalink to this heading\")\n\nIn this example we will give the Altair plot a custom theme and accent color.\n\nimport altair as alt\nimport panel as pn\n\nfrom vega\\_datasets import data\n\npn.extension(\"vega\")\n\ndef plot(theme, color):\n    alt.themes.enable(theme)\n\n    return (\n        alt.Chart(data.cars())\n        .mark\\_circle(size\\=200)\n        .encode(\n            x\\='Horsepower:Q',\n            y\\='Miles\\_per\\_Gallon:Q',\n            tooltip\\=\\[\"Name\", \"Origin\", \"Horsepower\", \"Miles\\_per\\_Gallon\"\\],\n        )\n        .configure\\_mark(\n            color\\=color\n        )\n        .properties(\n            height\\=300,\n            width\\=\"container\",\n        )\n        .interactive()\n    )\n\nthemes \\= sorted(alt.themes.names())\ntheme \\= pn.widgets.Select(value\\=\"dark\", options\\=themes, name\\=\"Theme\")\ncolor \\= pn.widgets.ColorPicker(value\\=\"#F08080\", name\\=\"Color\")\n\npn.Column(\n    pn.Row(theme, color),\n    pn.pane.Vega(pn.bind(plot, theme\\=theme, color\\=color), height\\=350, sizing\\_mode\\=\"stretch\\_width\"),\n    \"\\*\\*Altair Themes\\*\\*: \" + \", \".join(themes),\n    styles\\={\"border\": \"1px solid lightgray\"}\n).servable()\n\nPlease note that the line `alt.themes.enable(theme)` will set the theme of all future generated plots unless you specifically change it before usage in a `Vega` pane."
},
{
  "markdown": "## Style Echarts Plots[#](#style-echarts-plots \"Permalink to this heading\")\n\nThis guide addresses how to style ECharts plots displayed using the ECharts pane.\n\nYou can select the theme of ECharts plots using the `ECharts.theme` parameter.\n\n![ECharts Themes](https://assets.holoviz.org/panel/gifs/echarts-styles.gif)\n\n## An ECharts plot with a custom theme[#](#an-echarts-plot-with-a-custom-theme \"Permalink to this heading\")\n\nIn this example we will extend the `themes` available to the `ECharts` pane to the themes listed in the [ECharts Themes Guide](https://echarts.apache.org/en/download-theme.html) and then use one of them.\n\nimport panel as pn\n\nTHEME \\= \"shine\"\n\nECHARTS\\_THEMES \\= {\n    \"infographic\": \"https://fastly.jsdelivr.net/npm/echarts/theme/infographic.js?\\_v\\_=20200710\\_1\",\n    \"macarons\": \"https://fastly.jsdelivr.net/npm/echarts/theme/macarons.js?\\_v\\_=20200710\\_1\",\n    \"roma\": \"https://fastly.jsdelivr.net/npm/echarts/theme/roma.js?\\_v\\_=20200710\\_1\",\n    \"shine\": \"https://fastly.jsdelivr.net/npm/echarts/theme/shine.js?\\_v\\_=20200710\\_1\",\n    \"vintage\": \"https://fastly.jsdelivr.net/npm/echarts/theme/vintage.js?\\_v\\_=20200710\\_1\",\n}\n\npn.pane.ECharts.param.theme.objects \\= pn.pane.ECharts.param.theme.objects + list(\n    ECHARTS\\_THEMES\n)\n\npn.extension(\"echarts\", js\\_files\\=ECHARTS\\_THEMES)\n\nechart\\_bar \\= {\n    \"title\": {\"text\": \"ECharts Example\"},\n    \"tooltip\": {},\n    \"legend\": {\"data\": \\[\"Sales\"\\]},\n    \"xAxis\": {\"data\": \\[\"shirt\", \"cardign\", \"chiffon shirt\", \"pants\", \"heels\", \"socks\"\\]},\n    \"yAxis\": {},\n    \"series\": \\[{\"name\": \"Sales\", \"type\": \"bar\", \"data\": \\[5, 20, 36, 10, 10, 20\\]}\\],\n}\n\nplot \\= pn.pane.ECharts(\n    echart\\_bar,\n    height\\=500,\n    sizing\\_mode\\=\"stretch\\_width\",\n    theme\\=THEME,\n)\npn.Column(plot.param.theme, plot, sizing\\_mode\\=\"stretch\\_width\").servable()"
},
{
  "markdown": "## Style Matplotlib Plots[#](#style-matplotlib-plots \"Permalink to this heading\")\n\nThis guide addresses how to style Matplotlib plots displayed using the Matplotlib pane.\n\nThere are nearly 30 builtin styles to Matplotlib that can be activated with the `plt.style.use` function. The style names are listed in the `plt.style.available` array.\n\nFor more info check out the [Matplotlib style sheets reference](https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html) and the alternative themes [dracula theme](https://draculatheme.com/matplotlib) and [gadfly](https://towardsdatascience.com/a-new-plot-theme-for-matplotlib-gadfly-2cffc745ff84).\n\nThe gif below displays an example of what can be achieved with a little styling of the `Matplotlib` figure and the `FastListTemplate`.\n\n![Matplotlib + FastListTemlate Styling Example](https://assets.holoviews.org/panel/thumbnails/gallery/styles/matplotlib-styles.gif)\n\n## A Matplotlib plot with custom style and accent color[#](#a-matplotlib-plot-with-custom-style-and-accent-color \"Permalink to this heading\")\n\nIn this example we will give the Matplotlib plot a custom style and accent color.\n\nimport numpy as np\n\nfrom matplotlib.figure import Figure\nimport matplotlib.pyplot as plt\nimport panel as pn\n\npn.extension()\n\ndef plot(style, color):\n    x \\= np.arange(\\-2, 8, 0.1)\n    y \\= 0.1 \\* x\\*\\*3 \\- x\\*\\*2 + 3 \\* x + 2\n\n    plt.style.use(\"default\")  \\# reset to not be affected by previous style changes\n    plt.style.use(style)  \\# change to the specified style\n\n    fig0 \\= Figure(figsize\\=(12, 6))\n    ax0 \\= fig0.subplots()\n    ax0.plot(x, y, linewidth\\=10.0, color\\=color)\n    ax0.set\\_title(f\"Matplotlib Style: {style}\")\n\n    plt.style.use(\"default\")  \\# reset to not affect style of other plots\n\n    return fig0\n\nstyles \\= sorted(plt.style.available)\nstyle \\= pn.widgets.Select(value\\=\"dark\\_background\", options\\=styles, name\\=\"Style\")\ncolor \\= pn.widgets.ColorPicker(value\\=\"#F08080\", name\\=\"Color\")\n\npn.Column(\n    pn.Row(style, color),\n    pn.pane.Matplotlib(\n        pn.bind(plot, style\\=style, color\\=color),\n        height\\=400,\n        sizing\\_mode\\=\"fixed\",\n    ),\n    \"\\*\\*Matplotlib Styles\\*\\*: \" + \", \".join(styles),\n).servable()"
},
{
  "markdown": "## Make your component interactive[#](#make-your-component-interactive \"Permalink to this heading\")\n\nThis section will help you add interactivity to your applications and exploratory workflows.\n\nAdd interactivity to a function\n\nDiscover how to bind widgets to a function to add interactivity.\n\nBuild self-updating components\n\nHow to use Python generators with `pn.bind` to build components that update themselves.\n\nAdd reactivity to components\n\nDiscover how to bind parameters, widgets, and bound functions to components.\n\nBuild reactive data pipelines\n\nHow to use `hvplot.interactive` with widgets to make your data workflows interactive"
},
{
  "markdown": "## Style Vega Plots[#](#style-vega-plots \"Permalink to this heading\")\n\nThis guide addresses how to style Vega plots displayed using the Vega pane.\n\nThe gif below displays an example of what can be achieved with a little styling of the Vega plot and the `FastListTemplate`.\n\n![VegaAltairStyle.gif](https://assets.holoviews.org/panel/thumbnails/gallery/styles/vega-styles.gif)\n\n## A Vega plot with dark theme and accent color[#](#a-vega-plot-with-dark-theme-and-accent-color \"Permalink to this heading\")\n\nIn this example we will give the Vega Plot a dark theme and a custom accent color.\n\nimport panel as pn\n\nfrom vega\\_datasets import data\n\npn.extension(\"vega\")\n\nVEGA\\_ACCENT\\_COLOR \\= \"#F08080\"\nVEGA\\_THEME \\= {\n    \"background\": \"#333\",\n    \"title\": {\"color\": \"#fff\"},\n    \"style\": {\"guide-label\": {\"fill\": \"#fff\"}, \"guide-title\": {\"fill\": \"#fff\"}},\n    \"axis\": {\"domainColor\": \"#fff\", \"gridColor\": \"#888\", \"tickColor\": \"#fff\"},\n}\n\nvegalite \\= {\n    \"$schema\": \"https://vega.github.io/schema/vega-lite/v5.json\",\n    \"description\": \"A simple bar chart with rounded corners at the end of the bar.\",\n    \"width\": \"container\",\n    \"height\": 300,\n    \"data\": {\n    \"values\": \\[\n        {\"a\": \"A\", \"b\": 28},\n        {\"a\": \"B\", \"b\": 55},\n        {\"a\": \"C\", \"b\": 43},\n        {\"a\": \"D\", \"b\": 91},\n        {\"a\": \"E\", \"b\": 81},\n        {\"a\": \"F\", \"b\": 53},\n        {\"a\": \"G\", \"b\": 19},\n        {\"a\": \"H\", \"b\": 87},\n        {\"a\": \"I\", \"b\": 52}\n    \\]\n    },\n    \"mark\": {\"type\": \"bar\", \"cornerRadiusEnd\": 4, \"tooltip\": True},\n    \"encoding\": {\n        \"x\": {\"field\": \"a\", \"type\": \"ordinal\"},\n        \"y\": {\"field\": \"b\", \"type\": \"quantitative\"},\n        \"color\": {\"value\": VEGA\\_ACCENT\\_COLOR}\n    },\n}\n\nvegalite\\[\"config\"\\] \\= VEGA\\_THEME\n\npn.pane.Vega(vegalite, height\\=350, sizing\\_mode\\=\"stretch\\_width\").servable()"
},
{
  "markdown": "## Style Plotly Plots[#](#style-plotly-plots \"Permalink to this heading\")\n\nThis guide addresses how to style Plotly plots displayed using the Plotly pane.\n\nPlotly provides a list of built in templates in `plotly.io.templates`. See the [Plotly Templates Guide](https://plotly.com/python/templates/).\n\nThe gif below displays an example of what can be achieved with a little styling of the Plotly plot and the `FastListTemplate`.\n\n![PlotlyStyle.gif](https://assets.holoviews.org/panel/thumbnails/gallery/styles/plotly-styles.gif)\n\n## A Plotly Express plot with a custom theme and accent color[#](#a-plotly-express-plot-with-a-custom-theme-and-accent-color \"Permalink to this heading\")\n\nIn this example we will give the Plotly Express plot a dark theme and a custom accent color.\n\nimport pandas as pd\nimport plotly.express as px\nimport plotly.io as pio\n\nimport panel as pn\n\npn.extension(\"plotly\")\n\ndata \\= pd.DataFrame(\n    \\[\n        (\"Monday\", 7),\n        (\"Tuesday\", 4),\n        (\"Wednesday\", 9),\n        (\"Thursday\", 4),\n        (\"Friday\", 4),\n        (\"Saturday\", 4),\n        (\"Sunday\", 4),\n    \\],\n    columns\\=\\[\"Day\", \"Orders\"\\],\n)\n\ndef plot(template, color):\n    fig \\= px.line(\n        data,\n        x\\=\"Day\",\n        y\\=\"Orders\",\n        template\\=template,\n        color\\_discrete\\_sequence\\=(color,),\n        title\\=f\"Template: {template}\",\n    )\n    fig.update\\_traces(mode\\=\"lines+markers\", marker\\=dict(size\\=10), line\\=dict(width\\=4))\n    fig.layout.autosize \\= True\n    return fig\n\ntemplates \\= sorted(pio.templates)\ntemplate \\= pn.widgets.Select(value\\=\"plotly\\_dark\", options\\=templates, name\\=\"Template\")\ncolor \\= pn.widgets.ColorPicker(value\\=\"#F08080\", name\\=\"Color\")\n\npn.Column(\n    pn.Row(template, color),\n    pn.pane.Plotly(pn.bind(plot, template, color), sizing\\_mode\\=\"stretch\\_width\"),\n    \"\\*\\*Plotly Templates\\*\\*: \" + \", \".join(templates),\n).servable()\n\n## A Plotly `go.Figure` plot with dark theme[#](#a-plotly-go-figure-plot-with-dark-theme \"Permalink to this heading\")\n\nIn this example we will give the Plotly `go.Figure` plot a dark theme.\n\nimport pandas as pd\nimport plotly.graph\\_objects as go\n\nimport panel as pn\n\npn.extension(\"plotly\")\n\nTEMPLATE \\= \"plotly\\_dark\"  \\# \"ggplot2\", \"seaborn\", \"simple\\_white\", \"plotly\", \"plotly\\_white\", \"plotly\\_dark\", \"presentation\", \"xgridoff\", \"ygridoff\", \"gridon\", \"none\"\n\nz\\_data \\= pd.read\\_csv(\"https://raw.githubusercontent.com/plotly/datasets/master/api\\_docs/mt\\_bruno\\_elevation.csv\")\n\nfig \\= go.Figure(\n    data\\=go.Surface(z\\=z\\_data.values),\n    layout\\=go.Layout(\n        title\\=\"Mt Bruno Elevation\",\n    ))\nfig.layout.autosize \\= True\nfig.update\\_layout(template\\=TEMPLATE, title\\=f\"Mt Bruno Elevation in a '{TEMPLATE}' template\")\n\npn.pane.Plotly(fig, height\\=500, sizing\\_mode\\=\"stretch\\_width\").servable()"
},
{
  "markdown": "## How-to[#](#how-to \"Permalink to this heading\")\n\nThe Panel How-to guides provide step by step recipes for solving essential problems and tasks that arise during your work. They assume that you’ve completed the Getting Started material and therefore already have some knowledge of how Panel works. There is no order to the guides, other than any potential prerequisites listed at the top of a page. Jump to the topic that is relevant to you now.\n\n## Prepare to develop[#](#prepare-to-develop \"Permalink to this heading\")\n\nDevelop in a notebook\n\nHow to effectively develop apps in a notebook environment.\n\nDevelop in an editor\n\nHow to effectively develop apps in a Python or Markdown file.\n\n## Build apps[#](#build-apps \"Permalink to this heading\")\n\nConstruct components\n\nHow to construct and customize individual components like an image or slider widget.\n\nArrange Components\n\nHow to arrange and size components on the page.\n\nStyle components\n\nHow to apply designs, themes and custom styling to components to achieve a polished look and feel.\n\nAdd interactivity\n\nHow to link add interactivity to your applications using reactive APIs.\n\nApply templates\n\nHow to use a Template to customize the look and feel of a deployed Panel app.\n\n## Use specialized UIs and APIs[#](#use-specialized-uis-and-apis \"Permalink to this heading\")\n\nBuild a sequential UI\n\nHow to build a Panel Pipeline that connects multiple panels into a sequential user interface.\n\nBuild custom components\n\nHow to extend Panel by building custom components.\n\nGenerate UIs from declared parameters (`Declarative API`)\n\nHow to use Parameterized classes with Panel to generate UIs without writing GUI code.\n\nExplicitly link parameters (`Callbacks API`)\n\nHow to link the parameters of Panel components in Python and Javascript.\n\n## Manage session tasks[#](#manage-session-tasks \"Permalink to this heading\")\n\nRegister session callbacks\n\nHow to set up callbacks on session related events (e.g. on page load or when a session is destroyed) and define periodic tasks.\n\nAccess session state\n\nHow to access and manipulate state related to the user session, HTTP request and URL arguments.\n\n## Test and debug[#](#test-and-debug \"Permalink to this heading\")\n\nEnable profiling and debugging\n\nHow to profile and debug your application using the admin dashboard and other tools.\n\nSet up testing for an application\n\nHow to set up unit tests, UI tests and load testing to ensure your applications are (and stay) robust and scalable.\n\n## Share your work[#](#share-your-work \"Permalink to this heading\")\n\nConfigure the server\n\nHow to configure the Panel server.\n\nIntegrate with other servers\n\nHow to integrate Panel in other application based on Flask, FastAPI or Django.\n\nDeploy applications\n\nHow to deploy Panel applications to various cloud providers (e.g. Azure, GCP, AWS etc.)\n\nExport apps\n\nHow to export and save Panel applications as static files.\n\nRun panel in WebAssembly\n\nHow to run Panel applications entirely in the browser using WebAssembly (Wasm), Pyodide, and PyScript.\n\n## Migrate to Panel[#](#migrate-to-panel \"Permalink to this heading\")\n\nMigrate from Streamlit\n\n[![https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)\n\nHow to migrate existing Streamlit applications to Panel."
},
{
  "markdown": "## Dynamic Tabs[#](#dynamic-tabs \"Permalink to this heading\")\n\nimport numpy as np\nimport pandas as pd\nimport panel as pn\n\npn.extension('deckgl', 'echarts', 'plotly', 'vega', template\\='material')\n\nThis example demonstrates **how to efficiently render a number of complex components in `Tabs`** by using the `dynamic` parameter.\n\nimport altair as alt\nfrom vega\\_datasets import data\n\ncars \\= data.cars()\n\nchart \\= alt.Chart(cars).mark\\_circle(size\\=60).encode(\n    x\\='Horsepower',\n    y\\='Miles\\_per\\_Gallon',\n    color\\='Origin',\n    tooltip\\=\\['Name', 'Origin', 'Horsepower', 'Miles\\_per\\_Gallon'\\]\n).properties(width\\='container', height\\='container').interactive()\n\naltair\\_pane \\= pn.pane.Vega(chart)\n\naltair\\_pane\n\nfrom math import pi\n\nfrom bokeh.palettes import Category20c, Category20\nfrom bokeh.plotting import figure\nfrom bokeh.transform import cumsum\n\nx \\= {\n    'United States': 157,\n    'United Kingdom': 93,\n    'Japan': 89,\n    'China': 63,\n    'Germany': 44,\n    'India': 42,\n    'Italy': 40,\n    'Australia': 35,\n    'Brazil': 32,\n    'France': 31,\n    'Taiwan': 31,\n    'Spain': 29\n}\n\ndata \\= pd.Series(x).reset\\_index(name\\='value').rename(columns\\={'index':'country'})\ndata\\['angle'\\] \\= data\\['value'\\]/data\\['value'\\].sum() \\* 2\\*pi\ndata\\['color'\\] \\= Category20c\\[len(x)\\]\n\np \\= figure(sizing\\_mode\\='stretch\\_both', title\\=\"Pie Chart\", toolbar\\_location\\=None,\n           tools\\=\"hover\", tooltips\\=\"@country: @value\", x\\_range\\=(\\-0.5, 1.0), min\\_height\\=800)\n\nr \\= p.wedge(x\\=0, y\\=1, radius\\=0.4,\n        start\\_angle\\=cumsum('angle', include\\_zero\\=True), end\\_angle\\=cumsum('angle'),\n        line\\_color\\=\"white\", fill\\_color\\='color', legend\\_field\\='country', source\\=data)\n\np.axis.axis\\_label\\=None\np.axis.visible\\=False\np.grid.grid\\_line\\_color \\= None\n\nbokeh\\_pane \\= pn.pane.Bokeh(p, sizing\\_mode\\=\"stretch\\_both\", max\\_width\\=1300)\n\nbokeh\\_pane\n\nMAPBOX\\_KEY \\= (\n    \"pk.eyJ1IjoibWFyY3Nrb3ZtYWRzZW4iLCJhIjoiY2s1anMzcG5rMDYzazNvcm10NTFybTE4cSJ9.\"\n    \"TV1XBgaMfR-iTLvAXM\\_Iew\"\n)\n\njson\\_spec \\= {\n    \"initialViewState\": {\n        \"bearing\": \\-27.36,\n        \"latitude\": 52.2323,\n        \"longitude\": \\-1.415,\n        \"maxZoom\": 15,\n        \"minZoom\": 5,\n        \"pitch\": 40.5,\n        \"zoom\": 6\n    },\n    \"layers\": \\[{\n        \"@@type\": \"HexagonLayer\",\n        \"autoHighlight\": True,\n        \"coverage\": 1,\n        \"data\": \"https://raw.githubusercontent.com/uber-common/deck.gl-data/master/examples/3d-heatmap/heatmap-data.csv\",\n        \"elevationRange\": \\[0, 3000\\],\n        \"elevationScale\": 50,\n        \"extruded\": True,\n        \"getPosition\": \"@@=\\[lng, lat\\]\",\n        \"id\": \"8a553b25-ef3a-489c-bbe2-e102d18a3211\", \"pickable\": True\n    }\\],\n    \"mapStyle\": \"mapbox://styles/mapbox/dark-v9\",\n    \"views\": \\[{\"@@type\": \"MapView\", \"controller\": True}\\]\n}\n\ndeck\\_gl \\= pn.pane.DeckGL(json\\_spec, mapbox\\_api\\_key\\=MAPBOX\\_KEY, sizing\\_mode\\='stretch\\_both')\n\ndeck\\_gl\n\nechart \\= {\n        'title': {\n            'text': 'ECharts entry example'\n        },\n        'tooltip': {},\n        'legend': {\n            'data':\\['Sales'\\]\n        },\n        'xAxis': {\n            'data': \\[\"shirt\",\"cardign\",\"chiffon shirt\",\"pants\",\"heels\",\"socks\"\\]\n        },\n        'yAxis': {},\n        'series': \\[{\n            'name': 'Sales',\n            'type': 'bar',\n            'data': \\[5, 20, 36, 10, 10, 20\\]\n        }\\],\n    }\n\necharts\\_pane \\= pn.pane.ECharts(echart, sizing\\_mode\\='stretch\\_both')\n\necharts\\_pane\n\nimport holoviews as hv\nimport hvplot.pandas\nimport holoviews.plotting.bokeh\n\ndef sine(frequency\\=1.0, amplitude\\=1.0, function\\='sin'):\n    xs \\= np.arange(200)/200\\*20.0\n    ys \\= amplitude\\*getattr(np, function)(frequency\\*xs)\n    return pd.DataFrame(dict(y\\=ys), index\\=xs).hvplot(responsive\\=True)\n\ndmap \\= hv.DynamicMap(sine, kdims\\=\\['frequency', 'amplitude', 'function'\\]).redim.range(\n    frequency\\=(0.1, 10), amplitude\\=(1, 10)).redim.values(function\\=\\['sin', 'cos', 'tan'\\]).opts(responsive\\=True, line\\_width\\=4)\n\nhv\\_panel \\= pn.pane.HoloViews(dmap, widgets\\={\n    'amplitude': pn.widgets.LiteralInput(value\\=1., type\\=(float, int)),\n    'function': pn.widgets.RadioButtonGroup,\n    'frequency': {'value': 5},\n}, center\\=True, sizing\\_mode\\='stretch\\_both').layout\n\nhv\\_panel\n\nimport numpy as np\nimport matplotlib\n\nmatplotlib.use('agg')\n\nimport matplotlib.pyplot as plt\n\nY, X \\= np.mgrid\\[\\-3:3:100j, \\-3:3:100j\\]\nU \\= \\-1 \\- X\\*\\*2 + Y\nV \\= 1 + X \\- Y\\*\\*2\nspeed \\= np.sqrt(U\\*U + V\\*V)\n\nfig0, ax0 \\= plt.subplots()\nstrm \\= ax0.streamplot(X, Y, U, V, color\\=U, linewidth\\=2, cmap\\=plt.cm.autumn)\nfig0.colorbar(strm.lines)\n\nmpl\\_pane \\= pn.pane.Matplotlib(fig0, format\\='svg', sizing\\_mode\\='stretch\\_both')\n\nmpl\\_pane\n\nimport plotly.graph\\_objs as go\n\nxx \\= np.linspace(\\-3.5, 3.5, 100)\nyy \\= np.linspace(\\-3.5, 3.5, 100)\nx, y \\= np.meshgrid(xx, yy)\nz \\= np.exp(\\-(x\\-1)\\*\\*2\\-y\\*\\*2)\\-(x\\*\\*3+y\\*\\*4\\-x/5)\\*np.exp(\\-(x\\*\\*2+y\\*\\*2))\n\nsurface \\= go.Surface(z\\=z)\nlayout \\= go.Layout(\n    title\\='Plotly 3D Plot',\n    autosize\\=True,\n    margin\\=dict(t\\=50, b\\=50, r\\=50, l\\=50)\n)\nfig \\= dict(data\\=\\[surface\\], layout\\=layout)\n\nplotly\\_pane \\= pn.pane.Plotly(fig)\n\nplotly\\_pane\n\npn.Tabs(\n    ('Altair', altair\\_pane),\n    ('Bokeh', bokeh\\_pane),\n    ('deck.GL', deck\\_gl),\n    ('Echarts', echarts\\_pane),\n    ('HoloViews', hv\\_panel),\n    ('Matplotlib', mpl\\_pane),\n    ('Plotly', plotly\\_pane),\n    dynamic\\=True, sizing\\_mode\\='stretch\\_both'\n).servable()"
},
{
  "markdown": "## Set up Manual Threading[#](#set-up-manual-threading \"Permalink to this heading\")\n\nEnabling threading in Panel like we saw in the [automatic threading guide](https://panel.holoviz.org/how_to/concurrency/threading.html) is a simple way to achieve concurrency, however sometimes we need more control. Below we will demonstrate an example of a `Thread` which we start in the background to process items we put in a queue for processing. We simulate the processing with a `time.sleep` but it could be any long-running computation. The `threading.Condition` allows us to manipulate the global shared `queue`.\n\nimport time\nimport threading\n\nc \\= threading.Condition()\n\nbutton \\= pn.widgets.Button(name\\='Click to launch')\ntext \\= pn.widgets.StaticText()\n\nqueue \\= \\[\\]\n\ndef callback():\n    global queue\n    while True:\n        c.acquire()\n        for i, event in enumerate(queue):\n            text.value \\= f'Processing item {i+1} of {len(queue)} items in queue.'\n            ... \\# Do something with the event\n            time.sleep(2)\n        queue.clear()\n        text.value \\= \"Queue empty\"\n        c.release()\n        time.sleep(1)\n\nthread \\= threading.Thread(target\\=callback)\nthread.start()\n\nNow we will create a callback that puts new items for processing on the queue when a button is clicked:\n\ndef on\\_click(event):\n    queue.append(event)\n\nbutton.on\\_click(on\\_click)\n\npn.Row(button, text).servable()\n\nSince the processing happens on a separate thread the application itself can still remain responsive to further user input (such as putting new items on the queue)."
},
{
  "markdown": "## Create a Non-Linear `Pipeline`[#](#create-a-non-linear-pipeline \"Permalink to this heading\")\n\nThis guide addresses how to build a non-linear Panel Pipeline with branching and converging steps, i.e., an acyclic graph.\n\nPrerequisites\n\n1.  The [How-to > Param with Panel](https://panel.holoviz.org/how_to/param/index.html) guides describe how to set up classes that declare parameters and link them to some computation or visualization.\n    \n2.  The [How-to > Create a Pipeline](https://panel.holoviz.org/how_to/pipeline/simple_pipeline.html) guide walks through the essential steps of pipeline construction.\n    \n\n* * *\n\nAn example of a non-linear pipeline might be a workflow with two alternative stages that rejoin at a later point. Let’s create a pipeline with alternative stages (`Add` or `Multiply`) by declaring how each stage feeds into the other stages.\n\nFirst, we declare four simple stages: `Input`, `Multiply`, `Add`, and `Result`.\n\nimport param\nimport panel as pn\npn.extension() \\# for notebook\n\nclass Input(param.Parameterized):\n\n    value1 \\= param.Integer(default\\=2, bounds\\=(0,10))\n    value2 \\= param.Integer(default\\=3, bounds\\=(0,10))\n\n    def panel(self):\n        return pn.Column(self.param.value1, self.param.value2)\n\nclass Multiply(param.Parameterized):\n\n    value1 \\= param.Integer()\n    value2 \\= param.Integer()\n    operator \\= param.String(default\\='\\*')\n\n    def panel(self):\n        return pn.pane.Markdown(f'# {self.value1} \\* {self.value2}')\n\n    @param.output('result')\n    def output(self):\n        return self.value1 \\* self.value2\n\nclass Add(param.Parameterized):\n\n    value1 \\= param.Integer()\n    value2 \\= param.Integer()\n    operator \\= param.String(default\\='+')\n\n    def panel(self):\n        return pn.pane.Markdown(f'# {self.value1} + {self.value2}')\n\n    @param.output('result')\n    def output(self):\n        return self.value1 + self.value2\n\nclass Result(param.Parameterized):\n\n    value1 \\= param.Integer()\n    value2 \\= param.Integer()\n    operator \\= param.String(default\\='')\n    result \\= param.Integer(default\\=0)\n\n    def panel(self):\n        return pn.pane.Markdown(f'# {self.value1} {self.operator} {self.value2} = {self.result}')\n\nNow let’s add these stages to a new Pipeline:\n\ndag \\= pn.pipeline.Pipeline()\n\ndag.add\\_stage('Input', Input)\ndag.add\\_stage('Multiply', Multiply)\ndag.add\\_stage('Add', Add)\ndag.add\\_stage('Result', Result)\n\nNow comes the important part that differs from a simple linear pipeline. After adding all the stages we have to express the alternative branching aspect. We can use the `define_graph` method to provide an adjacency map which declares how each stage feeds into the other stages. In this case the `Input` feeds into both `Multiply` and `Add` and both those stages feed into the `Result`:\n\ndag.define\\_graph({'Input': ('Multiply', 'Add'), 'Multiply': 'Result', 'Add': 'Result'})\n\nNow let’s view our result:\n\nHere is the complete code for this section in case you want to easily copy it:\n\nimport param\nimport panel as pn\npn.extension() \\# for notebook\n\nclass Input(param.Parameterized):\n\n    value1 \\= param.Integer(default\\=2, bounds\\=(0,10))\n    value2 \\= param.Integer(default\\=3, bounds\\=(0,10))\n\n    def panel(self):\n        return pn.Column(self.param.value1, self.param.value2)\n\nclass Multiply(param.Parameterized):\n\n    value1 \\= param.Integer()\n    value2 \\= param.Integer()\n    operator \\= param.String(default\\='\\*')\n\n    def panel(self):\n        return pn.pane.Markdown(f'# {self.value1} \\* {self.value2}')\n\n    @param.output('result')\n    def output(self):\n        return self.value1 \\* self.value2\n\nclass Add(param.Parameterized):\n\n    value1 \\= param.Integer()\n    value2 \\= param.Integer()\n    operator \\= param.String(default\\='+')\n\n    def panel(self):\n        return pn.pane.Markdown(f'# {self.value1} + {self.value2}')\n\n    @param.output('result')\n    def output(self):\n        return self.value1 + self.value2\n\nclass Result(param.Parameterized):\n\n    value1 \\= param.Integer()\n    value2 \\= param.Integer()\n    operator \\= param.String(default\\='')\n    result \\= param.Integer(default\\=0)\n\n    def panel(self):\n        return pn.pane.Markdown(f'# {self.value1} {self.operator} {self.value2} = {self.result}')\n\ndag \\= pn.pipeline.Pipeline()\n\ndag.add\\_stage('Input', Input)\ndag.add\\_stage('Multiply', Multiply)\ndag.add\\_stage('Add', Add)\ndag.add\\_stage('Result', Result)\n\ndag.define\\_graph({'Input': ('Multiply', 'Add'), 'Multiply': 'Result', 'Add': 'Result'})\n\ndag"
},
{
  "markdown": "## Authentication Templates[#](#authentication-templates \"Permalink to this heading\")\n\nAuthentication flows have multiple stages and in certain scenarios Panel has to serve pages that provide you with information when authentication has not succeeded or allow you the option of logging back into the application. Panel includes default templates for these cases, specifically it has:\n\n*   Error Template: The template that is displayed if the authentication errored for any reason, e.g. the user was not authorized to access the application.\n    \n*   Logout Template: The template served when a user hits the `/logout` endpoint.\n    \n\nBoth templates use Jinja2 syntax to render certain variables.\n\n## Error Template[#](#error-template \"Permalink to this heading\")\n\nThe error template is used to display errors when authentication errored out. This can occur for any number of reasons, e.g. authentication is misconfigured or the user is not authorized to access the application.\n\nThe template can be configured on the commandline using the `--oauth-error-template` option. The provided value must be a valid HTML file relative to the current working directory or an absolute path:\n\npanel serve app.py ... \\--oauth-error-template error.html\n\nWhen using `panel.serve` to dynamically serve the application you can configure the template with the `oauth_error_template` argument:\n\npn.serve(..., oauth\\_error\\_template\\='error.html')\n\nThe error template may be a completely static file or use Jinja2 templating syntax with the following variables:\n\n`npm_cdn`\n\nThe CDN to load NPM resources from.\n\n`title`\n\nThe HTML page title.\n\n`error_type`\n\nThe type of error being raised.\n\n`error`\n\nA short description of the error.\n\n`error_msg`\n\nThe full error message providing additional context.\n\n## Logout Template[#](#logout-template \"Permalink to this heading\")\n\nThe logout template is rendered when a user hits the `/logout` endpoint with authentication enabled. It is meant to be a simple static page that confirms that the logout process was completed and optionally allows the user to log back in.\n\nThe default template looks like this:\n\n![Basic Auth Login Form](https://panel.holoviz.org/_images/logout_template.png)\n\nThe template can be configured on the commandline using the `--logout-template` option. The provided value must be a valid HTML file relative to the current working directory or an absolute path:\n\npanel serve app.py ... \\--logout-template logout.html\n\nWhen using `panel.serve` to dynamically serve the application you can configure the template with the `logout_template` argument:\n\npn.serve(..., logout\\_template\\=logout.html')\n\nThe template may be a completely static HTML file or use Jinja2 templating syntax with the following variables being provided:\n\n`PANEL_CDN`\n\nThe URL of the CDN (or local path) that Panel resources will be loaded from."
},
{
  "markdown": "## Access Tokens[#](#access-tokens \"Permalink to this heading\")\n\nWhen an OAuth provider is configured it will obtain an access token for each user. This access token may be used to authenticate with the service, e.g. to make requests to the provider itself or to make requests to other applications that use the same OAuth provider.\n\n## Using access tokens[#](#using-access-tokens \"Permalink to this heading\")\n\nThe `access_token` can be accessed via the session variable `pn.state.access_token`. As the name suggests this token will allow you to access privileged resources on the users behalf. Generally it can be used by adding it as a Bearer token in the `Authorization` header to a request, e.g.:\n\nimport requests\n\nrequests.get(..., headers\\={'Authorization': f'Bearer {pn.state.access\\_token}'})\n\n## Refreshing access tokens[#](#refreshing-access-tokens \"Permalink to this heading\")\n\nDepending on the OAuth provider you are using the `access_token` may eventually expire, e.g. Okta tokens generally expire after 30 days by default while Azure defaults to 60 minute expiry. Since the `access_token` is cached as a cookie a user may still be logged in even when the `access_token` has expired. To ensure that you have access to a non-expired `access_token` you may set `--oauth-refresh-tokens` on the commandline, `PANEL_OAUTH_REFRESH_TOKENS=1` as an environment variable or the `oauth_refresh_tokens` argument to the `pn.serve` function if you are starting a server dynamically. Enabling this option will do a few things:\n\n1.  When a user accesses the application with an expired `access_token` it will automatically fetch a new `access_token` using the available `refresh_token`, or if no `refresh_token` is available it will force the user to re-authenticate.\n    \n2.  While a user session is running Panel will automatically schedule the `access_token` to be refreshed 10 seconds before it expires.\n    \n\nNote\n\nSome OAuth providers require you to explicitly request a `refresh_token` either in the settings or by requesting `offline_access` in the list of scopes."
},
{
  "markdown": "import param\nimport panel as pn\n\nfrom panel.reactive import ReactiveHTML\n\npn.extension(template\\='bootstrap')\n\nThis example shows how to use the `ReactiveHTML` component to develop a **Drawable Canvas**.\n\nclass Canvas(ReactiveHTML):\n\n    color \\= param.Color(default\\='#000000')\n\n    line\\_width \\= param.Number(default\\=1, bounds\\=(0.1, 10))\n\n    uri \\= param.String()\n\n    \\_template \\= \"\"\"\n    <canvas\n      id=\"canvas\"\n      style=\"border: 1px solid\"\n      width=\"${model.width}\"\n      height=\"${model.height}\"\n      onmousedown=\"${script('start')}\"\n      onmousemove=\"${script('draw')}\"\n      onmouseup=\"${script('end')}\"\n    >\n    </canvas>\n    <button id=\"clear\" onclick='${script(\"clear\")}'>Clear</button>\n    <button id=\"save\" onclick='${script(\"save\")}'>Save</button>\n    \"\"\"\n\n    \\_scripts \\= {\n        'render': \"\"\"\n          state.ctx = canvas.getContext(\"2d\")\n        \"\"\",\n        'start': \"\"\"\n          state.start = event\n          state.ctx.beginPath()\n          state.ctx.moveTo(state.start.offsetX, state.start.offsetY)\n        \"\"\",\n        'draw': \"\"\"\n          if (state.start == null)\n            return\n          state.ctx.lineTo(event.offsetX, event.offsetY)\n          state.ctx.stroke()\n        \"\"\",\n        'end': \"\"\"\n          delete state.start\n        \"\"\",\n        'clear': \"\"\"\n          state.ctx.clearRect(0, 0, canvas.width, canvas.height);\n        \"\"\",\n        'save': \"\"\"\n          data.uri = canvas.toDataURL();\n        \"\"\",\n        'line\\_width': \"\"\"\n          state.ctx.lineWidth = data.line\\_width;\n        \"\"\",\n        'color': \"\"\"\n          state.ctx.strokeStyle = data.color;\n        \"\"\"\n    }\n\ncanvas \\= Canvas(width\\=400, height\\=400)\n\n\\# We create a separate HTML element which syncs with the uri parameter of the Canvas\n\npng\\_view \\= pn.pane.HTML(height\\=400)\n\ncanvas.jslink(png\\_view, code\\={'uri': \"target.text = \\`<img src='${source.uri}'></img>\\`\"})\n\npn.Row(\n    canvas.controls(\\['color', 'line\\_width'\\]).servable(target\\='sidebar'),\n    pn.Column(\n        '# Drag on canvas to draw\\\\n To export the drawing to a png click save.',\n        pn.Row(\n            canvas,\n            png\\_view\n        ),\n    ).servable()\n)"
},
{
  "markdown": "Note\n\nThe `LeafletHeatMap` component is defined before the call to `pn.extension` to allow us to load the `_extension_name` and thereby initialize the required JS and CSS resources. Ordinarily the component would be defined in an external module.\n\nimport param\nimport pandas as pd\nimport panel as pn\nimport numpy as np\n\nfrom panel.reactive import ReactiveHTML\n\nclass LeafletHeatMap(ReactiveHTML):\n\n    attribution \\= param.String(doc\\=\"Tile source attribution.\")\n\n    blur \\= param.Integer(default\\=18, bounds\\=(5, 50), doc\\=\"Amount of blur to apply to heatmap\")\n\n    center \\= param.XYCoordinates(default\\=(0, 0), doc\\=\"The center of the map.\")\n\n    data \\= param.DataFrame(doc\\=\"The heatmap data to plot, should have 'x', 'y' and 'value' columns.\")\n\n    tile\\_url \\= param.String(doc\\=\"Tile source URL with {x}, {y} and {z} parameter\")\n\n    min\\_alpha \\= param.Number(default\\=0.2, bounds\\=(0, 1), doc\\=\"Minimum alpha of the heatmap\")\n\n    radius \\= param.Integer(default\\=25, bounds\\=(5, 50), doc\\=\"The radius of heatmap values on the map\")\n\n    x \\= param.String(default\\='longitude', doc\\=\"Column in the data with longitude coordinates\")\n\n    y \\= param.String(default\\='latitude', doc\\=\"Column in the data with latitude coordinates\")\n\n    value \\= param.String(doc\\=\"Column in the data with the data values\")\n\n    zoom \\= param.Integer(default\\=13, bounds\\=(0, 21), doc\\=\"The plots zoom-level\")\n\n    \\_template \\= \"\"\"\n    <div id=\"map\" style=\"width: 100%; height: 100%;\"></div>\n    \"\"\"\n\n    \\_scripts \\= {\n        'get\\_data': \"\"\"\n            const records = \\[\\]\n            for (let i=0; i<data.data.index.length; i++)\n                records.push(\\[data.data\\[data.y\\]\\[i\\], data.data\\[data.x\\]\\[i\\], data.data\\[data.value\\]\\[i\\]\\])\n            return records\n        \"\"\",\n        'render': \"\"\"\n            state.map = L.map(map).setView(data.center, data.zoom);\n            state.map.on('zoom', (e) => { data.zoom = state.map.getZoom() })\n            state.tileLayer = L.tileLayer(data.tile\\_url, {\n                attribution: data.attribution,\n                maxZoom: 21,\n                tileSize: 512,\n                zoomOffset: -1,\n            }).addTo(state.map);\n        \"\"\",\n        'after\\_layout': \"\"\"\n           state.map.invalidateSize()\n           state.heatLayer = L.heatLayer(self.get\\_data(), {blur: data.blur, radius: data.radius, max: 10, minOpacity: data.min\\_alpha}).addTo(state.map)\n        \"\"\",\n        'radius': \"state.heatLayer.setOptions({radius: data.radius})\",\n        'blur': \"state.heatLayer.setOptions({blur: data.blur})\",\n        'min\\_alpha': \"state.heatLayer.setOptions({minOpacity: data.min\\_alpha})\",\n        'zoom': \"state.map.setZoom(data.zoom)\",\n        'data': 'state.heatLayer.setLatLngs(self.get\\_data())'\n    }\n\n    \\_extension\\_name \\= 'leaflet'\n\n    \\_\\_css\\_\\_ \\= \\['https://unpkg.com/leaflet@1.7.1/dist/leaflet.css'\\]\n\n    \\_\\_javascript\\_\\_ \\= \\[\n        'https://unpkg.com/leaflet@1.7.1/dist/leaflet.js',\n        'https://cdn.jsdelivr.net/npm/leaflet.heat@0.2.0/dist/leaflet-heat.min.js'\n    \\]\n\npn.extension('leaflet', template\\='bootstrap')\n\nThis example demonstrates how to build a custom component wrapping leaflet.js.\n\nurl \\= \"https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all\\_month.csv\"\n\nearthquakes \\= pd.read\\_csv(url)\n\nheatmap \\= LeafletHeatMap(\n    attribution\\='Map data &copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors',\n    data\\=earthquakes\\[\\['longitude', 'latitude', 'mag'\\]\\],\n    min\\_height\\=500,\n    tile\\_url\\='https://server.arcgisonline.com/ArcGIS/rest/services/World\\_Imagery/MapServer/tile/{z}/{y}/{x}.jpg',\n    radius\\=30,\n    sizing\\_mode\\='stretch\\_both',\n    value\\='mag',\n    zoom\\=2,\n)\n\ndescription\\=pn.pane.Markdown(f'## Earthquakes between {earthquakes.time.min()} and {earthquakes.time.max()}\\\\n\\\\n\\[Data Source\\]({url})', sizing\\_mode\\=\"stretch\\_width\")\n\npn.Column(\n    description,\n    pn.Row(\n        heatmap.controls(\\['blur', 'min\\_alpha', 'radius', 'zoom'\\]).servable(target\\='sidebar'),\n        heatmap.servable(),\n        sizing\\_mode\\='stretch\\_both'\n    ),\n    sizing\\_mode\\='stretch\\_both'\n)"
},
{
  "markdown": "## Wrapping Material UI components[#](#wrapping-material-ui-components \"Permalink to this heading\")\n\nNote\n\nThe `MaterialBase` component is defined before the call to `pn.extension` to allow us to load the `_extension_name` and thereby initialize the required JS and CSS resources. Ordinarily the component would be defined in an external module.\n\nimport param\nimport panel as pn\n\nfrom panel.reactive import ReactiveHTML\n\nclass MaterialBase(ReactiveHTML):\n\n    \\_\\_javascript\\_\\_ \\= \\['https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js'\\]\n\n    \\_\\_css\\_\\_ \\= \\['https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css'\\]\n\n    \\_extension\\_name \\= 'material\\_ui'\n\npn.extension('material\\_ui', template\\='material')\n\nThis example demonstrates how to wrap Material UI components using `ReactiveHTML`.\n\nclass MaterialTextField(MaterialBase):\n\n    value \\= param.String(default\\='')\n\n    \\_template \\= \"\"\"\n    <label id=\"text-field\" class=\"mdc-text-field mdc-text-field--filled\">\n      <span class=\"mdc-text-field\\_\\_ripple\"></span>\n      <span class=\"mdc-floating-label\">Label</span>\n      <input id=\"text-input\" type=\"text\" class=\"mdc-text-field\\_\\_input\" aria-labelledby=\"my-label\" value=\"${value}\"></input>\n      <span class=\"mdc-line-ripple\"></span>\n    </label>\n    \"\"\"\n\n    \\_dom\\_events \\= {'text-input': \\['change'\\]}\n\n    \\_scripts \\= {\n        'render': \"mdc.textField.MDCTextField.attachTo(text\\_field);\"\n    }\n\nclass MaterialSlider(MaterialBase):\n\n    end \\= param.Number(default\\=100)\n\n    start \\= param.Number(default\\=0)\n\n    value \\= param.Number(default\\=50)\n\n    \\_template \\= \"\"\"\n    <div id=\"mdc-slider\" class=\"mdc-slider\" style=\"width: ${model.width}px\">\n      <input id=\"slider-input\" class=\"mdc-slider\\_\\_input\" min=\"${start}\" max=\"${end}\" value=\"${value}\">\n      </input>\n      <div class=\"mdc-slider\\_\\_track\">\n        <div class=\"mdc-slider\\_\\_track--inactive\"></div>\n        <div class=\"mdc-slider\\_\\_track--active\">\n          <div class=\"mdc-slider\\_\\_track--active\\_fill\"></div>\n        </div>\n      </div>\n      <div class=\"mdc-slider\\_\\_thumb\">\n        <div class=\"mdc-slider\\_\\_thumb-knob\"></div>\n      </div>\n    </div>\n    \"\"\"\n\n    \\_scripts \\= {\n        'render': \"\"\"\n            slider\\_input.setAttribute('value', data.value)\n            state.slider = mdc.slider.MDCSlider.attachTo(mdc\\_slider)\n        \"\"\",\n        'value': \"\"\"\n            state.slider.setValue(data.value)\n        \"\"\"\n    }\n\nslider     \\= MaterialSlider(value\\=5, start\\=0, end\\=100, width\\=200)\ntext\\_field \\= MaterialTextField()\n\npn.Row(\n    pn.Column(\n        slider.controls(\\['value'\\]),\n        slider\n    ),\n    pn.Column(\n        text\\_field.controls(\\['value'\\]),\n        text\\_field\n    ),\n).servable()"
},
{
  "markdown": "## Wrap a Vue component[#](#wrap-a-vue-component \"Permalink to this heading\")\n\nThis example will demonstrate how to wrap a Vue.js component in panel. We will build a series of classes culminating in a Panel+Vue.js custom component inspired by medicinal chemistry.\n\nThis guide is heavily inspired by [Web Development with Python and Vue.js Components](https://blog.reverielabs.com/python-vue-components/).\n\n## What is a Vue Component?[#](#what-is-a-vue-component \"Permalink to this heading\")\n\n[Vue components](https://vuejs.org/v2/guide/components.html) are self-contained elements that can render HTML/CSS, store data within Javascript variables, and much more. Once defined, they are callable as HTML tags. For example, within existing HTML a Vue component can be rendered like below:\n\n![Vue Component](https://panel.holoviz.org/_images/vue_bootstrap_component.png)\n\nHere, the Vue component tags `<v-component></v-component>` are responsible for rendering a part of the frontend that takes user input.\n\nThe components are usually defined in a .vue file and require Webpack to serve.\n\nWith Panel you can take a **simpler approach**, there is no need to configure, learn and maintain an advanced javascript build tool chain to utilize Vue.js. We will show you how this is done below using Panels [ReactiveHTML](https://panel.holoviz.org/how_to/custom_components/custom_reactiveHTML.html).\n\n## Let’s get started[#](#let-s-get-started \"Permalink to this heading\")\n\nIn order to ensure that all the resources we need (such as Vue.js) are loaded appropriately we need to declare baseclasses which declare these dependencies **before** we run the `panel.extension`:\n\nimport panel as pn\nimport param\nimport requests\n\nclass BasicVueComponent(pn.reactive.ReactiveHTML):\n\n    \\_template \\= \"\"\"\n    <div id=\"container\" style=\"height:100%; width:100%; background:#0072B5; border-radius:4px; padding:6px; color:white\">\n      <vue-component></vue-component>\n    </div>\n    \"\"\"\n\n    \\_scripts \\= {\n        \"render\": \"\"\"\n    const template = \"<div>Hello Panel + Vue.js World!</div>\"\n    const vue\\_component = {template: template}\n    el=new Vue({\n        el: container,\n        components: {\n            'vue-component' : vue\\_component\n        }\n    })\n    \"\"\"\n    }\n\n    \\_extension\\_name \\= 'vue'\n\n    \\_\\_javascript\\_\\_ \\= \\[\n        \"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"\n    \\]\n\nclass BootstrapVueComponent(BasicVueComponent):\n\n    \\_\\_javascript\\_\\_\\= \\[\n        \"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\",\n        \"https://unpkg.com/bootstrap-vue@latest/dist/bootstrap-vue.min.js\",\n    \\]\n    \\_\\_css\\_\\_\\=\\[\n        \"https://unpkg.com/bootstrap/dist/css/bootstrap.min.css\",\n        \"https://unpkg.com/bootstrap-vue@latest/dist/bootstrap-vue.min.css\",\n    \\]\n\npn.extension('vue', sizing\\_mode\\=\"stretch\\_width\", template\\=\"bootstrap\")\n\nIn this example we are building a Vue.js component containing an input field and a button that will update the `value` parameter of the `PDBInput` component:\n\nclass PDBInput(BootstrapVueComponent):\n\n    value \\= param.String()\n\n    \\_template \\= \"\"\"\n    <div id=\"container\" style=\"height:100%; width:100%\">\n      <vue-component></vue-component>\n    </div>\n    \"\"\"\n\n    \\_scripts \\= {\n        \"render\": \"\"\"\n    const template = \\`\n    <div>\n      <b-form v-on:keydown.enter.prevent>\n        <b-form-input v-model=\"pdb\\_id\" placeholder=\"Enter PDB ID\" required></b-form-input>\n        <b-button variant=\"secondary\" size=\"sm\" v-on:click=\"setPDBId\" style=\"margin-top:10px;width:100%\">\n            Retrieve PDB metadata\n        </b-button>\n      </b-form>\n    </div>\\`\n    const vue\\_component = {\n      template: template,\n      delimiters: \\['\\[\\[', '\\]\\]'\\],\n      data: function () {\n        return {\n          pdb\\_id: data.value,\n        }\n      },\n      methods: {\n        setPDBId() {\n          data.value = this.pdb\\_id\n        }\n      }\n    }\n    const el = new Vue({\n        el: container,\n        components: {\n            'vue-component': vue\\_component\n        }\n    })\n    \"\"\"\n    }\n\n## Featurize Protein Structure[#](#featurize-protein-structure \"Permalink to this heading\")\n\nUse the Vue component below to retrieve PDB metadata from [KLIFS](https://klifs.net/). For example for _`2xyu`_ or _`4WSQ`_:\n\nURL \\= \"https://klifs.net/api/structures\\_pdb\\_list\"\n\ndef get\\_pdb\\_data\\_from\\_klifs(pdb\\_id):\n    if not pdb\\_id:\n        return \"Please specify a PDB ID.\"\n\n    params \\= {'pdb-codes': pdb\\_id}\n    res \\= requests.get(url \\= URL, params \\= params)\n    data \\= res.json()\n\n    if res.status\\_code \\== 400:\n        return f\"Error 400, Could not get PDB {pdb\\_id}\", data\\[1\\]\n\n    return data\\[0\\]\n\npdb\\_input \\= PDBInput(height\\=90, max\\_width\\=800)\n\niget\\_klifs\\_data \\= pn.bind(get\\_pdb\\_data\\_from\\_klifs, pdb\\_id\\=pdb\\_input.param.value)\n\npn.Column(\n    pdb\\_input,\n    pn.pane.JSON(iget\\_klifs\\_data, theme\\=\"light\")\n).servable()"
},
{
  "markdown": "## Reactive Tables[#](#reactive-tables \"Permalink to this heading\")\n\nimport param\nimport panel as pn\n\nfrom bokeh.sampledata.iris import flowers\nfrom bokeh.sampledata.autompg import autompg\\_clean\nfrom bokeh.sampledata.population import data\nfrom panel.viewable import Viewer\n\npn.extension(template\\='fast')\n\nThis example demonstrates Panel’s reactive programming paradigm using the Param library to express parameters, plus methods with computation depending on those parameters. This pattern can be used to update the displayed views whenever a parameter value changes, without re-running computation unnecessarily.\n\nclass ReactiveTables(Viewer):\n\n    dataset \\= param.ObjectSelector(default\\='iris', objects\\=\\['iris', 'autompg', 'population'\\])\n\n    rows \\= param.Integer(default\\=10, bounds\\=(0, 19))\n\n    @param.depends('dataset')\n    def data(self):\n        if self.dataset \\== 'iris':\n            return flowers\n        elif self.dataset \\== 'autompg':\n            return autompg\\_clean\n        else:\n            return data\n\n    @param.depends('data')\n    def summary(self):\n        return self.data().describe()\n\n    @param.depends('data', 'rows')\n    def table(self):\n        return self.data().iloc\\[:self.rows\\]\n\n    def \\_\\_panel\\_\\_(self):\n        return pn.Row(\n            pn.Param(self, name\\=\"Settings\", width\\=300),\n\t\t\tpn.Spacer(width\\=10),\n            pn.Column(\n\t\t\t    \"## Description\",\n\t\t\t\tpn.pane.DataFrame(self.summary, sizing\\_mode\\='stretch\\_width'),\n\t\t\t\t\"## Table\",\n\t\t\t\tpn.pane.DataFrame(self.table, sizing\\_mode\\='stretch\\_width'),\n\t\t\t)\n        )\n\nReactiveTables().servable()"
},
{
  "markdown": "## Plot Viewer[#](#plot-viewer \"Permalink to this heading\")\n\nimport param\nimport panel as pn\n\nfrom bokeh.sampledata.iris import flowers\nfrom panel.viewable import Viewer\n\npn.extension(template\\='fast')\nimport hvplot.pandas\n\nThis example demonstrates the use of a `Viewer` class to build a reactive app. It uses the [iris dataset](https://en.wikipedia.org/wiki/Iris_flower_data_set) which is a standard example used to illustrate machine-learning and visualization techniques.\n\nWe will start by using the dataframe with these five features and then create a `Selector` parameter to develop menu options for different input features. Later we will define the core plotting function in a `plot` method and define the layout in the `__panel__` method of the `IrisDashboard` class.\n\nThe `plot` method watches the `X_variable` and `Y_variable` using the `param.depends` [decorator](https://www.google.com/search?q=python+decorator). The `plot` method plots the features selected for `X_variable` and `Y_variable` and colors them using the `species` column.\n\ninputs \\= \\['sepal\\_length', 'sepal\\_width', 'petal\\_length', 'petal\\_width'\\]\n\nclass IrisDashboard(Viewer):\n    X\\_variable \\= param.Selector(objects\\=inputs, default\\=inputs\\[0\\])\n    Y\\_variable \\= param.Selector(objects\\=inputs, default\\=inputs\\[1\\])\n\n    @param.depends('X\\_variable', 'Y\\_variable')\n    def plot(self):\n        return flowers.hvplot.scatter(x\\=self.X\\_variable, y\\=self.Y\\_variable, by\\='species').opts(height\\=600)\n\n    def \\_\\_panel\\_\\_(self):\n        return pn.Row(\n            pn.Param(self, width\\=300, name\\=\"Plot Settings\"),\n            self.plot\n        )\n\nIrisDashboard(name\\='Iris\\_Dashboard').servable()"
},
{
  "markdown": "## Bokeh property editor[#](#bokeh-property-editor \"Permalink to this heading\")\n\nimport numpy as np\nimport panel as pn\n\npn.extension(template\\='bootstrap')\n\nBokeh’s property system defines the valid properties for all the different Bokeh models. Using `jslink` we can easily tie a widget value to Bokeh properties on another widget or plot. This example defines functions that generate a property editor for the most common Bokeh properties. First, we define two functions that generate a set of widgets linked to a plot:\n\nfrom bokeh.core.enums import LineDash, LineCap, MarkerType, NamedColor\nfrom bokeh.core.property.vectorization import Value\nfrom bokeh.models.plots import Model, \\_list\\_attr\\_splat\n\ndef meta\\_widgets(model, width\\=500):\n    tabs \\= pn.Tabs(width\\=width)\n    widgets \\= get\\_widgets(model, width\\=width\\-25)\n    if widgets:\n        tabs.append((type(model).\\_\\_name\\_\\_, widgets))\n    for p, v in model.properties\\_with\\_values().items():\n        if isinstance(v, \\_list\\_attr\\_splat):\n            v \\= v\\[0\\]\n        if isinstance(v, Model):\n            subtabs \\= meta\\_widgets(v)\n            if subtabs is not None:\n                tabs.append((p.title(), subtabs))\n\n    if hasattr(model, 'renderers'):\n        for r in model.renderers:\n            tabs.append((type(r).\\_\\_name\\_\\_, meta\\_widgets(r)))\n    if hasattr(model, 'axis') and isinstance(model.axis, list):\n        for pre, axis in zip('XY', model.axis):\n            tabs.append(('%s\\-Axis' % pre, meta\\_widgets(axis)))\n    if hasattr(model, 'grid'):\n        for pre, grid in zip('XY', model.grid):\n            tabs.append(('%s\\-Grid' % pre, meta\\_widgets(grid)))\n    if not widgets and not len(tabs) \\> 1:\n        return None\n    elif not len(tabs) \\> 1:\n        return tabs\\[0\\]\n    return tabs\n\ndef get\\_widgets(model, skip\\_none\\=True, \\*\\*kwargs):\n    widgets \\= \\[\\]\n    for p, v in model.properties\\_with\\_values().items():\n        if isinstance(v, Value):\n            v \\= v.value\n        if v is None and skip\\_none:\n            continue\n\n        ps \\= dict(name\\=p, value\\=v, \\*\\*kwargs)\n        if 'alpha' in p:\n            w \\= pn.widgets.FloatSlider(start\\=0, end\\=1, \\*\\*ps)\n        elif 'color' in p:\n            if v in list(NamedColor):\n                w \\= pn.widgets.Select(options\\=list(NamedColor), \\*\\*ps)\n            else:\n                w \\= pn.widgets.ColorPicker(\\*\\*ps)\n        elif p\\==\"width\":\n            w \\= pn.widgets.IntSlider(start\\=400, end\\=800, \\*\\*ps)\n        elif p in \\[\"inner\\_width\", \"outer\\_width\"\\]:\n            w \\= pn.widgets.IntSlider(start\\=0, end\\=20, \\*\\*ps)\n        elif p.endswith('width'):\n            w \\= pn.widgets.FloatSlider(start\\=0, end\\=20, \\*\\*ps)\n        elif 'marker' in p:\n            w \\= pn.widgets.Select(options\\=list(MarkerType), \\*\\*ps)\n        elif p.endswith('cap'):\n            w \\= pn.widgets.Select(options\\=list(LineCap), \\*\\*ps)\n        elif p \\== 'size':\n            w \\= pn.widgets.FloatSlider(start\\=0, end\\=20, \\*\\*ps)\n        elif p.endswith('text') or p.endswith('label'):\n            w \\= pn.widgets.TextInput(\\*\\*ps)\n        elif p.endswith('dash'):\n            patterns \\= list(LineDash)\n            w \\= pn.widgets.Select(options\\=patterns, value\\=v or patterns\\[0\\], \\*\\*kwargs)\n        else:\n            continue\n        w.jslink(model, value\\=p)\n        widgets.append(w)\n    return pn.Column(\\*sorted(widgets, key\\=lambda w: w.name))\n\n\\# Having defined these helper functions we can now declare a plot and use the \\`\\`meta\\_widgets\\`\\` function to generate the GUI:\n\nfrom bokeh.plotting import figure\n\np \\= figure(title\\='This is a title', x\\_axis\\_label\\='x-axis', y\\_axis\\_label\\='y-axis')\nxs \\= np.linspace(0, 10)\nr \\= p.scatter(xs, np.sin(xs))\n\neditor\\=pn.Row(meta\\_widgets(p), p)\n\neditor.servable()"
},
{
  "markdown": "## Deck.gl JSON Editor[#](#deck-gl-json-editor \"Permalink to this heading\")\n\nimport json\nimport panel as pn\n\npn.extension('codeeditor', 'deckgl', template\\='bootstrap')\n\nThis example demonstrates how to `jslink` a JSON editor to a DeckGL pane to enable super fast, live editing of a plot:\n\nMAPBOX\\_KEY \\= \"pk.eyJ1IjoicGFuZWxvcmciLCJhIjoiY2s1enA3ejhyMWhmZjNobjM1NXhtbWRrMyJ9.B\\_frQsAVepGIe-HiOJeqvQ\"\n\njson\\_spec \\= {\n    \"initialViewState\": {\n        \"bearing\": \\-27.36,\n        \"latitude\": 52.2323,\n        \"longitude\": \\-1.415,\n        \"maxZoom\": 15,\n        \"minZoom\": 5,\n        \"pitch\": 40.5,\n        \"zoom\": 6\n    },\n    \"layers\": \\[{\n        \"@@type\": \"HexagonLayer\",\n        \"autoHighlight\": True,\n        \"coverage\": 1,\n        \"data\": \"https://raw.githubusercontent.com/uber-common/deck.gl-data/master/examples/3d-heatmap/heatmap-data.csv\",\n        \"elevationRange\": \\[0, 3000\\],\n        \"elevationScale\": 50,\n        \"extruded\": True,\n        \"getPosition\": \"@@=\\[lng, lat\\]\",\n        \"id\": \"8a553b25-ef3a-489c-bbe2-e102d18a3211\", \"pickable\": True\n    }\\],\n    \"mapStyle\": \"mapbox://styles/mapbox/dark-v9\",\n    \"views\": \\[{\"@@type\": \"MapView\", \"controller\": True}\\]\n}\n\nview\\_editor \\= pn.widgets.CodeEditor(\n    value\\=json.dumps(json\\_spec\\['initialViewState'\\], indent\\=4),\n    theme\\= 'monokai', width\\=500, height\\=225\n)\nlayer\\_editor \\= pn.widgets.CodeEditor(\n    value\\=json.dumps(json\\_spec\\['layers'\\]\\[0\\], indent\\=4),\n    theme\\= 'monokai', width\\=500, height\\=365\n)\n\ndeck\\_gl \\= pn.pane.DeckGL(json\\_spec, mapbox\\_api\\_key\\=MAPBOX\\_KEY, sizing\\_mode\\='stretch\\_width', height\\=600)\n\nview\\_editor.jscallback(args\\={'deck\\_gl': deck\\_gl}, value\\=\"deck\\_gl.initialViewState = JSON.parse(cb\\_obj.code)\")\nlayer\\_editor.jscallback(args\\={'deck\\_gl': deck\\_gl}, value\\=\"deck\\_gl.layers = \\[JSON.parse(cb\\_obj.code)\\]\")\n\npn.Row(pn.Column(view\\_editor, layer\\_editor), deck\\_gl).servable()"
},
{
  "markdown": "## HoloViews Glyph Link[#](#holoviews-glyph-link \"Permalink to this heading\")\n\nimport numpy as np\nimport panel as pn\n\nimport holoviews as hv\nimport holoviews.plotting.bokeh\n\npn.extension()\n\nHoloViews-generated Bokeh plots can be statically linked to widgets that control their properties, allowing you to export static HTML files that allow end-user customization of appearance.\n\nfrom bokeh.core.enums import MarkerType\n\ncolors \\= \\[\"black\", \"red\", \"blue\", \"green\", \"gray\"\\]\nmarkers \\= list(MarkerType)\n\n\\# Define widget for properties we want to change\nalpha\\_widget \\= pn.widgets.FloatSlider(value\\=0.5, start\\=0, end\\=1, name\\='Alpha')\nsize\\_widget \\= pn.widgets.FloatSlider(value\\=12, start\\=3, end\\=20, name\\='Size')\ncolor\\_widget \\= pn.widgets.ColorPicker(value\\='#f80000', name\\='Color')\nmarker\\_widget \\= pn.widgets.Select(options\\=markers, value\\='circle', name\\='Marker')\n\n\\# Declare a Points object and apply some options\npoints \\= hv.Points(np.random.randn(200, 2)).options(\n    padding\\=0.1, height\\=500, line\\_color\\='black', responsive\\=True)\n\n\\# Link the widget value parameter to the property on the glyph\nalpha\\_widget.jslink(points, value\\='glyph.fill\\_alpha')\nsize\\_widget.jslink(points, value\\='glyph.size')\ncolor\\_widget.jslink(points, value\\='glyph.fill\\_color')\nmarker\\_widget.jslink(points, value\\='glyph.marker')\n\npn.Row(pn.Column(alpha\\_widget, color\\_widget, marker\\_widget, size\\_widget), points).servable()"
},
{
  "markdown": "## Plotly Link[#](#plotly-link \"Permalink to this heading\")\n\nimport numpy as np\nimport panel as pn\n\npn.extension('plotly', template\\='bootstrap')\n\nSince Plotly plots are represented as simple JavaScript objects, we can easily define a JS callback to modify the data and trigger an update in a plot:\n\nxs, ys \\= np.mgrid\\[\\-3:3:0.2, \\-3:3:0.2\\]\ncontour \\= dict(ncontours\\=4, type\\='contour', z\\=np.sin(xs\\*\\*2\\*ys\\*\\*2))\nlayout \\= {'width': 600, 'height': 500, 'margin': {'l': 8, 'b': 8, 'r': 8, 't': 8}}\nfig \\= dict(data\\=contour, layout\\=layout)\nplotly\\_pane \\= pn.pane.Plotly(fig, width\\=600, height\\=500)\n\nbuttons \\= pn.widgets.RadioButtonGroup(value\\='Medium', options\\=\\['Low', 'Medium', 'High'\\], button\\_type\\=\"success\")\n\nrange\\_callback \\= \"\"\"\nvar ncontours = \\[2, 5, 10\\]\ntarget.data\\[0\\].ncontours = ncontours\\[source.active\\]\ntarget.properties.data.change.emit()\n\"\"\"\n\nbuttons.jslink(plotly\\_pane, code\\={'active': range\\_callback})\n\npn.Column(buttons, plotly\\_pane).servable()"
},
{
  "markdown": "## Vega Link[#](#vega-link \"Permalink to this heading\")\n\nimport panel as pn\n\npn.extension('vega', template\\='bootstrap')\n\nThis example demonstrates how to link Panel widgets to a Vega pane by editing the Vega spec using callbacks and triggering updates in the plot.\n\nimdb \\= {\n  \"$schema\": \"https://vega.github.io/schema/vega-lite/v4.json\",\n  \"data\": {\"url\": \"https://raw.githubusercontent.com/vega/vega/master/docs/data/movies.json\"},\n  \"transform\": \\[{\n    \"filter\": {\"and\": \\[\n      {\"field\": \"IMDB Rating\", \"valid\": True},\n      {\"field\": \"Rotten Tomatoes Rating\", \"valid\": True}\n    \\]}\n  }\\],\n  \"mark\": \"rect\",\n  \"width\": \"container\",\n  \"height\": 400,\n  \"encoding\": {\n    \"x\": {\n      \"bin\": {\"maxbins\":60},\n      \"field\": \"IMDB Rating\",\n      \"type\": \"quantitative\"\n    },\n    \"y\": {\n      \"bin\": {\"maxbins\": 40},\n      \"field\": \"Rotten Tomatoes Rating\",\n      \"type\": \"quantitative\"\n    },\n    \"color\": {\n      \"aggregate\": \"count\",\n      \"type\": \"quantitative\"\n    }\n  },\n  \"config\": {\n    \"view\": {\n      \"stroke\": \"transparent\"\n    }\n  }\n}\n\nvega \\= pn.pane.Vega(imdb, height\\=425)\n\n\\# Declare range slider to adjust the color limits\ncolor\\_lims \\= pn.widgets.RangeSlider(name\\='Color limits', start\\=0, end\\=125, value\\=(0, 40), step\\=1)\ncolor\\_lims.jslink(vega, code\\={'value': \"\"\"\ntarget.data.encoding.color.scale = {domain: source.value};\ntarget.properties.data.change.emit()\n\"\"\"});\n\n\\# Declare slider to control the number of bins along the x-axis\nimdb\\_bins \\= pn.widgets.IntSlider(name\\='IMDB Ratings Bins', start\\=0, end\\=125, value\\=60, step\\=25)\nimdb\\_bins.jslink(vega, code\\={'value': \"\"\"\ntarget.data.encoding.x.bin.maxbins = source.value;\ntarget.properties.data.change.emit()\n\"\"\"});\n\n\\# Declare slider to control the number of bins along the y-axis\ntomato\\_bins \\= pn.widgets.IntSlider(name\\='Rotten Tomato Ratings Bins', start\\=0, end\\=125, value\\=40, step\\=25)\ntomato\\_bins.jslink(vega, code\\={'value': \"\"\"\ntarget.data.encoding.y.bin.maxbins = source.value;\ntarget.properties.data.change.emit()\n\"\"\"});\n\npn.Row(\n    vega, pn.Column(color\\_lims, imdb\\_bins, tomato\\_bins)\n)"
},
{
  "markdown": "## param.Action Example[#](#param-action-example \"Permalink to this heading\")\n\nimport param\nimport panel as pn\n\npn.extension(template\\='bootstrap')\n\nThis example demonstrates how to use `param.Action` to trigger an update in a method that depends on that parameter. Actions can trigger any function, but if we simply want to trigger a method that depends on that action, then we can define a small `lambda` function that triggers the parameter explicitly:\n\nclass ActionExample(param.Parameterized):\n    \"\"\"\n    Demonstrates how to use param.Action to trigger an update.\n    \"\"\"\n\n    action \\= param.Action(default\\=lambda x: x.param.trigger('action'), label\\='Click here!')\n\n    number \\= param.Integer(default\\=0)\n\n    @param.depends('action')\n    def get\\_number(self):\n        self.number += 1\n        return f'Number: {self.number}'\n\naction\\_example \\= ActionExample()\n\npn.Row(\n    pn.Column(\n        pn.panel(action\\_example, show\\_name\\=False, margin\\=0, widgets\\={\"action\": {\"button\\_type\": \"primary\"}, \"number\": {\"disabled\": True}}),\n        '\\*\\*Click the button\\*\\* to trigger an update in the output.'\n    ),\n    action\\_example.get\\_number,\n).servable()"
},
{
  "markdown": "## Loading Indicator[#](#loading-indicator \"Permalink to this heading\")\n\nimport time\nimport panel as pn\nimport holoviews as hv\nimport numpy as np\nimport holoviews.plotting.bokeh\n\npn.extension(loading\\_spinner\\='dots', loading\\_color\\='#00aa41', template\\='bootstrap')\nhv.extension('bokeh')\n\nEvery pane, widget and layout provides the **`loading` parameter**. When set to `True` a spinner will overlay the panel and indicate that the panel is currently loading. When you set `loading` to false the spinner is removed.\n\nUsing the `pn.extension` or by setting the equivalent parameters on `pn.config` we can select between different visual styles and colors for the loading indicator.\n\npn.extension(loading\\_spinner\\='dots', loading\\_color\\='#00aa41')\n\nWe can enable the loading indicator for reactive functions annotated with `depends` or `bind` globally using:\n\npn.param.ParamMethod.loading\\_indicator \\= True\n\nAlternatively we can enable it for a specific function by passing the `loading_indicator=True` argument to `pn.panel` or directly to the underlying `ParamMethod`/`ParamFunction` object:\n\nbutton \\= pn.widgets.Button(name\\=\"UPDATE\", button\\_type\\=\"primary\", sizing\\_mode\\='stretch\\_width')\n\ndef random\\_plot(event):\n    if event: time.sleep(5)\n    return hv.Points(np.random.rand(100, 2)).opts(\n        responsive\\=True, height\\=400, size\\=8, color\\=\"green\")\n\npn.Column(\n    button,\n    pn.param.ParamFunction(pn.bind(random\\_plot, button), loading\\_indicator\\=True)\n).servable()"
},
{
  "markdown": "## Param Subobjects[#](#param-subobjects \"Permalink to this heading\")\n\nimport panel as pn\nimport param\nimport numpy as np\n\npn.extension(template\\='bootstrap')\n\nThis example demonstrates how to use the Param library to express nested hierarchies of classes whose parameters can be edited in a GUI, without tying those classes to Panel or any other GUI framework.\n\nFor this purpose we create a hierarchy of three classes that draw Bokeh plots. At the top level there is a `ShapeViewer` that allows selecting between different `Shape` classes. The Shape classes include a subobject controlling the `Style` (i.e. the `color` and `line_width`) of the drawn shapes.\n\nIn each case, `param.depends` is used to indicate which parameter that computation depends on, either a parameter of this object (as for `radius` below) or a parameter of a subobject (i.e., a parameter of one of this object’s parameters, as for `style.color` below).\n\nfrom bokeh.plotting import figure\n\nclass Style(param.Parameterized):\n\n    color \\= param.Color(default\\='#0f6f0f')\n\n    line\\_width \\= param.Number(default\\=2, bounds\\=(0, 10))\n\nclass Shape(param.Parameterized):\n\n    radius \\= param.Number(default\\=1, bounds\\=(0, 1))\n\n    style \\= param.Parameter(precedence\\=3)\n\n    def \\_\\_init\\_\\_(self, \\*\\*params):\n        if 'style' not in params:\n            params\\['style'\\] \\= Style(name\\='Style')\n        super(Shape, self).\\_\\_init\\_\\_(\\*\\*params)\n        self.figure \\= figure(x\\_range\\=(\\-1, 1), y\\_range\\=(\\-1, 1), sizing\\_mode\\=\"stretch\\_width\", height\\=400)\n        self.renderer \\= self.figure.line(\\*self.\\_get\\_coords())\n        self.\\_update\\_style()\n\n    @param.depends('style.color', 'style.line\\_width', watch\\=True)\n    def \\_update\\_style(self):\n        self.renderer.glyph.line\\_color \\= self.style.color\n        self.renderer.glyph.line\\_width \\= self.style.line\\_width\n\n    def \\_get\\_coords(self):\n        return \\[\\], \\[\\]\n\n    def view(self):\n        return self.figure\n\nclass Circle(Shape):\n\n    n \\= param.Integer(default\\=100, precedence\\=-1)\n\n    def \\_get\\_coords(self):\n        angles \\= np.linspace(0, 2\\*np.pi, self.n+1)\n        return (self.radius\\*np.sin(angles),\n                self.radius\\*np.cos(angles))\n\n    @param.depends('radius', watch\\=True)\n    def update(self):\n        xs, ys \\= self.\\_get\\_coords()\n        self.renderer.data\\_source.data.update({'x': xs, 'y': ys})\n\nclass NGon(Circle):\n\n    n \\= param.Integer(default\\=3, bounds\\=(3, 10), precedence\\=1)\n\n    @param.depends('radius', 'n', watch\\=True)\n    def update(self):\n        xs, ys \\= self.\\_get\\_coords()\n        self.renderer.data\\_source.data.update({'x': xs, 'y': ys})\n\nshapes \\= \\[NGon(name\\='NGon'), Circle(name\\='Circle')\\]\n\nHaving defined our basic domain model (of shapes in this case), we can now make a generic viewer using Panel without requiring or encoding information about the underlying domain objects. Here, we define a `view` method that will be called whenever any of the possible parameters that a shape might have changes, without necessarily knowing what those are (as for `shape.param` below). That way, if someone adds a `Line` shape that has no `n` parameter but has `orientation`, the viewer should continue to work and be responsive. We can also depend on specific parameters (as for `shape.radius`) if we wish. Either way, the panel should then reactively update to each of the shape’s parameters as they are changed in the browser:\n\nclass ShapeViewer(param.Parameterized):\n\n    shape \\= param.ObjectSelector(default\\=shapes\\[0\\], objects\\=shapes)\n\n    @param.depends('shape', 'shape.param')\n    def view(self):\n        return self.shape.view()\n\n    @param.depends('shape', 'shape.radius')\n    def title(self):\n        return '## %s (radius=%.1f)' % (type(self.shape).\\_\\_name\\_\\_, self.shape.radius)\n\n    def panel(self):\n        return pn.Column(self.title, self.view, sizing\\_mode\\=\"stretch\\_width\")\n\n\\# Instantiate and display ShapeViewer\nviewer \\= ShapeViewer()\nsubpanel \\= pn.Column()\n\npn.Row(\n    pn.Column(pn.Param(viewer.param, expand\\_layout\\=subpanel, name\\=\"Shape Settings\"), subpanel),\n    viewer.panel(),\n).servable()"
},
{
  "markdown": "## Param Precedence[#](#param-precedence \"Permalink to this heading\")\n\nimport panel as pn\nimport param\n\npn.extension(template\\='bootstrap')\n\nThis example demonstrates how to order and hide widgets by means of the `precedence` and `display_threshold` attributes.\n\nEach `Parameter` object has a `precedence` attribute that is defined as follows in the documentation of `param`:\n\n> `precedence` is a value, usually in the range 0.0 to 1.0, that allows the order of Parameters in a class to be defined (for e.g. in GUI menus). A negative precedence indicates a parameter that should be hidden in e.g. GUI menus.\n\nA `Param` pane has a `display_threshold` attribute defaulting to 0 and defined as follows:\n\n> Parameters with precedence below this value are not displayed.\n\nThe interactive example below helps to understand how the interplay between these two attributes affects the display of widgets.\n\nThe `PrecedenceTutorial` class emulates a dummy app whose display we want to control and that consists of three input parameters, `x`, `y` and `z`. These parameters will be displayed by `panel` with their associated default widgets. Additionally, the class declares the four parameters that will control the dummy app display: `x_precedence`, `y_precedence` and `z_precedence` and `dummy_app_display_threshold`.\n\nclass Precedence(param.Parameterized):\n\n    \\# Parameters of the dummy app.\n    x \\= param.Number(precedence\\=-1)\n    y \\= param.Boolean(precedence\\=3)\n    z \\= param.String(precedence\\=2)\n\n    \\# Parameters of the control app.\n    x\\_precedence \\= param.Number(default\\=x.precedence, bounds\\=(\\-10, 10), step\\=1)\n    y\\_precedence \\= param.Number(default\\=y.precedence, bounds\\=(\\-10, 10), step\\=1)\n    z\\_precedence \\= param.Number(default\\=z.precedence, bounds\\=(\\-10, 10), step\\=1)\n    dummy\\_app\\_display\\_threshold \\= param.Number(default\\=1, bounds\\=(\\-10, 10), step\\=1)\n\n    def \\_\\_init\\_\\_(self):\n        super().\\_\\_init\\_\\_()\n        \\# Building the dummy app as a Param pane in here so that its \\`\\`display\\_threshold\\`\\`\n        \\# parameter can be accessed and linked via @param.depends(...).\n        self.dummy\\_app \\= pn.Param(\n            self.param,\n            parameters\\=\\[\"x\", \"y\", \"z\"\\],\n            widgets\\={\n                \"x\": {\"background\": \"#fac400\"},\n                \"y\": {\"background\": \"#07d900\"},\n                \"z\": {\"background\": \"#00c0d9\"},\n            },\n            show\\_name\\=False\n        )\n\n    \\# Linking the two apps here.\n    @param.depends(\"dummy\\_app\\_display\\_threshold\", \"x\\_precedence\", \"y\\_precedence\", \"z\\_precedence\", watch\\=True)\n    def update\\_precedences\\_and\\_threshold(self):\n        self.param.x.precedence \\= self.x\\_precedence\n        self.param.y.precedence \\= self.y\\_precedence\n        self.param.z.precedence \\= self.z\\_precedence\n        self.dummy\\_app.display\\_threshold \\= self.dummy\\_app\\_display\\_threshold\n\nprecedence\\_model \\= Precedence()\n\n\\# Building the control app as a Param pane too.\ncontrol\\_app \\= pn.Param(\n    precedence\\_model.param,\n    parameters\\=\\[\"x\\_precedence\", \"y\\_precedence\", \"z\\_precedence\", \"dummy\\_app\\_display\\_threshold\"\\],\n    widgets\\={\n        \"x\\_precedence\": {\"styles\": {\"background\": \"#fac400\"}},\n        \"y\\_precedence\": {\"styles\": {\"background\": \"#07d900\"}},\n        \"z\\_precedence\": {\"styles\": {\"background\": \"#00c0d9\"}},\n    },\n    show\\_name\\=False\n)\n\n\\# Building the complete interactive example.\npn.Column(\n    \"## Precedence Example\",\n    \"Moving the sliders of the control app should update the display of the dummy app.\",\n    pn.Row(\n        pn.Column(\"\\*\\*Control app\\*\\*\", control\\_app),\n        pn.Column(\"\\*\\*Dummy app\\*\\*\", precedence\\_model.dummy\\_app)\n    )\n).servable()\n\n<ast>:18: PanelDeprecationWarning: \"FloatInput(..., background='#fac400')\" is deprecated and will be removed in version 1.4, use \"FloatInput(..., styles={'background': '#fac400'})\" instead.\n<ast>:18: PanelDeprecationWarning: \"TextInput(..., background='#00c0d9')\" is deprecated and will be removed in version 1.4, use \"TextInput(..., styles={'background': '#00c0d9'})\" instead.\n<ast>:18: PanelDeprecationWarning: \"Checkbox(..., background='#07d900')\" is deprecated and will be removed in version 1.4, use \"Checkbox(..., styles={'background': '#07d900'})\" instead."
},
{
  "markdown": "This guide addresses how to add notifications when the server connection is established and when it disconnects.\n\n* * *\n\nPanel includes a notification system that is enabled by default. The notification system also allows registering notification messages when the server connection is ready and when the server connection is lost. These can be configured by setting the `disconnect_notification` and `ready_notification`.\n\nimport panel as pn\n\npn.extension(\n    disconnect\\_notification\\='Connection lost, try reloading the page!',\n    ready\\_notification\\='Application fully loaded.',\n    template\\='bootstrap'\n)\n\nslider \\= pn.widgets.IntSlider(name\\='Number', start\\=1, end\\=10, value\\=7)\n\npn.Column(\n    slider,\n    pn.bind(lambda n: '⭐' \\* n, slider)\n).servable(title\\='Connection Notifications')\n\n![Connection notifications](https://assets.holoviz.org/panel/gifs/connection_notifications.gif)"
},
{
  "markdown": "## Streaming Bokeh[#](#streaming-bokeh \"Permalink to this heading\")\n\nimport numpy as np\nimport panel as pn\n\nfrom bokeh.plotting import figure\nfrom bokeh.models import ColumnDataSource\n\npn.extension(template\\='fast')\n\nThis example demonstrates how to use `add_periodic_callback` to stream data to a Bokeh plot.\n\np \\= figure(sizing\\_mode\\='stretch\\_width', title\\='Bokeh streaming example')\n\nxs \\= np.arange(1000)\nys \\= np.random.randn(1000).cumsum()\nx, y \\= xs\\[\\-1\\], ys\\[\\-1\\]\n\ncds \\= ColumnDataSource(data\\={'x': xs, 'y': ys})\n\np.line('x', 'y', source\\=cds)\n\ndef stream():\n    global x, y\n    x += 1\n    y += np.random.randn()\n    cds.stream({'x': \\[x\\], 'y': \\[y\\]})\n    pn.io.push\\_notebook(bk\\_pane) \\# Only needed when running in notebook context\n\ncb \\= pn.state.add\\_periodic\\_callback(stream, 100)\n\nbk\\_pane \\= pn.pane.Bokeh(p)\n\npn.Column(\n\tpn.Row(\n        cb.param.period,\n\t    pn.widgets.Toggle.from\\_param(cb.param.running, align\\='end')\n    ),\n\tbk\\_pane\n).servable()"
},
{
  "markdown": "## Streaming Indicator[#](#streaming-indicator \"Permalink to this heading\")\n\nimport numpy as np\nimport panel as pn\n\npn.extension(template\\='fast')\n\nThis example demonstrates how to use `add_periodic_callback` to stream data to the `Trend` indicator.\n\nlayout \\= pn.layout.FlexBox(\\*(\n    pn.indicators.Trend(\n        data\\={'x': list(range(10)), 'y': np.random.randn(10).cumsum()},\n        width\\=150,\n        height\\=100,\n        plot\\_type\\=pn.indicators.Trend.param.plot\\_type.objects\\[i%4\\]\n    ) for i in range(32)\n))\n\ndef stream():\n    for trend in layout:\n        trend.stream({'x': \\[trend.data\\['x'\\]\\[\\-1\\]+1\\], 'y': \\[trend.data\\['y'\\]\\[\\-1\\]+np.random.randn()\\]}, rollover\\=20)\n\ncb \\= pn.state.add\\_periodic\\_callback(stream, 500)\n\npn.Column(\n  pn.Row(\n      cb.param.period,\n\t  pn.widgets.Toggle.from\\_param(cb.param.running, align\\='end')\n  ),\n  layout\n).servable()"
},
{
  "markdown": "## Streaming Tabulator[#](#streaming-tabulator \"Permalink to this heading\")\n\nimport numpy as np\nimport pandas as pd\nimport panel as pn\n\npn.extension('tabulator', template\\='fast', sizing\\_mode\\=\"stretch\\_width\")\n\nThis example demonstrates how to use `add_periodic_callback` to stream data to a `Tabulator` pane.\n\ndf \\= pd.DataFrame(np.random.randn(10, 4), columns\\=list('ABCD')).cumsum()\n\nrollover \\= pn.widgets.IntInput(name\\='Rollover', value\\=15)\nfollow \\= pn.widgets.Checkbox(name\\='Follow', value\\=True, align\\='end')\n\ntabulator \\= pn.widgets.Tabulator(df, height\\=450)\n\ndef color\\_negative\\_red(val):\n    \"\"\"\n    Takes a scalar and returns a string with\n    the css property \\`'color: red'\\` for negative\n    strings, black otherwise.\n    \"\"\"\n    color \\= 'red' if val < 0 else 'green'\n    return 'color: %s' % color\n\ntabulator.style.applymap(color\\_negative\\_red)\n\ndef stream():\n    data \\= df.iloc\\[\\-1\\] + np.random.randn(4)\n    tabulator.stream(data, rollover\\=rollover.value, follow\\=follow.value)\n\ncb \\= pn.state.add\\_periodic\\_callback(stream, 200)\n\npn.Column(\n    pn.Row(cb.param.period, rollover, follow, width\\=400),\n    tabulator\n).servable()"
},
{
  "markdown": "## Streaming Perspective[#](#streaming-perspective \"Permalink to this heading\")\n\nimport numpy as np\nimport pandas as pd\nimport panel as pn\n\npn.extension('perspective', template\\='fast', sizing\\_mode\\='stretch\\_width')\n\nThis example demonstrates how to use `add_periodic_callback` to stream data to a `Perspective` pane.\n\ndf \\= pd.DataFrame(np.random.randn(10, 4), columns\\=list('ABCD')).cumsum()\n\nrollover \\= pn.widgets.IntInput(name\\='Rollover', value\\=15)\n\nperspective \\= pn.pane.Perspective(df, height\\=400)\n\ndef stream():\n    data \\= df.iloc\\[\\-1\\] + np.random.randn(4)\n    perspective.stream(data, rollover\\=rollover.value)\n\ncb \\= pn.state.add\\_periodic\\_callback(stream, 50)\n\npn.Column(\n    pn.Row(cb.param.period, rollover, perspective.param.theme),\n    perspective\n).servable()"
},
{
  "markdown": "## Sync Widgets and URL[#](#sync-widgets-and-url \"Permalink to this heading\")\n\nimport panel as pn\n\npn.extension(design\\='material', template\\='material')\n\npn.state.template.main\\_max\\_width \\= '768px'\n\nThis example demonstrates how to sync widget state with the URL bar, restoring it from the URL parameters on page load and updating it when the widgets change.\n\nwidget \\= pn.widgets.FloatSlider(name\\='Slider', start\\=0, end\\=10)\nwidget2 \\= pn.widgets.TextInput(name\\='Text')\nwidget3 \\= pn.widgets.RangeSlider(name\\='RangeSlider', start\\=0, end\\=10)\n\nif pn.state.location:\n    pn.state.location.sync(widget, {'value': 'slider\\_value'})\n    pn.state.location.sync(widget2, {'value': 'text\\_value'})\n    pn.state.location.sync(widget3, {'value': 'range\\_value'})\n\npn.Column(widget, widget2, widget3).servable()"
},
{
  "markdown": "## How-to[#](#how-to \"Permalink to this heading\")\n\nThe Panel How-to guides provide step by step recipes for solving essential problems and tasks that arise during your work. They assume that you’ve completed the Getting Started material and therefore already have some knowledge of how Panel works. There is no order to the guides, other than any potential prerequisites listed at the top of a page. Jump to the topic that is relevant to you now.\n\n## Prepare to develop[#](#prepare-to-develop \"Permalink to this heading\")\n\nDevelop in a notebook\n\nHow to effectively develop apps in a notebook environment.\n\nDevelop in an editor\n\nHow to effectively develop apps in a Python or Markdown file.\n\n## Build apps[#](#build-apps \"Permalink to this heading\")\n\nConstruct components\n\nHow to construct and customize individual components like an image or slider widget.\n\nArrange Components\n\nHow to arrange and size components on the page.\n\nStyle components\n\nHow to apply designs, themes and custom styling to components to achieve a polished look and feel.\n\nAdd interactivity\n\nHow to link add interactivity to your applications using reactive APIs.\n\nApply templates\n\nHow to use a Template to customize the look and feel of a deployed Panel app.\n\n## Use specialized UIs and APIs[#](#use-specialized-uis-and-apis \"Permalink to this heading\")\n\nBuild a sequential UI\n\nHow to build a Panel Pipeline that connects multiple panels into a sequential user interface.\n\nBuild custom components\n\nHow to extend Panel by building custom components.\n\nGenerate UIs from declared parameters (`Declarative API`)\n\nHow to use Parameterized classes with Panel to generate UIs without writing GUI code.\n\nExplicitly link parameters (`Callbacks API`)\n\nHow to link the parameters of Panel components in Python and Javascript.\n\n## Manage session tasks[#](#manage-session-tasks \"Permalink to this heading\")\n\nRegister session callbacks\n\nHow to set up callbacks on session related events (e.g. on page load or when a session is destroyed) and define periodic tasks.\n\nAccess session state\n\nHow to access and manipulate state related to the user session, HTTP request and URL arguments.\n\n## Test and debug[#](#test-and-debug \"Permalink to this heading\")\n\nEnable profiling and debugging\n\nHow to profile and debug your application using the admin dashboard and other tools.\n\nSet up testing for an application\n\nHow to set up unit tests, UI tests and load testing to ensure your applications are (and stay) robust and scalable.\n\n## Share your work[#](#share-your-work \"Permalink to this heading\")\n\nConfigure the server\n\nHow to configure the Panel server.\n\nIntegrate with other servers\n\nHow to integrate Panel in other application based on Flask, FastAPI or Django.\n\nDeploy applications\n\nHow to deploy Panel applications to various cloud providers (e.g. Azure, GCP, AWS etc.)\n\nExport apps\n\nHow to export and save Panel applications as static files.\n\nRun panel in WebAssembly\n\nHow to run Panel applications entirely in the browser using WebAssembly (Wasm), Pyodide, and PyScript.\n\n## Migrate to Panel[#](#migrate-to-panel \"Permalink to this heading\")\n\nMigrate from Streamlit\n\n[![https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)](https://assets.holoviz.org/panel/background/comparisons/streamlit_logo.png)\n\nHow to migrate existing Streamlit applications to Panel."
},
{
  "markdown": "## Create Chat Interfaces[#](#create-chat-interfaces \"Permalink to this heading\")\n\nBoth Streamlit and Panel provides special components to help you build conversational apps.\n\n| Streamlit | Panel | Description |\n| --- | --- | --- |\n| [`chat_message`](https://docs.streamlit.io/library/api-reference/chat/st.chat_message) | `ChatMessage` | Display a chat message |\n| [`chat_input`](https://docs.streamlit.io/library/api-reference/chat/st.chat_input) | [`ChatInput` example](https://holoviz-topics.github.io/panel-chat-examples/components/#chat_input) | Input a chat message |\n| [`status`](https://docs.streamlit.io/library/api-reference/status/st.status) | [`Status` example](https://holoviz-topics.github.io/panel-chat-examples/components/#status) | Display the output of long-running tasks in a container |\n|     | `ChatFeed` | Display multiple chat messages |\n|     | `ChatInterface` | High-level, easy to use chat interface |\n| [`StreamlitCallbackHandler`](https://python.langchain.com/docs/integrations/callbacks/streamlit) | `PanelCallbackHandler` | Display the thoughts and actions of a [LangChain](https://python.langchain.com/docs/get_started/introduction) agent |\n| [`StreamlitChatMessageHistory`](https://python.langchain.com/docs/integrations/memory/streamlit_chat_message_history) |     | Persist the memory of a [LangChain](https://python.langchain.com/docs/get_started/introduction) agent |\n\nThe starting point for most Panel users is the _high-level_ `ChatInterface` or `PanelCallbackHandler`, not the _low-level_ `ChatMessage` and `ChatFeed` components.\n\n## Chat Message[#](#chat-message \"Permalink to this heading\")\n\nLets see how-to migrate an app that is using `st.chat_message`.\n\n### Streamlit Chat Message Example[#](#streamlit-chat-message-example \"Permalink to this heading\")\n\nimport streamlit as st\n\nwith st.chat\\_message(\"user\"):\n    st.image(\"https://streamlit.io/images/brand/streamlit-logo-primary-colormark-darktext.png\")\n    st.write(\"# A faster way to build and share data apps\")\n\n![Streamlit chat_entry](https://panel.holoviz.org/_images/streamlit_chat_message.png)\n\n### Panel Chat Message Example[#](#panel-chat-message-example \"Permalink to this heading\")\n\nimport panel as pn\n\npn.extension(design\\=\"material\")\n\nmessage \\= pn.Column(\n    \"https://panel.holoviz.org/\\_images/logo\\_horizontal\\_light\\_theme.png\",\n    \"# The powerful data exploration & web app framework for Python\"\n)\npn.chat.ChatMessage(message, user\\=\"user\").servable()\n\n![Panel ChatEntry](https://panel.holoviz.org/_images/panel_chat_entry.png)\n\n## Echo Bot[#](#echo-bot \"Permalink to this heading\")\n\nLets see how to migrate a bot that echoes the user input.\n\n### Streamlit Echo Bot[#](#streamlit-echo-bot \"Permalink to this heading\")\n\nimport streamlit as st\n\ndef echo(prompt):\n    return f\"Echo: {prompt}\"\n\nst.title(\"Echo Bot\")\n\nif \"messages\" not in st.session\\_state:\n    st.session\\_state.messages \\= \\[\\]\n\nfor message in st.session\\_state.messages:\n    with st.chat\\_message(message\\[\"role\"\\]):\n        st.markdown(message\\[\"content\"\\])\n\nif prompt := st.chat\\_input(\"What is up?\"):\n    st.chat\\_message(\"user\").markdown(prompt)\n    st.session\\_state.messages.append({\"role\": \"user\", \"content\": prompt})\n    response \\= echo(prompt)\n\n    with st.chat\\_message(\"assistant\"):\n        st.markdown(response)\n    st.session\\_state.messages.append({\"role\": \"assistant\", \"content\": response})\n\n![Streamlit Echo Bot](https://panel.holoviz.org/_images/streamlit_echo_bot.png)\n\n### Panel Echo Bot[#](#panel-echo-bot \"Permalink to this heading\")\n\nimport panel as pn\n\npn.extension(design\\=\"material\")\n\ndef echo(contents, user, instance):\n    return f\"Echo: {contents}\"\n\nchat\\_interface \\= pn.chat.ChatInterface(\n    callback\\=echo,\n)\n\npn.Column(\n    \"# Echo Bot\",\n    chat\\_interface,\n).servable()\n\n![Panel Echo Bot](https://panel.holoviz.org/_images/panel_echo_bot.png)\n\n## Search Agent with Chain of thought[#](#search-agent-with-chain-of-thought \"Permalink to this heading\")\n\nLets try to migrate an agent that uses the Duck Duck Go search tool and shows its _chain of thought_.\n\n### Streamlit Search Agent with Chain of thought[#](#streamlit-search-agent-with-chain-of-thought \"Permalink to this heading\")\n\nfrom langchain.llms import OpenAI\nfrom langchain.agents import AgentType, initialize\\_agent, load\\_tools\nfrom langchain.callbacks import StreamlitCallbackHandler\nimport streamlit as st\n\nllm \\= OpenAI(temperature\\=0, streaming\\=True)\ntools \\= load\\_tools(\\[\"ddg-search\"\\])\nagent \\= initialize\\_agent(\n    tools, llm, agent\\=AgentType.ZERO\\_SHOT\\_REACT\\_DESCRIPTION, verbose\\=True\n)\n\nif prompt := st.chat\\_input():\n    st.chat\\_message(\"user\").write(prompt)\n    with st.chat\\_message(\"assistant\"):\n        st\\_callback \\= StreamlitCallbackHandler(st.container())\n        response \\= agent.run(prompt, callbacks\\=\\[st\\_callback\\])\n        st.write(response)\n\n Your browser does not support the video tag.\n\n### Panel Search Agent with Chain of thought[#](#panel-search-agent-with-chain-of-thought \"Permalink to this heading\")\n\nfrom langchain.llms import OpenAI\nfrom langchain.agents import AgentType, initialize\\_agent, load\\_tools\nimport panel as pn\n\npn.extension(design\\=\"material\")\n\nllm \\= OpenAI(temperature\\=0, streaming\\=True)\ntools \\= load\\_tools(\\[\"ddg-search\"\\])\nagent \\= initialize\\_agent(\n    tools, llm, agent\\=AgentType.ZERO\\_SHOT\\_REACT\\_DESCRIPTION, verbose\\=True,\n)\n\nasync def callback(contents, user, instance):\n    callback\\_handler \\= pn.chat.langchain.PanelCallbackHandler(instance)\n    await agent.arun(contents, callbacks\\=\\[callback\\_handler\\])\n\npn.chat.ChatInterface(callback\\=callback).servable()\n\n Your browser does not support the video tag.\n\n## More Panel Chat Examples[#](#more-panel-chat-examples \"Permalink to this heading\")\n\nFor more inspiration check out [panel-chat-examples](https://holoviz-topics.github.io/panel-chat-examples/)."
},
{
  "markdown": "## Preview Apps in JupyterLab[#](#preview-apps-in-jupyterlab \"Permalink to this heading\")\n\nThis guide addresses how to use the _Preview_ functionality in JupyterLab to rapidly develop applications.\n\n* * *\n\nWith this functionality you can preview the app you are building in a JupyterLab tab right next to your code. This is a traditional setup for web developers, who like to quickly visualize the effects of their code changes.\n\nTo have your app appear in the _Preview_, you need to mark the objects you want to display with `.servable()`. This is identical to how you would mark objects that you want to serve with `panel serve ...`.\n\nYou can enable the _Preview_ by clicking on Panel’s logo in the menu bar of your notebook. Once clicked, you should see a new tab being opened next to your notebook tab, and after some moment your app will be rendered in this tab.\n\n![JupyterLab Preview](https://panel.holoviz.org/_images/jlabpreview.png)\n\nThe _Preview_ offers two update modes that are configurable in the preview tab:\n\n*   manual: click on the _Reload_ button () to re-run and re-render your app.\n    \n*   automatic: toggle the _Render on save_ checkbox () for the app to be automatically re-rendered when you save your notebook.\n    \n\nTip\n\nPanel built-in templates don’t render necessarily well in a notebook as their styling can badly interact with the notebook built-in styling. Using the _Preview_ is a good way to circumvent this issue, while still being able to work within JupyterLab ."
},
{
  "markdown": "## Configure VS Code[#](#configure-vs-code \"Permalink to this heading\")\n\nThis guide addresses how to configure VS Code for an efficient Panel development workflow.\n\nWe assume you have\n\n*   a basic understanding of [developing Panel apps in an editor](https://panel.holoviz.org/how_to/editor/editor.html) and [working with Python in VS Code](https://code.visualstudio.com/docs/python/python-tutorial).\n    \n*   installed the VS Code [Python extension](https://github.com/Microsoft/vscode-python)\n    \n\n* * *\n\n## Debugging[#](#debugging \"Permalink to this heading\")\n\nTo learn how to use the _integrated debugger_ in general check out [the official guide](https://code.visualstudio.com/docs/editor/debugging).\n\nTo configure the integrated debugger for Panel, you will need to add a debugging configuration like the below.\n\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": \\[\n        {\n            \"name\": \"panel serve\",\n            \"type\": \"python\",\n            \"request\": \"launch\",\n            \"program\": \"-m\",\n            \"args\": \\[\n                \"panel\",\n                \"serve\",\n                \"${relativeFile}\",\n                \"--show\"\n            \\],\n            \"console\": \"integratedTerminal\",\n            \"justMyCode\": true\n        },\n    \\]\n}\n\nIn use it looks like\n\n![Integrated Debugging of a Panel app in VS Code](https://panel.holoviz.org/_images/vscode-integrated-debugging.png)\n\n## Extensions[#](#extensions \"Permalink to this heading\")\n\nThe following extensions will help speed up your Panel workflow\n\n*   [Live Server](https://github.com/ritwickdey/vscode-live-server-plus-plus): Enables you to easily view `.html` files created using `.save()` or `panel convert`.\n    \n\n## General Settings[#](#general-settings \"Permalink to this heading\")\n\nWe recommend adding the below to your `settings.json` file.\n\n\"explorer.copyRelativePathSeparator\": \"/\" \\# Relevant on Windows only\n\n## Keyboard Shortcuts[#](#keyboard-shortcuts \"Permalink to this heading\")\n\nTo speed up your workflow we recommend configuring a keyboard short cut to `panel serve` your app.\n\n\\[\n    {\n        \"key\": \"ctrl+shift+space\",\n        \"command\": \"workbench.action.terminal.sendSequence\",\n        \"args\": { \"text\": \"panel serve ${relativeFile} --autoreload --show\\\\u000D\" }\n    }\n\\]\n\nOn Windows you will need to add quotes around `${relativeFile}`, i.e. replace it with `'${relativeFile}'`.\n\nWhen you press `CTRL+SHIFT+SPACE` you will `panel serve` your file in the terminal, if you have an open terminal.\n\n## Notebook and Interactive Environment[#](#notebook-and-interactive-environment \"Permalink to this heading\")\n\nEnsure you install `jupyter_bokeh` with `pip install jupyter_bokeh` or `conda install -c bokeh jupyter_bokeh` and then enable the extension with `pn.extension()`.\n\nYou can see a notebook in action below.\n\n![Panel in VS Code Notebook Environment](https://panel.holoviz.org/_images/vscode-notebook.png)\n\n## Snippets[#](#snippets \"Permalink to this heading\")\n\nTo speed up your workflow you can configure [_user defined snippets_](https://code.visualstudio.com/docs/editor/userdefinedsnippets) like these [example Panel snippets](https://panel.holoviz.org/_downloads/877953fdfd7410b5f9c8b922ee063024/vscode-snippets-python.json). When you start typing `import panel` you will get the option to select between the snippets as shown below.\n\n![Panel VS Code Snippets](https://panel.holoviz.org/_images/vscode-snippets-python.png)\n\nThe snippets will be available in the script, notebook and the interactive environments."
},
{
  "markdown": "This guide addresses how to debug apps in your favorite IDE or editor.\n\n* * *\n\nThe simplest way to debug is to insert a `breakpoint()` in your code and then serve your app from a terminal. Type `help` in the debugger to see the available _commands_.\n\n![](https://panel.holoviz.org/_static/images/terminal-breakpoint.png)\n\nIf your editor or IDE provides _integrated debugging_ you can also use that in one of two ways.\n\n*   Use `.servable()` and configure your editor to start debugging using the command `python -m panel serve <name-of-script.py>`. This is our recommended method.\n    \n*   Use `.show()` on a single Panel component. This is an alternative method.\n    \n\nFor more details check out the VS Code Debug Configuration Guide."
},
{
  "markdown": "## Customize a Design[#](#customize-a-design \"Permalink to this heading\")\n\nThis guide addresses how to customize a design system with CSS variables.\n\nNew in version 1.0.0: The design feature was added in 1.0.0 and is actively being developed and improved. Currently there are a limited number of design variables but in future the goal is to expose a large variety of styling options via CSS variables.\n\nPrerequisites\n\n1.  The [How-to > Apply a Design](https://panel.holoviz.org/how_to/styling/design.html) guides describe how to select a design system to apply to the components to achieve a consistent design language.\n    \n2.  The [How-to > Apply CSS](https://panel.holoviz.org/how_to/styling/apply_css.html) guide describes how to apply CSS definitions in Panel.\n    \n\n* * *\n\nThe Design systems in Panel are set up to be overridden by CSS variables. The usual order of fallbacks for CSS variables is the following:\n\n1.  User defined design variables (e.g. `--design-primary-color`)\n    \n2.  Editor/notebook dependent variables (e.g. `--jp-brand-color0`, for JupyterLab)\n    \n3.  The theme CSS variable definitions (e.g. `--panel-primary-color`)\n    \n\nTo override a particular style we therefore simply have to override one of the user defined design variables:\n\n| Variable | Description |\n| --- | --- |\n| `--design-primary-color` | Primary color of the design. |\n| `--design-primary-text-color` | Color of text rendered on top of primary color. |\n| `--design-secondary-color` | Secondary color of the design. |\n| `--design-secondary-text-color` | Color of text rendered on top of secondary color. |\n| `--design-background-color` | Color of the background layer. |\n| `--design-background-text-color` | Color of text rendered on top of the background layer. |\n| `--design-surface-color` | Color of the surface layer. |\n| `--design-surface-text-color` | Color of text rendered on top of the surface layer. |\n\nNote\n\nBackground and surface colors generally are only set at the template level.\n\nWhen and how to set these variables depends on the precise use case, e.g. if you consistently want to override the colors in a template, use the `Template.config.raw_css` or `Template.config.css_files` parameters to define an inline or imported stylesheet that will apply across the entire template.\n\nFor global overrides that apply in all scenarios you can use the `pn.config.global_css` parameter, e.g. here we initialize it via the `pn.extension`:\n\nimport panel as pn\n\npn.extension(design\\='material', global\\_css\\=\\[':root { --design-primary-color: purple; }'\\])\n\nWhen defining design variable overrides globally use the `:root` CSS selector, which applies the variable from the root on down.\n\npn.Tabs(\n    ('Slider', pn.widgets.FloatSlider(start\\=0, end\\=7, value\\=3)),\n    ('Button', pn.widgets.Button(name\\='Click me!', button\\_type\\='primary'))\n)\n\nAlternatively you can also define it directly on a component by adding it to the `stylesheets` and prefixing it with the `:host` selector:\n\npn.Tabs(\n    ('Slider', pn.widgets.FloatSlider(\n\t    start\\=0, end\\=7, value\\=3, stylesheets\\=\\[':host { --design-primary-color: red; }'\\]\n\t)),\n    ('Button', pn.widgets.Button(name\\='Click me!', button\\_type\\='primary'))\n)"
}]